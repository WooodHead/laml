/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var YAMLException = __webpack_require__(5);

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

  // Source: https://stackoverflow.com/a/27404602/1339651
module.exports.renameTag = function(document, nodeOrSelector, newTagName, classOrTrue) {
    let node = nodeOrSelector;
    if (typeof node === 'string') node = document.querySelector(nodeOrSelector);
    if (!node) return new Error('No node found');
    let className = '';
    if (classOrTrue && classOrTrue === true) className = node.tagName.toLowerCase();
    if (typeof classOrTrue === 'string') className = classOrTrue;

    const newNode = document.createElement(newTagName);
    while (node.firstChild) newNode.appendChild(node.firstChild);
    for (let attribute of node.attributes) {
      newNode.setAttribute(attribute.name, attribute.value);
    }
    newNode.setAttribute('data-originalTagName', node.tagName.toLowerCase());
    if (className !== '') newNode.classList.add(className);
    node.parentNode.replaceChild(newNode, node);
    return newNode;
  };


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len*/

var common        = __webpack_require__(2);
var YAMLException = __webpack_require__(5);
var Type          = __webpack_require__(0);


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var encode = __webpack_require__(62);
var decode = __webpack_require__(63);

var C_BACKSLASH = 92;

var decodeHTML = __webpack_require__(12).decodeHTML;

var ENTITY = "&(?:#x[a-f0-9]{1,8}|#[0-9]{1,8}|[a-z][a-z0-9]{1,31});";

var TAGNAME = '[A-Za-z][A-Za-z0-9-]*';
var ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
var UNQUOTEDVALUE = "[^\"'=<>`\\x00-\\x20]+";
var SINGLEQUOTEDVALUE = "'[^']*'";
var DOUBLEQUOTEDVALUE = '"[^"]*"';
var ATTRIBUTEVALUE = "(?:" + UNQUOTEDVALUE + "|" + SINGLEQUOTEDVALUE + "|" + DOUBLEQUOTEDVALUE + ")";
var ATTRIBUTEVALUESPEC = "(?:" + "\\s*=" + "\\s*" + ATTRIBUTEVALUE + ")";
var ATTRIBUTE = "(?:" + "\\s+" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)";
var OPENTAG = "<" + TAGNAME + ATTRIBUTE + "*" + "\\s*/?>";
var CLOSETAG = "</" + TAGNAME + "\\s*[>]";
var HTMLCOMMENT = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var PROCESSINGINSTRUCTION = "[<][?].*?[?][>]";
var DECLARATION = "<![A-Z]+" + "\\s+[^>]*>";
var CDATA = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTMLTAG = "(?:" + OPENTAG + "|" + CLOSETAG + "|" + HTMLCOMMENT + "|" +
        PROCESSINGINSTRUCTION + "|" + DECLARATION + "|" + CDATA + ")";
var reHtmlTag = new RegExp('^' + HTMLTAG, 'i');

var reBackslashOrAmp = /[\\&]/;

var ESCAPABLE = '[!"#$%&\'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]';

var reEntityOrEscapedChar = new RegExp('\\\\' + ESCAPABLE + '|' + ENTITY, 'gi');

var XMLSPECIAL = '[&<>"]';

var reXmlSpecial = new RegExp(XMLSPECIAL, 'g');

var reXmlSpecialOrEntity = new RegExp(ENTITY + '|' + XMLSPECIAL, 'gi');

var unescapeChar = function(s) {
    if (s.charCodeAt(0) === C_BACKSLASH) {
        return s.charAt(1);
    } else {
        return decodeHTML(s);
    }
};

// Replace entities and backslash escapes with literal characters.
var unescapeString = function(s) {
    if (reBackslashOrAmp.test(s)) {
        return s.replace(reEntityOrEscapedChar, unescapeChar);
    } else {
        return s;
    }
};

var normalizeURI = function(uri) {
    try {
        return encode(decode(uri));
    }
    catch(err) {
        return uri;
    }
};

var replaceUnsafeChar = function(s) {
    switch (s) {
    case '&':
        return '&amp;';
    case '<':
        return '&lt;';
    case '>':
        return '&gt;';
    case '"':
        return '&quot;';
    default:
        return s;
    }
};

var escapeXml = function(s, preserve_entities) {
    if (reXmlSpecial.test(s)) {
        if (preserve_entities) {
            return s.replace(reXmlSpecialOrEntity, replaceUnsafeChar);
        } else {
            return s.replace(reXmlSpecial, replaceUnsafeChar);
        }
    } else {
        return s;
    }
};

module.exports = { unescapeString: unescapeString,
                   normalizeURI: normalizeURI,
                   escapeXml: escapeXml,
                   reHtmlTag: reHtmlTag,
                   OPENTAG: OPENTAG,
                   CLOSETAG: CLOSETAG,
                   ENTITY: ENTITY,
                   ESCAPABLE: ESCAPABLE
                 };


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)





var Schema = __webpack_require__(3);


module.exports = new Schema({
  include: [
    __webpack_require__(10)
  ],
  implicit: [
    __webpack_require__(31),
    __webpack_require__(32)
  ],
  explicit: [
    __webpack_require__(33),
    __webpack_require__(39),
    __webpack_require__(40),
    __webpack_require__(41)
  ]
});


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.





var Schema = __webpack_require__(3);


module.exports = Schema.DEFAULT = new Schema({
  include: [
    __webpack_require__(6)
  ],
  explicit: [
    __webpack_require__(42),
    __webpack_require__(43),
    __webpack_require__(44)
  ]
});


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346





var Schema = __webpack_require__(3);


module.exports = new Schema({
  explicit: [
    __webpack_require__(24),
    __webpack_require__(25),
    __webpack_require__(26)
  ]
});


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isContainer(node) {
    switch (node._type) {
    case 'document':
    case 'block_quote':
    case 'list':
    case 'item':
    case 'paragraph':
    case 'heading':
    case 'emph':
    case 'strong':
    case 'link':
    case 'image':
    case 'custom_inline':
    case 'custom_block':
        return true;
    default:
        return false;
    }
}

var resumeAt = function(node, entering) {
    this.current = node;
    this.entering = (entering === true);
};

var next = function(){
    var cur = this.current;
    var entering = this.entering;

    if (cur === null) {
        return null;
    }

    var container = isContainer(cur);

    if (entering && container) {
        if (cur._firstChild) {
            this.current = cur._firstChild;
            this.entering = true;
        } else {
            // stay on node but exit
            this.entering = false;
        }

    } else if (cur === this.root) {
        this.current = null;

    } else if (cur._next === null) {
        this.current = cur._parent;
        this.entering = false;

    } else {
        this.current = cur._next;
        this.entering = true;
    }

    return {entering: entering, node: cur};
};

var NodeWalker = function(root) {
    return { current: root,
             root: root,
             entering: true,
             next: next,
             resumeAt: resumeAt };
};

var Node = function(nodeType, sourcepos) {
    this._type = nodeType;
    this._parent = null;
    this._firstChild = null;
    this._lastChild = null;
    this._prev = null;
    this._next = null;
    this._sourcepos = sourcepos;
    this._lastLineBlank = false;
    this._open = true;
    this._string_content = null;
    this._literal = null;
    this._listData = {};
    this._info = null;
    this._destination = null;
    this._title = null;
    this._isFenced = false;
    this._fenceChar = null;
    this._fenceLength = 0;
    this._fenceOffset = null;
    this._level = null;
    this._onEnter = null;
    this._onExit = null;
};

var proto = Node.prototype;

Object.defineProperty(proto, 'isContainer', {
    get: function () { return isContainer(this); }
});

Object.defineProperty(proto, 'type', {
    get: function() { return this._type; }
});

Object.defineProperty(proto, 'firstChild', {
    get: function() { return this._firstChild; }
});

Object.defineProperty(proto, 'lastChild', {
    get: function() { return this._lastChild; }
});

Object.defineProperty(proto, 'next', {
    get: function() { return this._next; }
});

Object.defineProperty(proto, 'prev', {
    get: function() { return this._prev; }
});

Object.defineProperty(proto, 'parent', {
    get: function() { return this._parent; }
});

Object.defineProperty(proto, 'sourcepos', {
    get: function() { return this._sourcepos; }
});

Object.defineProperty(proto, 'literal', {
    get: function() { return this._literal; },
    set: function(s) { this._literal = s; }
});

Object.defineProperty(proto, 'destination', {
    get: function() { return this._destination; },
    set: function(s) { this._destination = s; }
});

Object.defineProperty(proto, 'title', {
    get: function() { return this._title; },
    set: function(s) { this._title = s; }
});

Object.defineProperty(proto, 'info', {
    get: function() { return this._info; },
    set: function(s) { this._info = s; }
});

Object.defineProperty(proto, 'level', {
    get: function() { return this._level; },
    set: function(s) { this._level = s; }
});

Object.defineProperty(proto, 'listType', {
    get: function() { return this._listData.type; },
    set: function(t) { this._listData.type = t; }
});

Object.defineProperty(proto, 'listTight', {
    get: function() { return this._listData.tight; },
    set: function(t) { this._listData.tight = t; }
});

Object.defineProperty(proto, 'listStart', {
    get: function() { return this._listData.start; },
    set: function(n) { this._listData.start = n; }
});

Object.defineProperty(proto, 'listDelimiter', {
    get: function() { return this._listData.delimiter; },
    set: function(delim) { this._listData.delimiter = delim; }
});

Object.defineProperty(proto, 'onEnter', {
    get: function() { return this._onEnter; },
    set: function(s) { this._onEnter = s; }
});

Object.defineProperty(proto, 'onExit', {
    get: function() { return this._onExit; },
    set: function(s) { this._onExit = s; }
});

Node.prototype.appendChild = function(child) {
    child.unlink();
    child._parent = this;
    if (this._lastChild) {
        this._lastChild._next = child;
        child._prev = this._lastChild;
        this._lastChild = child;
    } else {
        this._firstChild = child;
        this._lastChild = child;
    }
};

Node.prototype.prependChild = function(child) {
    child.unlink();
    child._parent = this;
    if (this._firstChild) {
        this._firstChild._prev = child;
        child._next = this._firstChild;
        this._firstChild = child;
    } else {
        this._firstChild = child;
        this._lastChild = child;
    }
};

Node.prototype.unlink = function() {
    if (this._prev) {
        this._prev._next = this._next;
    } else if (this._parent) {
        this._parent._firstChild = this._next;
    }
    if (this._next) {
        this._next._prev = this._prev;
    } else if (this._parent) {
        this._parent._lastChild = this._prev;
    }
    this._parent = null;
    this._next = null;
    this._prev = null;
};

Node.prototype.insertAfter = function(sibling) {
    sibling.unlink();
    sibling._next = this._next;
    if (sibling._next) {
        sibling._next._prev = sibling;
    }
    sibling._prev = this;
    this._next = sibling;
    sibling._parent = this._parent;
    if (!sibling._next) {
        sibling._parent._lastChild = sibling;
    }
};

Node.prototype.insertBefore = function(sibling) {
    sibling.unlink();
    sibling._prev = this._prev;
    if (sibling._prev) {
        sibling._prev._next = sibling;
    }
    sibling._next = this;
    this._prev = sibling;
    sibling._parent = this._parent;
    if (!sibling._prev) {
        sibling._parent._firstChild = sibling;
    }
};

Node.prototype.walker = function() {
    var walker = new NodeWalker(this);
    return walker;
};

module.exports = Node;


/* Example of use of walker:

 var walker = w.walker();
 var event;

 while (event = walker.next()) {
 console.log(event.entering, event.node.type);
 }

 */


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.





var Schema = __webpack_require__(3);


module.exports = new Schema({
  include: [
    __webpack_require__(11)
  ]
});


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.





var Schema = __webpack_require__(3);


module.exports = new Schema({
  include: [
    __webpack_require__(8)
  ],
  implicit: [
    __webpack_require__(27),
    __webpack_require__(28),
    __webpack_require__(29),
    __webpack_require__(30)
  ]
});


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var encode = __webpack_require__(64),
    decode = __webpack_require__(65);

exports.decode = function(data, level){
	return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
};

exports.decodeStrict = function(data, level){
	return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
};

exports.encode = function(data, level){
	return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
};

exports.encodeXML = encode.XML;

exports.encodeHTML4 =
exports.encodeHTML5 =
exports.encodeHTML  = encode.HTML;

exports.decodeXML =
exports.decodeXMLStrict = decode.XML;

exports.decodeHTML4 =
exports.decodeHTML5 =
exports.decodeHTML = decode.HTML;

exports.decodeHTML4Strict =
exports.decodeHTML5Strict =
exports.decodeHTMLStrict = decode.HTMLStrict;

exports.escape = encode.escape;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = {"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\"","QUOT":"\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function Renderer() {}

/**
 *  Walks the AST and calls member methods for each Node type.
 *
 *  @param ast {Node} The root of the abstract syntax tree.
 */
function render(ast) {
  var walker = ast.walker()
    , event
    , type;

  this.buffer = '';
  this.lastOut = '\n';

  while((event = walker.next())) {
    type = event.node.type;
    if (this[type]) {
      this[type](event.node, event.entering);
    }
  }
  return this.buffer;
}

/**
 *  Concatenate a literal string to the buffer.
 *
 *  @param str {String} The string to concatenate.
 */
function lit(str) {
  this.buffer += str;
  this.lastOut = str;
}

/**
 *  Output a newline to the buffer.
 */
function cr() {
  if (this.lastOut !== '\n') {
    this.lit('\n');
  }
}

/**
 *  Concatenate a string to the buffer possibly escaping the content.
 *
 *  Concrete renderer implementations should override this method.
 *
 *  @param str {String} The string to concatenate.
 */
function out(str) {
  this.lit(str);
}

/**
 *  Escape a string for the target renderer.
 *
 *  Abstract function that should be implemented by concrete 
 *  renderer implementations.
 *
 *  @param str {String} The string to escape.
 */
function esc(str) {
  return str;
}

Renderer.prototype.render = render;
Renderer.prototype.out = out;
Renderer.prototype.lit = lit;
Renderer.prototype.cr  = cr;
Renderer.prototype.esc  = esc;

module.exports = Renderer;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {const laml = __webpack_require__(18);
const {tex2jax} = __webpack_require__(59);
const commonmark = __webpack_require__(60);

const htmlHead = __webpack_require__(75);
const paragraphs = __webpack_require__(76);

const worker = function(window) {
  const document = window.document;
  htmlHead(document);
  paragraphs(document);

  window.tex2jax = tex2jax;
  window.tex2jax.config.doc = document;
  window.tex2jax.config.inlineMath.push(['$', '$']);
  window.tex2jax.config.processEscapes = true;
  window.tex2jax.PreProcess();


  const reader = new commonmark.Parser();
  const writer = new commonmark.HtmlRenderer();
  const parsed = reader.parse(document.body.innerHTML);
  document.body.innerHTML = writer.render(parsed);

  laml(document);
};

if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'){
    module.exports.worker = worker;
}
else {
  worker(window);
  window.MathJax = {
    'fast-preview': {
      disabled: true
    }
  };
  const mj = document.createElement('script');
  mj.src =
    'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-AMS_CHTML-full';
  document.head.appendChild(mj);

}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

const { renameTag } = __webpack_require__(1);
const yamldata = __webpack_require__(19)
const metadata = __webpack_require__(47);
const preamble = __webpack_require__(48);
const abstract = __webpack_require__(49);
const sectioning = __webpack_require__(50);
const statements = __webpack_require__(51);
const figures = __webpack_require__(52);
const names = __webpack_require__(53);
const blames = __webpack_require__(54);
const refs = __webpack_require__(55);
const cites = __webpack_require__(56);
const notes = __webpack_require__(57);
const bibliography = __webpack_require__(58)

module.exports = function(document) {
  yamldata(document);
  const data = metadata(document);
  preamble(document);
  abstract(document);
  sectioning(document);
  statements(document, data.laml.statements);
  figures(document, false);
  names(document);
  // TODO should depend on cm.css?
  blames(document);
  refs(document);
  cites(document);
  notes(document);
  bibliography(document);
};



/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

const yaml = __webpack_require__(20);

module.exports = function(document) {
  // convert yaml to json metadata
  // TODO think about schema.org markup
  const yamldata = yaml.safeLoad(document.querySelector('script[type="application/yaml"]').text);
  if (!yamldata) return ;
  const metadata = document.createElement('script');
  metadata.setAttribute('type', 'application/json');
  metadata.setAttribute('data-laml', 'metadata');
  metadata.text = JSON.stringify(yamldata);
  document.head.appendChild(metadata);
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var yaml = __webpack_require__(21);


module.exports = yaml;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var loader = __webpack_require__(22);
var dumper = __webpack_require__(46);


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = __webpack_require__(0);
module.exports.Schema              = __webpack_require__(3);
module.exports.FAILSAFE_SCHEMA     = __webpack_require__(8);
module.exports.JSON_SCHEMA         = __webpack_require__(11);
module.exports.CORE_SCHEMA         = __webpack_require__(10);
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(6);
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(7);
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = __webpack_require__(5);

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(8);
module.exports.SAFE_SCHEMA    = __webpack_require__(6);
module.exports.DEFAULT_SCHEMA = __webpack_require__(7);

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len,no-use-before-define*/

var common              = __webpack_require__(2);
var YAMLException       = __webpack_require__(5);
var Mark                = __webpack_require__(23);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(6);
var DEFAULT_FULL_SCHEMA = __webpack_require__(7);


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var common = __webpack_require__(2);


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(2);
var Type   = __webpack_require__(0);

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(2);
var Type   = __webpack_require__(0);

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var require;

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = require;
  NodeBuffer = __webpack_require__(34).Buffer;
} catch (__) {}

var Type       = __webpack_require__(0);


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(36)
var ieee754 = __webpack_require__(37)
var isArray = __webpack_require__(38)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))

/***/ }),
/* 35 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 37 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 38 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(0);

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var require;

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = __webpack_require__(45);
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __webpack_require__(0);

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        ast.body[0].expression.type !== 'FunctionExpression') {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      ast.body[0].expression.type !== 'FunctionExpression') {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  /*eslint-disable no-new-func*/
  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
/* istanbul ignore next */
	else if(typeof exports === 'object')
		exports["esprima"] = factory();
	else
		root["esprima"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.0';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token) {
	        return {
	            index: token.start,
	            line: token.lineNumber,
	            column: token.start - token.lineStart
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            markers.pop();
	            while (i > 1) {
	                var node = this.startNode(markers.pop());
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = !this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */) {
	                        if (token.value === 'get' || token.value === 'set') {
	                            this.tolerateUnexpectedToken(token);
	                        }
	                        else if (token.value === 'constructor') {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                        }
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable no-use-before-define*/

var common              = __webpack_require__(2);
var YAMLException       = __webpack_require__(5);
var DEFAULT_FULL_SCHEMA = __webpack_require__(7);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(6);

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema       = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent       = Math.max(1, (options['indent'] || 2));
  this.skipInvalid  = options['skipInvalid'] || false;
  this.flowLevel    = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap     = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys     = options['sortKeys'] || false;
  this.lineWidth    = options['lineWidth'] || 80;
  this.noRefs       = options['noRefs'] || false;
  this.noCompatMode = options['noCompatMode'] || false;
  this.condenseFlow = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    && c !== CHAR_COLON
    && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (string[0] === ' ' && indentPerLevel > 9) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = (string[0] === ' ') ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;


/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = function(document) {
  // handle metadata
  const metadata = JSON.parse(document.querySelector('script[data-laml="metadata"]').text);
  if (!metadata) return;
  const articleInfo = document.createElement('section');
  articleInfo.classList.add('articleInfo');
  document.body.insertBefore(articleInfo, document.body.firstChild);
  const articleTitle = metadata.title;
  if (articleTitle) {
    const title = document.querySelector('title');
    if (title) title.innerHTML = articleTitle;
    else {
      newtitle = document.createElement('title');
      newtitle.innerHTML = articleTitle;
      document.head.appendChild(newtitle);
    }
    const heading = document.createElement('h1');
    heading.innerHTML = articleTitle;
    articleInfo.appendChild(heading);
  }
  const articleAuthors = metadata.authors || [];
  for (let author of articleAuthors) {
    const name = author.name;
    const address = author.address;
    const authorP = document.createElement('p');
    authorP.classList.add('author');
    authorP.innerHTML = name + ', ' + address + '.';
    articleInfo.appendChild(authorP);
  }
  const keywords = metadata.keywords;
  const kw = document.createElement('p');
  kw.classList.add('keywords');
  kw.innerHTML = 'Keywords: ' + keywords.join(', ') + '.';
  articleInfo.appendChild(kw);

  const licensing = document.createElement('p');
  licensing.classList.add('license');

  licensing.innerHTML =
    'Derived from <a href="' +
    metadata.source +
    '">' +
    metadata.source +
    '</a>, ' +
    metadata.license +
    ' and licensed as such.';
  articleInfo.appendChild(licensing);
  return metadata;
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

const { renameTag } = __webpack_require__(1);
module.exports = function(document){
  // preamble
  renameTag(document,'preamble', 'div', 'hidden');
}


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

const { renameTag } = __webpack_require__(1);
module.exports = function(document){
  // abstract
  renameTag(document, 'abstract', 'section', true);
}


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

const { renameTag } = __webpack_require__(1);
module.exports = function(document){
    for (chapter of document.querySelectorAll('chapter')) renameTag(document, 'chapter', 'section', true);
}


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

const { renameTag } = __webpack_require__(1);

const defaultConfig = {
  proof: { fullName: 'Proof' },
  theorem: { fullName: 'Theorem' },
  proposition: { fullName: 'Proposition' },
  lemma: { fullName: 'Lemma' },
  corollary: { fullName: 'Corollary' }
};

module.exports = function(document, config = defaultConfig) {
  // convert statements to section
  const selector = [];
  for (let key in config) selector.push(key);
  const statements = document.querySelectorAll(selector.join(','));
  let statement_counter = 0;
  for (let statement of statements) {
    const renamedNode = renameTag(document, statement, 'section', true);
    const configEntry = config[statement.tagName.toLowerCase()];
    const fullName = configEntry.fullName;
    renamedNode.classList.add('statement');
    renamedNode.classList.add(
      configEntry.className || 'statement__' + fullName.toLowerCase()
    );
    const name = renamedNode.querySelector('name');
    // TODO maybe name handling is more like a helper that should be required and applied here?
    if (name) continue;
    statement_counter++;
    // TODO look up correct heading level
    const heading = document.createElement('h2');
    heading.classList.add('name');
    heading.id = fullName.toLowerCase() + '-' + statement_counter;
    heading.innerHTML = fullName + ' ' + statement_counter;
    renamedNode.insertBefore(heading, renamedNode.firstChild);
  }
};


/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = function(document, belowOrAbove) {
  // handle figures
  const figures = document.querySelectorAll('figure');
  for (let [index, figure] of figures.entries()) {
    figure.classList.add('figure');
    const name = figure.querySelector('name');
    if (name) continue;
    // TODO look up correct heading level
    const heading = document.createElement('h2');
    heading.classList.add('name');
    heading.innerHTML = 'Figure ' + (index + 1);
    if (belowOrAbove) figure.insertBefore(heading, figure.children[1]);
    else figure.insertBefore(heading, figure.firstChild);
  }
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

const { renameTag } = __webpack_require__(1);

module.exports = function(document) {
  // convert names to headings
  const names = document.querySelectorAll('name');
  for (let name of names) {
    // TODO look up correct heading level
    const renamedNode = renameTag(document, name, 'h2', true);
  }
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

const { renameTag } = __webpack_require__(1);

module.exports = function(document) {
  // convert blames to headings
  const blames = document.querySelectorAll('blame');
  for (let blame of blames) {
    const previous = blame.previousElementSibling;
    if (previous && (previous.classList.contains('name') || previous.tagName === 'NAME')) {
      const renamedNode = renameTag(document, blame, 'span', true);
      previous.appendChild(document.createTextNode(' '));
      previous.appendChild(renamedNode);
    }
    // TODO look up correct heading level
    else {const renamedNode = renameTag(document, blame, 'h2', true);}
  }
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

const { renameTag } = __webpack_require__(1);

module.exports = function(document) {
  // convert ref to links
  const refs = document.querySelectorAll('ref');
  for (let ref of refs) {
    const renamedNode = renameTag(document, ref, 'a');
    const targetId = renamedNode.getAttribute('target');
    renamedNode.classList.add('ref');
    renamedNode.setAttribute('href', '#' + targetId);
    renamedNode.removeAttribute('target');
    if (!/^\s*$/.test(renamedNode.innerHTML)) {
      // the node has some nontrivial contents
      continue;
    }
    // the node is whitespace. replace it with our defaults.
    const target = document.getElementById(targetId);
    let refText =
      '<span style="color:red; background-color:yellow; border: 1px solid red">ERROR: TARGET NOT FOUND</span>';
    if (target && target.querySelector('h1, h2, h3, h4, h5, h6')) {
      const targetHeading = target.querySelector('h1, h2, h3, h4, h5, h6');
      if (targetHeading) {
        clonedHeading = targetHeading.cloneNode(true);
        // strip blame
        if (targetHeading.querySelector('.blame'))
          targetHeading.removeChild(targetHeading.querySelector('.blame'));
        refText = clonedHeading.innerHTML;
      } else {
        console.error(ref, 'Target has no heading');
        refText =
          '<span style="color:red; background-color:yellow; border: 1px solid red">ERROR: TARGET HAS NO HEADING</span>';
      }
    } else console.error(ref, 'Target not found');
    renamedNode.innerHTML = refText;
  }
};


/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = function(document) {
  // populate bibliographic citations
  const bibitems = document.querySelectorAll('bibliography a');
  for (let [index, bibitem] of bibitems.entries()) {
    const counter = '[' + (index + 1) + ']';
    // TODO create DL in buildBib instead
    const counterNode = document.createTextNode(counter + ' ');
    bibitem.parentNode.insertBefore(counterNode, bibitem);
    const cites = document.querySelectorAll(
      'cite[target="' + bibitem.id + '"]'
    );
    for (let cite of cites) {
      if ( /^\s*$/.test(cite.innerHTML) ) {
        // the node is whitespace, replace it with our defaults
        cite.innerHTML = counter;
      } else {
        // leave it alone
      }
      const anchor = document.createElement('a');
      anchor.setAttribute('href', '#' + bibitem.id);
      cite.parentNode.replaceChild(anchor, cite);
      anchor.appendChild(cite);
    }
  }
}


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

const { renameTag } = __webpack_require__(1);

module.exports = function(document) {
  // handle (foot)notes
  const notes = document.querySelectorAll('note');
  for (let [index, note] of notes.entries()) {
    const newNote = renameTag(document, note, 'span');
    newNote.classList.add('footnote');
    newNote.id = 'fn-' + index;
    const fnlink = document.createElement('a');
    fnlink.setAttribute('href', '#' + newNote.id);
    fnlink.id = 'fnlink' + index;
    fnlink.innerHTML = '<sup>' + (index + 1) + '</sup>';
    newNote.parentNode.insertBefore(fnlink, newNote);
    const backlink = document.createElement('a');
    backlink.setAttribute('href', '#' + fnlink.id);
    backlink.innerHTML = '<sup>🔙</sup>';
    backlink.classList.add('backlink');
    newNote.appendChild(backlink);
    // TODO this is not actually disabling clicks
    fnlink.addEventListener(
      'click',
      function(event) {
        event.preventDefault();
      },
      false
    );
    backlink.addEventListener(
      'click',
      function(event) {
        event.preventDefault();
      },
      false
    );
  }
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

const { renameTag } = __webpack_require__(1);

module.exports = function(document) {
  const bib = renameTag(document, 'bibliography', 'section', true);
  const heading = document.createElement('h2');
  heading.innerHTML = 'Bibliography';
  bib.insertBefore(heading, bib.firstChild);
};


/***/ }),
/* 59 */
/***/ (function(module, exports) {

/************************************************************************
 *  Copyright (c) 2016 The MathJax Consortium
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
var tex2jax = function () {};

tex2jax.prototype.config = {
    doc: {},
    inlineMath: [ // The start/stop pairs for in-line math
        //    ['$','$'],               //  (comment out any you don't want, or add your own, but
        ['\\(', '\\)'] //  be sure that you don't have an extra comma at the end)
    ],

    displayMath: [ // The start/stop pairs for display math
        ['$$', '$$'], //  (comment out any you don't want, or add your own, but
        ['\\[', '\\]'] //  be sure that you don't have an extra comma at the end)
    ],

    balanceBraces: true, // determines whether tex2jax requires braces to be
    // balanced within math delimiters (allows for nested
    // dollar signs).  Set to false to get pre-v2.0 compatibility.

    skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "annotation", "annotation-xml"],
    // The names of the tags whose contents will not be
    // scanned for math delimiters

    ignoreClass: "tex2jax_ignore", // the class name of elements whose contents should
    // NOT be processed by tex2jax.  Note that this
    // is a regular expression, so be sure to quote any
    // regexp special characters

    processClass: "tex2jax_process", // the class name of elements whose contents SHOULD
    // be processed when they appear inside ones that
    // are ignored.  Note that this is a regular expression,
    // so be sure to quote any regexp special characters

    processEscapes: false, // set to true to allow \$ to produce a dollar without
    //   starting in-line math mode

    processEnvironments: true, // set to true to process \begin{xxx}...\end{xxx} outside
    //   of math mode, false to prevent that

    processRefs: true, // set to true to process \ref{...} outside of math mode

};

tex2jax.prototype.PreProcess = function (element) {
    if (typeof (element) === "string") {
        element = this.config.doc.getElementById(element)
    }
    if (!element) {
        element = this.config.doc.body
    }
    if (this.createPatterns()) {
        this.scanElement(element, element.nextSibling)
    }
};

tex2jax.prototype.createPatterns = function () {
    var starts = [],
        parts = [],
        i, m, config = this.config;
    this.match = {};
    for (i = 0, m = config.inlineMath.length; i < m; i++) {
        starts.push(this.patternQuote(config.inlineMath[i][0]));
        this.match[config.inlineMath[i][0]] = {
            mode: "tex",
            end: config.inlineMath[i][1],
            pattern: this.endPattern(config.inlineMath[i][1])
        };
    }
    for (i = 0, m = config.displayMath.length; i < m; i++) {
        starts.push(this.patternQuote(config.displayMath[i][0]));
        this.match[config.displayMath[i][0]] = {
            mode: "tex; mode=display",
            end: config.displayMath[i][1],
            pattern: this.endPattern(config.displayMath[i][1])
        };
    }
    if (starts.length) {
        parts.push(starts.sort(this.sortLength).join("|"))
    }
    if (config.processEnvironments) {
        parts.push("\\\\begin\\{([^}]*)\\}")
    }
    if (config.processEscapes) {
        parts.push("\\\\*\\\\\\\$")
    }
    if (config.processRefs) {
        parts.push("\\\\(eq)?ref\\{[^}]*\\}")
    }
    this.start = new RegExp(parts.join("|"), "g");
    this.skipTags = new RegExp("^(" + config.skipTags.join("|") + ")$", "i");
    var ignore = [];
    if (this.config.preRemoveClass) {
        ignore.push(this.config.preRemoveClass)
    };
    if (config.ignoreClass) {
        ignore.push(config.ignoreClass)
    }
    this.ignoreClass = (ignore.length ? new RegExp("(^| )(" + ignore.join("|") + ")( |$)") : /^$/);
    this.processClass = new RegExp("(^| )(" + config.processClass + ")( |$)");
    return (parts.length > 0);
};

tex2jax.prototype.patternQuote = function (s) {
    return s.replace(/([\^$(){}+*?\-|\[\]\:\\])/g, '\\$1')
};

tex2jax.prototype.endPattern = function (end) {
    return new RegExp(this.patternQuote(end) + "|\\\\.|[{}]", "g");
};

tex2jax.prototype.sortLength = function (a, b) {
    if (a.length !== b.length) {
        return b.length - a.length
    }
    return (a == b ? 0 : (a < b ? -1 : 1));
};

tex2jax.prototype.scanElement = function (element, stop, ignore) {
    var cname, tname, ignoreChild, process;
    while (element && element != stop) {
        if (element.nodeName.toLowerCase() === '#text') {
            if (!ignore) {
                element = this.scanText(element)
            }
        } else {
            cname = (typeof (element.className) === "undefined" ? "" : element.className);
            tname = (typeof (element.tagName) === "undefined" ? "" : element.tagName);
            if (typeof (cname) !== "string") {
                cname = String(cname)
            } // jsxgraph uses non-string class names!
            process = this.processClass.exec(cname);
            if (element.firstChild && !cname.match(/(^| )MathJax/) &&
                (process || !this.skipTags.exec(tname))) {
                ignoreChild = (ignore || this.ignoreClass.exec(cname)) && !process;
                this.scanElement(element.firstChild, stop, ignoreChild);
            }
        }
        if (element) {
            element = element.nextSibling
        }
    }
};

tex2jax.prototype.scanText = function (element) {
    if (element.nodeValue.replace(/\s+/, '') == '') {
        return element
    }
    var match, prev;
    this.search = {
        start: true
    };
    this.pattern = this.start;
    while (element) {
        this.pattern.lastIndex = 0;
        while (element && element.nodeName.toLowerCase() === '#text' &&
            (match = this.pattern.exec(element.nodeValue))) {
            if (this.search.start) {
                element = this.startMatch(match, element)
            } else {
                element = this.endMatch(match, element)
            }
        }
        if (this.search.matched) {
            element = this.encloseMath(element)
        }
        if (element) {
            do {
                prev = element;
                element = element.nextSibling
            }
            while (element && (element.nodeName.toLowerCase() === 'br' ||
                    element.nodeName.toLowerCase() === '#comment'));
            if (!element || element.nodeName !== '#text') {
                return (this.search.close ? this.prevEndMatch() : prev)
            }
        }
    }
    return element;
};

tex2jax.prototype.startMatch = function (match, element) {
    var delim = this.match[match[0]];
    if (delim != null) { // a start delimiter
        this.search = {
            end: delim.end,
            mode: delim.mode,
            pcount: 0,
            open: element,
            olen: match[0].length,
            opos: this.pattern.lastIndex - match[0].length
        };
        this.switchPattern(delim.pattern);
    } else if (match[0].substr(0, 6) === "\\begin") { // \begin{...}
        this.search = {
            end: "\\end{" + match[1] + "}",
            mode: "tex; mode=display",
            pcount: 0,
            open: element,
            olen: 0,
            opos: this.pattern.lastIndex - match[0].length,
            isBeginEnd: true
        };
        this.switchPattern(this.endPattern(this.search.end));
    } else if (match[0].substr(0, 4) === "\\ref" || match[0].substr(0, 6) === "\\eqref") {
        this.search = {
            mode: "",
            end: "",
            open: element,
            pcount: 0,
            olen: 0,
            opos: this.pattern.lastIndex - match[0].length
        }
        return this.endMatch([""], element);
    } else { // escaped dollar signs
        // put $ in a span so it doesn't get processed again
        // split off backslashes so they don't get removed later
        var slashes = match[0].substr(0, match[0].length - 1),
            n, span;
        if (slashes.length % 2 === 0) {
            span = [slashes.replace(/\\\\/g, "\\")];
            n = 1
        } else {
            span = [slashes.substr(1).replace(/\\\\/g, "\\"), "$"];
            n = 0
        }
        escaped = this.config.doc.createElement("span");
        escaped.innerHTML = span.join('');
        var text = this.config.doc.createTextNode(element.nodeValue.substr(0, match.index));
        element.nodeValue = element.nodeValue.substr(match.index + match[0].length - n);
        element.parentNode.insertBefore(escaped, element);
        element.parentNode.insertBefore(text, escaped);
        this.pattern.lastIndex = n;
    }
    return element;
};

tex2jax.prototype.endMatch = function (match, element) {
    var search = this.search;
    if (match[0] == search.end) {
        if (!search.close || search.pcount === 0) {
            search.close = element;
            search.cpos = this.pattern.lastIndex;
            search.clen = (search.isBeginEnd ? 0 : match[0].length);
        }
        if (search.pcount === 0) {
            search.matched = true;
            element = this.encloseMath(element);
            this.switchPattern(this.start);
        }
    } else if (match[0] === "{") {
        search.pcount++
    } else if (match[0] === "}" && search.pcount) {
        search.pcount--
    }
    return element;
};
tex2jax.prototype.prevEndMatch = function () {
    this.search.matched = true;
    var element = this.encloseMath(this.search.close);
    this.switchPattern(this.start);
    return element;
};

tex2jax.prototype.switchPattern = function (pattern) {
    pattern.lastIndex = this.pattern.lastIndex;
    this.pattern = pattern;
    this.search.start = (pattern === this.start);
};

tex2jax.prototype.encloseMath = function (element) {
    var search = this.search,
        close = search.close,
        CLOSE, math;
    if (search.cpos === close.length) {
        close = close.nextSibling
    } else {
        close = close.splitText(search.cpos)
    }
    if (!close) {
        CLOSE = close = search.close.parentNode.appendChild(this.config.doc.createTextNode(""));
    }
    search.close = close;
    math = (search.opos ? search.open.splitText(search.opos) : search.open);
    while (math.nextSibling && math.nextSibling !== close) {
        if (math.nextSibling.nodeValue !== null) {
            if (math.nextSibling.nodeName === "#comment") {
                math.nodeValue += math.nextSibling.nodeValue.replace(/^\[CDATA\[((.|\n|\r)*)\]\]$/, "$1");
            } else {
                math.nodeValue += math.nextSibling.nodeValue;
            }
        } else if (this.msieNewlineBug) {
            math.nodeValue += (math.nextSibling.nodeName.toLowerCase() === "br" ? "\n" : " ");
        } else {
            math.nodeValue += " ";
        }
        math.parentNode.removeChild(math.nextSibling);
    }
    var TeX = math.nodeValue.substr(search.olen, math.nodeValue.length - search.olen - search.clen);
    math.parentNode.removeChild(math);
    math = this.createMathTag(search.mode, TeX);
    this.search = {};
    this.pattern.lastIndex = 0;
    if (CLOSE) {
        CLOSE.parentNode.removeChild(CLOSE)
    }
    return math;
};

tex2jax.prototype.insertNode = function (node) {
    var search = this.search;
    search.close.parentNode.insertBefore(node, search.close);
};

tex2jax.prototype.createMathTag = function (mode, tex) {
    var script = this.config.doc.createElement("script");
    script.type = 'math/' + mode;
    script.text = tex;
    this.insertNode(script);
    return script;
};

tex2jax.prototype.filterPreview = function (tex) {
    return tex
};

exports.tex2jax = new tex2jax();


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// commonmark.js - CommomMark in JavaScript
// Copyright (C) 2014 John MacFarlane
// License: BSD3.

// Basic usage:
//
// var commonmark = require('commonmark');
// var parser = new commonmark.Parser();
// var renderer = new commonmark.HtmlRenderer();
// console.log(renderer.render(parser.parse('Hello *world*')));

module.exports.Node = __webpack_require__(9);
module.exports.Parser = __webpack_require__(61);
module.exports.HtmlRenderer = __webpack_require__(73);
module.exports.XmlRenderer = __webpack_require__(74);


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Node = __webpack_require__(9);
var unescapeString = __webpack_require__(4).unescapeString;
var OPENTAG = __webpack_require__(4).OPENTAG;
var CLOSETAG = __webpack_require__(4).CLOSETAG;

var CODE_INDENT = 4;

var C_TAB = 9;
var C_NEWLINE = 10;
var C_GREATERTHAN = 62;
var C_LESSTHAN = 60;
var C_SPACE = 32;
var C_OPEN_BRACKET = 91;

var InlineParser = __webpack_require__(69);

var reHtmlBlockOpen = [
   /./, // dummy for 0
   /^<(?:script|pre|style)(?:\s|>|$)/i,
   /^<!--/,
   /^<[?]/,
   /^<![A-Z]/,
   /^<!\[CDATA\[/,
   /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|title|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
    new RegExp('^(?:' + OPENTAG + '|' + CLOSETAG + ')\\s*$', 'i')
];

var reHtmlBlockClose = [
   /./, // dummy for 0
   /<\/(?:script|pre|style)>/i,
   /-->/,
   /\?>/,
   />/,
   /\]\]>/
];

var reThematicBreak = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/;

var reMaybeSpecial = /^[#`~*+_=<>0-9-]/;

var reNonSpace = /[^ \t\f\v\r\n]/;

var reBulletListMarker = /^[*+-]/;

var reOrderedListMarker = /^(\d{1,9})([.)])/;

var reATXHeadingMarker = /^#{1,6}(?:[ \t]+|$)/;

var reCodeFence = /^`{3,}(?!.*`)|^~{3,}(?!.*~)/;

var reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;

var reSetextHeadingLine = /^(?:=+|-+)[ \t]*$/;

var reLineEnding = /\r\n|\n|\r/;

// Returns true if string contains only space characters.
var isBlank = function(s) {
    return !(reNonSpace.test(s));
};

var isSpaceOrTab = function(c) {
    return c === C_SPACE || c === C_TAB;
};

var peek = function(ln, pos) {
    if (pos < ln.length) {
        return ln.charCodeAt(pos);
    } else {
        return -1;
    }
};

// DOC PARSER

// These are methods of a Parser object, defined below.

// Returns true if block ends with a blank line, descending if needed
// into lists and sublists.
var endsWithBlankLine = function(block) {
    while (block) {
        if (block._lastLineBlank) {
            return true;
        }
        var t = block.type;
        if (t === 'list' || t === 'item') {
            block = block._lastChild;
        } else {
            break;
        }
    }
    return false;
};

// Add a line to the block at the tip.  We assume the tip
// can accept lines -- that check should be done before calling this.
var addLine = function() {
    if (this.partiallyConsumedTab) {
      this.offset += 1; // skip over tab
      // add space characters:
      var charsToTab = 4 - (this.column % 4);
      this.tip._string_content += (' '.repeat(charsToTab));
    }
    this.tip._string_content += this.currentLine.slice(this.offset) + '\n';
};

// Add block of type tag as a child of the tip.  If the tip can't
// accept children, close and finalize it and try its parent,
// and so on til we find a block that can accept children.
var addChild = function(tag, offset) {
    while (!this.blocks[this.tip.type].canContain(tag)) {
        this.finalize(this.tip, this.lineNumber - 1);
    }

    var column_number = offset + 1; // offset 0 = column 1
    var newBlock = new Node(tag, [[this.lineNumber, column_number], [0, 0]]);
    newBlock._string_content = '';
    this.tip.appendChild(newBlock);
    this.tip = newBlock;
    return newBlock;
};

// Parse a list marker and return data on the marker (type,
// start, delimiter, bullet character, padding) or null.
var parseListMarker = function(parser, container) {
    var rest = parser.currentLine.slice(parser.nextNonspace);
    var match;
    var nextc;
    var spacesStartCol;
    var spacesStartOffset;
    var data = { type: null,
                 tight: true,  // lists are tight by default
                 bulletChar: null,
                 start: null,
                 delimiter: null,
                 padding: null,
                 markerOffset: parser.indent };
    if ((match = rest.match(reBulletListMarker))) {
        data.type = 'bullet';
        data.bulletChar = match[0][0];

    } else if ((match = rest.match(reOrderedListMarker)) &&
                (container.type !== 'paragraph' ||
                 match[1] === '1')) {
        data.type = 'ordered';
        data.start = parseInt(match[1]);
        data.delimiter = match[2];
    } else {
        return null;
    }
    // make sure we have spaces after
    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);
    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {
        return null;
    }

    // if it interrupts paragraph, make sure first line isn't blank
    if (container.type === 'paragraph' && !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {
        return null;
    }

    // we've got a match! advance offset and calculate padding
    parser.advanceNextNonspace(); // to start of marker
    parser.advanceOffset(match[0].length, true); // to end of marker
    spacesStartCol = parser.column;
    spacesStartOffset = parser.offset;
    do {
        parser.advanceOffset(1, true);
        nextc = peek(parser.currentLine, parser.offset);
    } while (parser.column - spacesStartCol < 5 &&
           isSpaceOrTab(nextc));
    var blank_item = peek(parser.currentLine, parser.offset) === -1;
    var spaces_after_marker = parser.column - spacesStartCol;
    if (spaces_after_marker >= 5 ||
        spaces_after_marker < 1 ||
        blank_item) {
        data.padding = match[0].length + 1;
        parser.column = spacesStartCol;
        parser.offset = spacesStartOffset;
        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
            parser.advanceOffset(1, true);
        }
    } else {
        data.padding = match[0].length + spaces_after_marker;
    }
    return data;
};

// Returns true if the two list items are of the same type,
// with the same delimiter and bullet character.  This is used
// in agglomerating list items into lists.
var listsMatch = function(list_data, item_data) {
    return (list_data.type === item_data.type &&
            list_data.delimiter === item_data.delimiter &&
            list_data.bulletChar === item_data.bulletChar);
};

// Finalize and close any unmatched blocks.
var closeUnmatchedBlocks = function() {
    if (!this.allClosed) {
        // finalize any blocks not matched
        while (this.oldtip !== this.lastMatchedContainer) {
            var parent = this.oldtip._parent;
            this.finalize(this.oldtip, this.lineNumber - 1);
            this.oldtip = parent;
        }
        this.allClosed = true;
    }
};

// 'finalize' is run when the block is closed.
// 'continue' is run to check whether the block is continuing
// at a certain line and offset (e.g. whether a block quote
// contains a `>`.  It returns 0 for matched, 1 for not matched,
// and 2 for "we've dealt with this line completely, go to next."
var blocks = {
    document: {
        continue: function() { return 0; },
        finalize: function() { return; },
        canContain: function(t) { return (t !== 'item'); },
        acceptsLines: false
    },
    list: {
        continue: function() { return 0; },
        finalize: function(parser, block) {
            var item = block._firstChild;
            while (item) {
                // check for non-final list item ending with blank line:
                if (endsWithBlankLine(item) && item._next) {
                    block._listData.tight = false;
                    break;
                }
                // recurse into children of list item, to see if there are
                // spaces between any of them:
                var subitem = item._firstChild;
                while (subitem) {
                    if (endsWithBlankLine(subitem) &&
                        (item._next || subitem._next)) {
                        block._listData.tight = false;
                        break;
                    }
                    subitem = subitem._next;
                }
                item = item._next;
            }
        },
        canContain: function(t) { return (t === 'item'); },
        acceptsLines: false
    },
    block_quote: {
        continue: function(parser) {
            var ln = parser.currentLine;
            if (!parser.indented &&
                peek(ln, parser.nextNonspace) === C_GREATERTHAN) {
                parser.advanceNextNonspace();
                parser.advanceOffset(1, false);
                if (isSpaceOrTab(peek(ln, parser.offset))) {
                    parser.advanceOffset(1, true);
                }
            } else {
                return 1;
            }
            return 0;
        },
        finalize: function() { return; },
        canContain: function(t) { return (t !== 'item'); },
        acceptsLines: false
    },
    item: {
        continue: function(parser, container) {
            if (parser.blank) {
                if (container._firstChild == null) {
                    // Blank line after empty list item
                    return 1;
                } else {
                    parser.advanceNextNonspace();
                }
            } else if (parser.indent >=
                       container._listData.markerOffset +
                       container._listData.padding) {
                parser.advanceOffset(container._listData.markerOffset +
                    container._listData.padding, true);
            } else {
                return 1;
            }
            return 0;
        },
        finalize: function() { return; },
        canContain: function(t) { return (t !== 'item'); },
        acceptsLines: false
    },
    heading: {
        continue: function() {
            // a heading can never container > 1 line, so fail to match:
            return 1;
        },
        finalize: function() { return; },
        canContain: function() { return false; },
        acceptsLines: false
    },
    thematic_break: {
        continue: function() {
            // a thematic break can never container > 1 line, so fail to match:
            return 1;
        },
        finalize: function() { return; },
        canContain: function() { return false; },
        acceptsLines: false
    },
    code_block: {
        continue: function(parser, container) {
            var ln = parser.currentLine;
            var indent = parser.indent;
            if (container._isFenced) { // fenced
                var match = (indent <= 3 &&
                    ln.charAt(parser.nextNonspace) === container._fenceChar &&
                    ln.slice(parser.nextNonspace).match(reClosingCodeFence));
                if (match && match[0].length >= container._fenceLength) {
                    // closing fence - we're at end of line, so we can return
                    parser.finalize(container, parser.lineNumber);
                    return 2;
                } else {
                    // skip optional spaces of fence offset
                    var i = container._fenceOffset;
                    while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {
                        parser.advanceOffset(1, true);
                        i--;
                    }
                }
            } else { // indented
                if (indent >= CODE_INDENT) {
                    parser.advanceOffset(CODE_INDENT, true);
                } else if (parser.blank) {
                    parser.advanceNextNonspace();
                } else {
                    return 1;
                }
            }
            return 0;
        },
        finalize: function(parser, block) {
            if (block._isFenced) { // fenced
                // first line becomes info string
                var content = block._string_content;
                var newlinePos = content.indexOf('\n');
                var firstLine = content.slice(0, newlinePos);
                var rest = content.slice(newlinePos + 1);
                block.info = unescapeString(firstLine.trim());
                block._literal = rest;
            } else { // indented
                block._literal = block._string_content.replace(/(\n *)+$/, '\n');
            }
            block._string_content = null; // allow GC
        },
        canContain: function() { return false; },
        acceptsLines: true
    },
    html_block: {
        continue: function(parser, container) {
            return ((parser.blank &&
                     (container._htmlBlockType === 6 ||
                      container._htmlBlockType === 7)) ? 1 : 0);
        },
        finalize: function(parser, block) {
            block._literal = block._string_content.replace(/(\n *)+$/, '');
            block._string_content = null; // allow GC
        },
        canContain: function() { return false; },
        acceptsLines: true
    },
    paragraph: {
        continue: function(parser) {
            return (parser.blank ? 1 : 0);
        },
        finalize: function(parser, block) {
            var pos;
            var hasReferenceDefs = false;

            // try parsing the beginning as link reference definitions:
            while (peek(block._string_content, 0) === C_OPEN_BRACKET &&
                   (pos =
                    parser.inlineParser.parseReference(block._string_content,
                                                       parser.refmap))) {
                block._string_content = block._string_content.slice(pos);
                hasReferenceDefs = true;
            }
            if (hasReferenceDefs && isBlank(block._string_content)) {
                block.unlink();
            }
        },
        canContain: function() { return false; },
        acceptsLines: true
    }
};

// block start functions.  Return values:
// 0 = no match
// 1 = matched container, keep going
// 2 = matched leaf, no more block starts
var blockStarts = [
    // block quote
    function(parser) {
        if (!parser.indented &&
            peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {
            parser.advanceNextNonspace();
            parser.advanceOffset(1, false);
            // optional following space
            if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
                parser.advanceOffset(1, true);
            }
            parser.closeUnmatchedBlocks();
            parser.addChild('block_quote', parser.nextNonspace);
            return 1;
        } else {
            return 0;
        }
    },

    // ATX heading
    function(parser) {
        var match;
        if (!parser.indented &&
            (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {
            parser.advanceNextNonspace();
            parser.advanceOffset(match[0].length, false);
            parser.closeUnmatchedBlocks();
            var container = parser.addChild('heading', parser.nextNonspace);
            container.level = match[0].trim().length; // number of #s
            // remove trailing ###s:
            container._string_content =
                parser.currentLine.slice(parser.offset).replace(/^[ \t]*#+[ \t]*$/, '').replace(/[ \t]+#+[ \t]*$/, '');
            parser.advanceOffset(parser.currentLine.length - parser.offset);
            return 2;
        } else {
            return 0;
        }
    },

    // Fenced code block
    function(parser) {
        var match;
        if (!parser.indented &&
            (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {
            var fenceLength = match[0].length;
            parser.closeUnmatchedBlocks();
            var container = parser.addChild('code_block', parser.nextNonspace);
            container._isFenced = true;
            container._fenceLength = fenceLength;
            container._fenceChar = match[0][0];
            container._fenceOffset = parser.indent;
            parser.advanceNextNonspace();
            parser.advanceOffset(fenceLength, false);
            return 2;
        } else {
            return 0;
        }
    },

    // HTML block
    function(parser, container) {
        if (!parser.indented &&
            peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {
            var s = parser.currentLine.slice(parser.nextNonspace);
            var blockType;

            for (blockType = 1; blockType <= 7; blockType++) {
                if (reHtmlBlockOpen[blockType].test(s) &&
                    (blockType < 7 ||
                     container.type !== 'paragraph')) {
                    parser.closeUnmatchedBlocks();
                    // We don't adjust parser.offset;
                    // spaces are part of the HTML block:
                    var b = parser.addChild('html_block',
                                            parser.offset);
                    b._htmlBlockType = blockType;
                    return 2;
                }
            }
        }

        return 0;

    },

    // Setext heading
    function(parser, container) {
        var match;
        if (!parser.indented &&
            container.type === 'paragraph' &&
                   ((match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine)))) {
            parser.closeUnmatchedBlocks();
            var heading = new Node('heading', container.sourcepos);
            heading.level = match[0][0] === '=' ? 1 : 2;
            heading._string_content = container._string_content;
            container.insertAfter(heading);
            container.unlink();
            parser.tip = heading;
            parser.advanceOffset(parser.currentLine.length - parser.offset, false);
            return 2;
        } else {
            return 0;
        }
    },

    // thematic break
    function(parser) {
        if (!parser.indented &&
            reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {
            parser.closeUnmatchedBlocks();
            parser.addChild('thematic_break', parser.nextNonspace);
            parser.advanceOffset(parser.currentLine.length - parser.offset, false);
            return 2;
        } else {
            return 0;
        }
    },

    // list item
    function(parser, container) {
        var data;

        if ((!parser.indented || container.type === 'list')
                && (data = parseListMarker(parser, container))) {
            parser.closeUnmatchedBlocks();

            // add the list if needed
            if (parser.tip.type !== 'list' ||
                !(listsMatch(container._listData, data))) {
                container = parser.addChild('list', parser.nextNonspace);
                container._listData = data;
            }

            // add the list item
            container = parser.addChild('item', parser.nextNonspace);
            container._listData = data;
            return 1;
        } else {
            return 0;
        }
    },

    // indented code block
    function(parser) {
        if (parser.indented &&
            parser.tip.type !== 'paragraph' &&
            !parser.blank) {
            // indented code
            parser.advanceOffset(CODE_INDENT, true);
            parser.closeUnmatchedBlocks();
            parser.addChild('code_block', parser.offset);
            return 2;
        } else {
            return 0;
        }
     }

];

var advanceOffset = function(count, columns) {
    var currentLine = this.currentLine;
    var charsToTab, charsToAdvance;
    var c;
    while (count > 0 && (c = currentLine[this.offset])) {
        if (c === '\t') {
            charsToTab = 4 - (this.column % 4);
            if (columns) {
                this.partiallyConsumedTab = charsToTab > count;
                charsToAdvance = charsToTab > count ? count : charsToTab;
                this.column += charsToAdvance;
                this.offset += this.partiallyConsumedTab ? 0 : 1;
                count -= charsToAdvance;
            } else {
                this.partiallyConsumedTab = false;
                this.column += charsToTab;
                this.offset += 1;
                count -= 1;
            }
        } else {
            this.partiallyConsumedTab = false;
            this.offset += 1;
            this.column += 1; // assume ascii; block starts are ascii
            count -= 1;
        }
    }
};

var advanceNextNonspace = function() {
    this.offset = this.nextNonspace;
    this.column = this.nextNonspaceColumn;
    this.partiallyConsumedTab = false;
};

var findNextNonspace = function() {
    var currentLine = this.currentLine;
    var i = this.offset;
    var cols = this.column;
    var c;

    while ((c = currentLine.charAt(i)) !== '') {
        if (c === ' ') {
            i++;
            cols++;
        } else if (c === '\t') {
            i++;
            cols += (4 - (cols % 4));
        } else {
            break;
        }
    }
    this.blank = (c === '\n' || c === '\r' || c === '');
    this.nextNonspace = i;
    this.nextNonspaceColumn = cols;
    this.indent = this.nextNonspaceColumn - this.column;
    this.indented = this.indent >= CODE_INDENT;
};

// Analyze a line of text and update the document appropriately.
// We parse markdown text by calling this on each line of input,
// then finalizing the document.
var incorporateLine = function(ln) {
    var all_matched = true;
    var t;

    var container = this.doc;
    this.oldtip = this.tip;
    this.offset = 0;
    this.column = 0;
    this.blank = false;
    this.partiallyConsumedTab = false;
    this.lineNumber += 1;

    // replace NUL characters for security
    if (ln.indexOf('\u0000') !== -1) {
        ln = ln.replace(/\0/g, '\uFFFD');
    }

    this.currentLine = ln;

    // For each containing block, try to parse the associated line start.
    // Bail out on failure: container will point to the last matching block.
    // Set all_matched to false if not all containers match.
    var lastChild;
    while ((lastChild = container._lastChild) && lastChild._open) {
        container = lastChild;

        this.findNextNonspace();

        switch (this.blocks[container.type].continue(this, container)) {
        case 0: // we've matched, keep going
            break;
        case 1: // we've failed to match a block
            all_matched = false;
            break;
        case 2: // we've hit end of line for fenced code close and can return
            this.lastLineLength = ln.length;
            return;
        default:
            throw 'continue returned illegal value, must be 0, 1, or 2';
        }
        if (!all_matched) {
            container = container._parent; // back up to last matching block
            break;
        }
    }

    this.allClosed = (container === this.oldtip);
    this.lastMatchedContainer = container;

    var matchedLeaf = container.type !== 'paragraph' &&
            blocks[container.type].acceptsLines;
    var starts = this.blockStarts;
    var startsLen = starts.length;
    // Unless last matched container is a code block, try new container starts,
    // adding children to the last matched container:
    while (!matchedLeaf) {

        this.findNextNonspace();

        // this is a little performance optimization:
        if (!this.indented &&
            !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {
            this.advanceNextNonspace();
            break;
        }

        var i = 0;
        while (i < startsLen) {
            var res = starts[i](this, container);
            if (res === 1) {
                container = this.tip;
                break;
            } else if (res === 2) {
                container = this.tip;
                matchedLeaf = true;
                break;
            } else {
                i++;
            }
        }

        if (i === startsLen) { // nothing matched
            this.advanceNextNonspace();
            break;
        }
    }

    // What remains at the offset is a text line.  Add the text to the
    // appropriate container.

   // First check for a lazy paragraph continuation:
    if (!this.allClosed && !this.blank &&
        this.tip.type === 'paragraph') {
        // lazy paragraph continuation
        this.addLine();

    } else { // not a lazy continuation

        // finalize any blocks not matched
        this.closeUnmatchedBlocks();
        if (this.blank && container.lastChild) {
            container.lastChild._lastLineBlank = true;
        }

        t = container.type;

        // Block quote lines are never blank as they start with >
        // and we don't count blanks in fenced code for purposes of tight/loose
        // lists or breaking out of lists.  We also don't set _lastLineBlank
        // on an empty list item, or if we just closed a fenced block.
        var lastLineBlank = this.blank &&
            !(t === 'block_quote' ||
              (t === 'code_block' && container._isFenced) ||
              (t === 'item' &&
               !container._firstChild &&
               container.sourcepos[0][0] === this.lineNumber));

        // propagate lastLineBlank up through parents:
        var cont = container;
        while (cont) {
            cont._lastLineBlank = lastLineBlank;
            cont = cont._parent;
        }

        if (this.blocks[t].acceptsLines) {
            this.addLine();
            // if HtmlBlock, check for end condition
            if (t === 'html_block' &&
                container._htmlBlockType >= 1 &&
                container._htmlBlockType <= 5 &&
                reHtmlBlockClose[container._htmlBlockType].test(this.currentLine.slice(this.offset))) {
                this.finalize(container, this.lineNumber);
            }

        } else if (this.offset < ln.length && !this.blank) {
            // create paragraph container for line
            container = this.addChild('paragraph', this.offset);
            this.advanceNextNonspace();
            this.addLine();
        }
    }
    this.lastLineLength = ln.length;
};

// Finalize a block.  Close it and do any necessary postprocessing,
// e.g. creating string_content from strings, setting the 'tight'
// or 'loose' status of a list, and parsing the beginnings
// of paragraphs for reference definitions.  Reset the tip to the
// parent of the closed block.
var finalize = function(block, lineNumber) {
    var above = block._parent;
    block._open = false;
    block.sourcepos[1] = [lineNumber, this.lastLineLength];

    this.blocks[block.type].finalize(this, block);

    this.tip = above;
};

// Walk through a block & children recursively, parsing string content
// into inline content where appropriate.
var processInlines = function(block) {
    var node, event, t;
    var walker = block.walker();
    this.inlineParser.refmap = this.refmap;
    this.inlineParser.options = this.options;
    while ((event = walker.next())) {
        node = event.node;
        t = node.type;
        if (!event.entering && (t === 'paragraph' || t === 'heading')) {
            this.inlineParser.parse(node);
        }
    }
};

var Document = function() {
    var doc = new Node('document', [[1, 1], [0, 0]]);
    return doc;
};

// The main parsing function.  Returns a parsed document AST.
var parse = function(input) {
    this.doc = new Document();
    this.tip = this.doc;
    this.refmap = {};
    this.lineNumber = 0;
    this.lastLineLength = 0;
    this.offset = 0;
    this.column = 0;
    this.lastMatchedContainer = this.doc;
    this.currentLine = "";
    if (this.options.time) { console.time("preparing input"); }
    var lines = input.split(reLineEnding);
    var len = lines.length;
    if (input.charCodeAt(input.length - 1) === C_NEWLINE) {
        // ignore last blank line created by final newline
        len -= 1;
    }
    if (this.options.time) { console.timeEnd("preparing input"); }
    if (this.options.time) { console.time("block parsing"); }
    for (var i = 0; i < len; i++) {
        this.incorporateLine(lines[i]);
    }
    while (this.tip) {
        this.finalize(this.tip, len);
    }
    if (this.options.time) { console.timeEnd("block parsing"); }
    if (this.options.time) { console.time("inline parsing"); }
    this.processInlines(this.doc);
    if (this.options.time) { console.timeEnd("inline parsing"); }
    return this.doc;
};


// The Parser object.
function Parser(options){
    return {
        doc: new Document(),
        blocks: blocks,
        blockStarts: blockStarts,
        tip: this.doc,
        oldtip: this.doc,
        currentLine: "",
        lineNumber: 0,
        offset: 0,
        column: 0,
        nextNonspace: 0,
        nextNonspaceColumn: 0,
        indent: 0,
        indented: false,
        blank: false,
        partiallyConsumedTab: false,
        allClosed: true,
        lastMatchedContainer: this.doc,
        refmap: {},
        lastLineLength: 0,
        inlineParser: new InlineParser(options),
        findNextNonspace: findNextNonspace,
        advanceOffset: advanceOffset,
        advanceNextNonspace: advanceNextNonspace,
        addLine: addLine,
        addChild: addChild,
        incorporateLine: incorporateLine,
        finalize: finalize,
        processInlines: processInlines,
        closeUnmatchedBlocks: closeUnmatchedBlocks,
        parse: parse,
        options: options || {}
    };
}

module.exports = Parser;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";




var encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) { return cache; }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped  = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";


module.exports = encode;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";




/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i, ch, cache = decodeCache[exclude];
  if (cache) { return cache; }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}


// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    var i, l, b1, b2, b3, b4, chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);

          if (chr < 0x80) {
            result += '\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);

          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
            result += '\ufffd\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\ufffd\ufffd\ufffd\ufffd';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\ufffd';
    }

    return result;
  });
}


decode.defaultChars   = ';/?:@&=+$,#';
decode.componentChars = '';


module.exports = decode;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var inverseXML = getInverseObj(__webpack_require__(13)),
    xmlReplacer = getInverseReplacer(inverseXML);

exports.XML = getInverse(inverseXML, xmlReplacer);

var inverseHTML = getInverseObj(__webpack_require__(14)),
    htmlReplacer = getInverseReplacer(inverseHTML);

exports.HTML = getInverse(inverseHTML, htmlReplacer);

function getInverseObj(obj){
	return Object.keys(obj).sort().reduce(function(inverse, name){
		inverse[obj[name]] = "&" + name + ";";
		return inverse;
	}, {});
}

function getInverseReplacer(inverse){
	var single = [],
	    multiple = [];

	Object.keys(inverse).forEach(function(k){
		if(k.length === 1){
			single.push("\\" + k);
		} else {
			multiple.push(k);
		}
	});

	//TODO add ranges
	multiple.unshift("[" + single.join("") + "]");

	return new RegExp(multiple.join("|"), "g");
}

var re_nonASCII = /[^\0-\x7F]/g,
    re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function singleCharReplacer(c){
	return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
}

function astralReplacer(c){
	// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	var high = c.charCodeAt(0);
	var low  = c.charCodeAt(1);
	var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
	return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}

function getInverse(inverse, re){
	function func(name){
		return inverse[name];
	}

	return function(data){
		return data
				.replace(re, func)
				.replace(re_astralSymbols, astralReplacer)
				.replace(re_nonASCII, singleCharReplacer);
	};
}

var re_xmlChars = getInverseReplacer(inverseXML);

function escapeXML(data){
	return data
			.replace(re_xmlChars, singleCharReplacer)
			.replace(re_astralSymbols, astralReplacer)
			.replace(re_nonASCII, singleCharReplacer);
}

exports.escape = escapeXML;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var entityMap = __webpack_require__(14),
    legacyMap = __webpack_require__(66),
    xmlMap    = __webpack_require__(13),
    decodeCodePoint = __webpack_require__(67);

var decodeXMLStrict  = getStrictDecoder(xmlMap),
    decodeHTMLStrict = getStrictDecoder(entityMap);

function getStrictDecoder(map){
	var keys = Object.keys(map).join("|"),
	    replace = getReplacer(map);

	keys += "|#[xX][\\da-fA-F]+|#\\d+";

	var re = new RegExp("&(?:" + keys + ");", "g");

	return function(str){
		return String(str).replace(re, replace);
	};
}

var decodeHTML = (function(){
	var legacy = Object.keys(legacyMap)
		.sort(sorter);

	var keys = Object.keys(entityMap)
		.sort(sorter);

	for(var i = 0, j = 0; i < keys.length; i++){
		if(legacy[j] === keys[i]){
			keys[i] += ";?";
			j++;
		} else {
			keys[i] += ";";
		}
	}

	var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
	    replace = getReplacer(entityMap);

	function replacer(str){
		if(str.substr(-1) !== ";") str += ";";
		return replace(str);
	}

	//TODO consider creating a merged map
	return function(str){
		return String(str).replace(re, replacer);
	};
}());

function sorter(a, b){
	return a < b ? 1 : -1;
}

function getReplacer(map){
	return function replace(str){
		if(str.charAt(1) === "#"){
			if(str.charAt(2) === "X" || str.charAt(2) === "x"){
				return decodeCodePoint(parseInt(str.substr(3), 16));
			}
			return decodeCodePoint(parseInt(str.substr(2), 10));
		}
		return map[str.slice(1, -1)];
	};
}

module.exports = {
	XML: decodeXMLStrict,
	HTML: decodeHTML,
	HTMLStrict: decodeHTMLStrict
};

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = {"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\"","QUOT":"\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var decodeMap = __webpack_require__(68);

module.exports = decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint){

	if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
		return "\uFFFD";
	}

	if(codePoint in decodeMap){
		codePoint = decodeMap[codePoint];
	}

	var output = "";

	if(codePoint > 0xFFFF){
		codePoint -= 0x10000;
		output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
		codePoint = 0xDC00 | codePoint & 0x3FF;
	}

	output += String.fromCharCode(codePoint);
	return output;
}


/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = {"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Node = __webpack_require__(9);
var common = __webpack_require__(4);
var normalizeReference = __webpack_require__(70);

var normalizeURI = common.normalizeURI;
var unescapeString = common.unescapeString;
var fromCodePoint = __webpack_require__(71);
var decodeHTML = __webpack_require__(12).decodeHTML;
__webpack_require__(72); // Polyfill for String.prototype.repeat

// Constants for character codes:

var C_NEWLINE = 10;
var C_ASTERISK = 42;
var C_UNDERSCORE = 95;
var C_BACKTICK = 96;
var C_OPEN_BRACKET = 91;
var C_CLOSE_BRACKET = 93;
var C_LESSTHAN = 60;
var C_BANG = 33;
var C_BACKSLASH = 92;
var C_AMPERSAND = 38;
var C_OPEN_PAREN = 40;
var C_CLOSE_PAREN = 41;
var C_COLON = 58;
var C_SINGLEQUOTE = 39;
var C_DOUBLEQUOTE = 34;

// Some regexps used in inline parser:

var ESCAPABLE = common.ESCAPABLE;
var ESCAPED_CHAR = '\\\\' + ESCAPABLE;

var ENTITY = common.ENTITY;
var reHtmlTag = common.reHtmlTag;

var rePunctuation = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/);

var reLinkTitle = new RegExp(
    '^(?:"(' + ESCAPED_CHAR + '|[^"\\x00])*"' +
        '|' +
        '\'(' + ESCAPED_CHAR + '|[^\'\\x00])*\'' +
        '|' +
        '\\((' + ESCAPED_CHAR + '|[^)\\x00])*\\))');

var reLinkDestinationBraces = new RegExp(
    '^(?:[<](?:[^ <>\\t\\n\\\\\\x00]' + '|' + ESCAPED_CHAR + '|' + '\\\\)*[>])');

var reEscapable = new RegExp('^' + ESCAPABLE);

var reEntityHere = new RegExp('^' + ENTITY, 'i');

var reTicks = /`+/;

var reTicksHere = /^`+/;

var reEllipses = /\.\.\./g;

var reDash = /--+/g;

var reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;

var reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i;

var reSpnl = /^ *(?:\n *)?/;

var reWhitespaceChar = /^[ \t\n\x0b\x0c\x0d]/;

var reWhitespace = /[ \t\n\x0b\x0c\x0d]+/g;

var reUnicodeWhitespaceChar = /^\s/;

var reFinalSpace = / *$/;

var reInitialSpace = /^ */;

var reSpaceAtEndOfLine = /^ *(?:\n|$)/;

var reLinkLabel = new RegExp('^\\[(?:[^\\\\\\[\\]]|' + ESCAPED_CHAR +
  '|\\\\){0,1000}\\]');

// Matches a string of non-special characters.
var reMain = /^[^\n`\[\]\\!<&*_'"]+/m;

var text = function(s) {
    var node = new Node('text');
    node._literal = s;
    return node;
};

// INLINE PARSER

// These are methods of an InlineParser object, defined below.
// An InlineParser keeps track of a subject (a string to be
// parsed) and a position in that subject.

// If re matches at current position in the subject, advance
// position in subject and return the match; otherwise return null.
var match = function(re) {
    var m = re.exec(this.subject.slice(this.pos));
    if (m === null) {
        return null;
    } else {
        this.pos += m.index + m[0].length;
        return m[0];
    }
};

// Returns the code for the character at the current subject position, or -1
// there are no more characters.
var peek = function() {
    if (this.pos < this.subject.length) {
        return this.subject.charCodeAt(this.pos);
    } else {
        return -1;
    }
};

// Parse zero or more space characters, including at most one newline
var spnl = function() {
    this.match(reSpnl);
    return true;
};

// All of the parsers below try to match something at the current position
// in the subject.  If they succeed in matching anything, they
// return the inline matched, advancing the subject.

// Attempt to parse backticks, adding either a backtick code span or a
// literal sequence of backticks.
var parseBackticks = function(block) {
    var ticks = this.match(reTicksHere);
    if (ticks === null) {
        return false;
    }
    var afterOpenTicks = this.pos;
    var matched;
    var node;
    while ((matched = this.match(reTicks)) !== null) {
        if (matched === ticks) {
            node = new Node('code');
            node._literal = this.subject.slice(afterOpenTicks,
                                        this.pos - ticks.length)
                          .trim().replace(reWhitespace, ' ');
            block.appendChild(node);
            return true;
        }
    }
    // If we got here, we didn't match a closing backtick sequence.
    this.pos = afterOpenTicks;
    block.appendChild(text(ticks));
    return true;
};

// Parse a backslash-escaped special character, adding either the escaped
// character, a hard line break (if the backslash is followed by a newline),
// or a literal backslash to the block's children.  Assumes current character
// is a backslash.
var parseBackslash = function(block) {
    var subj = this.subject;
    var node;
    this.pos += 1;
    if (this.peek() === C_NEWLINE) {
        this.pos += 1;
        node = new Node('linebreak');
        block.appendChild(node);
    } else if (reEscapable.test(subj.charAt(this.pos))) {
        block.appendChild(text(subj.charAt(this.pos)));
        this.pos += 1;
    } else {
        block.appendChild(text('\\'));
    }
    return true;
};

// Attempt to parse an autolink (URL or email in pointy brackets).
var parseAutolink = function(block) {
    var m;
    var dest;
    var node;
    if ((m = this.match(reEmailAutolink))) {
        dest = m.slice(1, m.length - 1);
        node = new Node('link');
        node._destination = normalizeURI('mailto:' + dest);
        node._title = '';
        node.appendChild(text(dest));
        block.appendChild(node);
        return true;
    } else if ((m = this.match(reAutolink))) {
        dest = m.slice(1, m.length - 1);
        node = new Node('link');
        node._destination = normalizeURI(dest);
        node._title = '';
        node.appendChild(text(dest));
        block.appendChild(node);
        return true;
    } else {
        return false;
    }
};

// Attempt to parse a raw HTML tag.
var parseHtmlTag = function(block) {
    var m = this.match(reHtmlTag);
    if (m === null) {
        return false;
    } else {
        var node = new Node('html_inline');
        node._literal = m;
        block.appendChild(node);
        return true;
    }
};

// Scan a sequence of characters with code cc, and return information about
// the number of delimiters and whether they are positioned such that
// they can open and/or close emphasis or strong emphasis.  A utility
// function for strong/emph parsing.
var scanDelims = function(cc) {
    var numdelims = 0;
    var char_before, char_after, cc_after;
    var startpos = this.pos;
    var left_flanking, right_flanking, can_open, can_close;
    var after_is_whitespace, after_is_punctuation, before_is_whitespace, before_is_punctuation;

    if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
        numdelims++;
        this.pos++;
    } else {
        while (this.peek() === cc) {
            numdelims++;
            this.pos++;
        }
    }

    if (numdelims === 0) {
        return null;
    }

    char_before = startpos === 0 ? '\n' : this.subject.charAt(startpos - 1);

    cc_after = this.peek();
    if (cc_after === -1) {
        char_after = '\n';
    } else {
        char_after = fromCodePoint(cc_after);
    }

    after_is_whitespace = reUnicodeWhitespaceChar.test(char_after);
    after_is_punctuation = rePunctuation.test(char_after);
    before_is_whitespace = reUnicodeWhitespaceChar.test(char_before);
    before_is_punctuation = rePunctuation.test(char_before);

    left_flanking = !after_is_whitespace &&
            (!after_is_punctuation || before_is_whitespace || before_is_punctuation);
    right_flanking = !before_is_whitespace &&
            (!before_is_punctuation || after_is_whitespace || after_is_punctuation);
    if (cc === C_UNDERSCORE) {
        can_open = left_flanking &&
            (!right_flanking || before_is_punctuation);
        can_close = right_flanking &&
            (!left_flanking || after_is_punctuation);
    } else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
        can_open = left_flanking && !right_flanking;
        can_close = right_flanking;
    } else {
        can_open = left_flanking;
        can_close = right_flanking;
    }
    this.pos = startpos;
    return { numdelims: numdelims,
             can_open: can_open,
             can_close: can_close };
};

// Handle a delimiter marker for emphasis or a quote.
var handleDelim = function(cc, block) {
    var res = this.scanDelims(cc);
    if (!res) {
        return false;
    }
    var numdelims = res.numdelims;
    var startpos = this.pos;
    var contents;

    this.pos += numdelims;
    if (cc === C_SINGLEQUOTE) {
        contents = "\u2019";
    } else if (cc === C_DOUBLEQUOTE) {
        contents = "\u201C";
    } else {
        contents = this.subject.slice(startpos, this.pos);
    }
    var node = text(contents);
    block.appendChild(node);

    // Add entry to stack for this opener
    this.delimiters = { cc: cc,
                        numdelims: numdelims,
                        origdelims: numdelims,
                        node: node,
                        previous: this.delimiters,
                        next: null,
                        can_open: res.can_open,
                        can_close: res.can_close };
    if (this.delimiters.previous !== null) {
        this.delimiters.previous.next = this.delimiters;
    }

    return true;

};

var removeDelimiter = function(delim) {
    if (delim.previous !== null) {
        delim.previous.next = delim.next;
    }
    if (delim.next === null) {
        // top of stack
        this.delimiters = delim.previous;
    } else {
        delim.next.previous = delim.previous;
    }
};

var removeDelimitersBetween = function(bottom, top) {
    if (bottom.next !== top) {
        bottom.next = top;
        top.previous = bottom;
    }
};

var processEmphasis = function(stack_bottom) {
    var opener, closer, old_closer;
    var opener_inl, closer_inl;
    var tempstack;
    var use_delims;
    var tmp, next;
    var opener_found;
    var openers_bottom = [];
    var odd_match = false;

    openers_bottom[C_UNDERSCORE] = stack_bottom;
    openers_bottom[C_ASTERISK] = stack_bottom;
    openers_bottom[C_SINGLEQUOTE] = stack_bottom;
    openers_bottom[C_DOUBLEQUOTE] = stack_bottom;

    // find first closer above stack_bottom:
    closer = this.delimiters;
    while (closer !== null && closer.previous !== stack_bottom) {
        closer = closer.previous;
    }
    // move forward, looking for closers, and handling each
    while (closer !== null) {
        var closercc = closer.cc;
        if (!closer.can_close) {
            closer = closer.next;
        } else {
            // found emphasis closer. now look back for first matching opener:
            opener = closer.previous;
            opener_found = false;
            while (opener !== null && opener !== stack_bottom &&
                   opener !== openers_bottom[closercc]) {
                odd_match = (closer.can_open || opener.can_close) &&
                    (opener.origdelims + closer.origdelims) % 3 === 0;
                if (opener.cc === closer.cc && opener.can_open && !odd_match) {
                    opener_found = true;
                    break;
                }
                opener = opener.previous;
            }
            old_closer = closer;

            if (closercc === C_ASTERISK || closercc === C_UNDERSCORE) {
                if (!opener_found) {
                    closer = closer.next;
                } else {
                    // calculate actual number of delimiters used from closer
                    use_delims =
                      (closer.numdelims >= 2 && opener.numdelims >= 2) ? 2 : 1;

                    opener_inl = opener.node;
                    closer_inl = closer.node;

                    // remove used delimiters from stack elts and inlines
                    opener.numdelims -= use_delims;
                    closer.numdelims -= use_delims;
                    opener_inl._literal =
                        opener_inl._literal.slice(0,
                                                  opener_inl._literal.length - use_delims);
                    closer_inl._literal =
                        closer_inl._literal.slice(0,
                                                  closer_inl._literal.length - use_delims);

                    // build contents for new emph element
                    var emph = new Node(use_delims === 1 ? 'emph' : 'strong');

                    tmp = opener_inl._next;
                    while (tmp && tmp !== closer_inl) {
                        next = tmp._next;
                        tmp.unlink();
                        emph.appendChild(tmp);
                        tmp = next;
                    }

                    opener_inl.insertAfter(emph);

                    // remove elts between opener and closer in delimiters stack
                    removeDelimitersBetween(opener, closer);

                    // if opener has 0 delims, remove it and the inline
                    if (opener.numdelims === 0) {
                        opener_inl.unlink();
                        this.removeDelimiter(opener);
                    }

                    if (closer.numdelims === 0) {
                        closer_inl.unlink();
                        tempstack = closer.next;
                        this.removeDelimiter(closer);
                        closer = tempstack;
                    }

                }

            } else if (closercc === C_SINGLEQUOTE) {
                closer.node._literal = "\u2019";
                if (opener_found) {
                    opener.node._literal = "\u2018";
                }
                closer = closer.next;

            } else if (closercc === C_DOUBLEQUOTE) {
                closer.node._literal = "\u201D";
                if (opener_found) {
                    opener.node.literal = "\u201C";
                }
                closer = closer.next;

            }
            if (!opener_found && !odd_match) {
                // Set lower bound for future searches for openers:
                // We don't do this with odd_match because a **
                // that doesn't match an earlier * might turn into
                // an opener, and the * might be matched by something
                // else.
                openers_bottom[closercc] = old_closer.previous;
                if (!old_closer.can_open) {
                    // We can remove a closer that can't be an opener,
                    // once we've seen there's no matching opener:
                    this.removeDelimiter(old_closer);
                }
            }
        }

    }

    // remove all delimiters
    while (this.delimiters !== null && this.delimiters !== stack_bottom) {
        this.removeDelimiter(this.delimiters);
    }
};

// Attempt to parse link title (sans quotes), returning the string
// or null if no match.
var parseLinkTitle = function() {
    var title = this.match(reLinkTitle);
    if (title === null) {
        return null;
    } else {
        // chop off quotes from title and unescape:
        return unescapeString(title.substr(1, title.length - 2));
    }
};

// Attempt to parse link destination, returning the string or
// null if no match.
var parseLinkDestination = function() {
    var res = this.match(reLinkDestinationBraces);
    if (res === null) {
        // TODO handrolled parser; res should be null or the string
        var savepos = this.pos;
        var openparens = 0;
        var c;
        while ((c = this.peek()) !== -1) {
            if (c === C_BACKSLASH) {
                this.pos += 1;
                if (this.peek() !== -1) {
                    this.pos += 1;
                }
            } else if (c === C_OPEN_PAREN) {
                this.pos += 1;
                openparens += 1;
            } else if (c === C_CLOSE_PAREN) {
                if (openparens < 1) {
                    break;
                } else {
                    this.pos += 1;
                    openparens -= 1;
                }
            } else if (reWhitespaceChar.exec(fromCodePoint(c)) !== null) {
                break;
            } else {
                this.pos += 1;
            }
        }
        res = this.subject.substr(savepos, this.pos - savepos);
        return normalizeURI(unescapeString(res));
    } else {  // chop off surrounding <..>:
        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));
    }
};

// Attempt to parse a link label, returning number of characters parsed.
var parseLinkLabel = function() {
    var m = this.match(reLinkLabel);
    // Note:  our regex will allow something of form [..\];
    // we disallow it here rather than using lookahead in the regex:
    if (m === null || m.length > 1001 || /[^\\]\\\]$/.exec(m)) {
        return 0;
    } else {
        return m.length;
    }
};

// Add open bracket to delimiter stack and add a text node to block's children.
var parseOpenBracket = function(block) {
    var startpos = this.pos;
    this.pos += 1;

    var node = text('[');
    block.appendChild(node);

    // Add entry to stack for this opener
    this.addBracket(node, startpos, false);
    return true;
};

// IF next character is [, and ! delimiter to delimiter stack and
// add a text node to block's children.  Otherwise just add a text node.
var parseBang = function(block) {
    var startpos = this.pos;
    this.pos += 1;
    if (this.peek() === C_OPEN_BRACKET) {
        this.pos += 1;

        var node = text('![');
        block.appendChild(node);

        // Add entry to stack for this opener
        this.addBracket(node, startpos + 1, true);
    } else {
        block.appendChild(text('!'));
    }
    return true;
};

// Try to match close bracket against an opening in the delimiter
// stack.  Add either a link or image, or a plain [ character,
// to block's children.  If there is a matching delimiter,
// remove it from the delimiter stack.
var parseCloseBracket = function(block) {
    var startpos;
    var is_image;
    var dest;
    var title;
    var matched = false;
    var reflabel;
    var opener;

    this.pos += 1;
    startpos = this.pos;

    // get last [ or ![
    opener = this.brackets;

    if (opener === null) {
        // no matched opener, just return a literal
        block.appendChild(text(']'));
        return true;
    }

    if (!opener.active) {
        // no matched opener, just return a literal
        block.appendChild(text(']'));
        // take opener off brackets stack
        this.removeBracket();
        return true;
    }

    // If we got here, open is a potential opener
    is_image = opener.image;

    // Check to see if we have a link/image

    var savepos = this.pos;

    // Inline link?
    if (this.peek() === C_OPEN_PAREN) {
        this.pos++;
        if (this.spnl() &&
            ((dest = this.parseLinkDestination()) !== null) &&
            this.spnl() &&
            // make sure there's a space before the title:
            (reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&
             (title = this.parseLinkTitle()) || true) &&
            this.spnl() &&
            this.peek() === C_CLOSE_PAREN) {
            this.pos += 1;
            matched = true;
        } else {
            this.pos = savepos;
        }
    }

    if (!matched) {

        // Next, see if there's a link label
        var beforelabel = this.pos;
        var n = this.parseLinkLabel();
        if (n > 2) {
            reflabel = this.subject.slice(beforelabel, beforelabel + n);
        } else if (!opener.bracketAfter) {
            // Empty or missing second label means to use the first label as the reference.
            // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.
            reflabel = this.subject.slice(opener.index, startpos);
        }
        if (n === 0) {
            // If shortcut reference link, rewind before spaces we skipped.
            this.pos = savepos;
        }

        if (reflabel) {
            // lookup rawlabel in refmap
            var link = this.refmap[normalizeReference(reflabel)];
            if (link) {
                dest = link.destination;
                title = link.title;
                matched = true;
            }
        }
    }

    if (matched) {
        var node = new Node(is_image ? 'image' : 'link');
        node._destination = dest;
        node._title = title || '';

        var tmp, next;
        tmp = opener.node._next;
        while (tmp) {
            next = tmp._next;
            tmp.unlink();
            node.appendChild(tmp);
            tmp = next;
        }
        block.appendChild(node);
        this.processEmphasis(opener.previousDelimiter);
        this.removeBracket();
        opener.node.unlink();

        // We remove this bracket and processEmphasis will remove later delimiters.
        // Now, for a link, we also deactivate earlier link openers.
        // (no links in links)
        if (!is_image) {
          opener = this.brackets;
          while (opener !== null) {
            if (!opener.image) {
                opener.active = false; // deactivate this opener
            }
            opener = opener.previous;
          }
        }

        return true;

    } else { // no match

        this.removeBracket();  // remove this opener from stack
        this.pos = startpos;
        block.appendChild(text(']'));
        return true;
    }

};

var addBracket = function(node, index, image) {
    if (this.brackets !== null) {
        this.brackets.bracketAfter = true;
    }
    this.brackets = { node: node,
                      previous: this.brackets,
                      previousDelimiter: this.delimiters,
                      index: index,
                      image: image,
                      active: true };
};

var removeBracket = function() {
    this.brackets = this.brackets.previous;
};

// Attempt to parse an entity.
var parseEntity = function(block) {
    var m;
    if ((m = this.match(reEntityHere))) {
        block.appendChild(text(decodeHTML(m)));
        return true;
    } else {
        return false;
    }
};

// Parse a run of ordinary characters, or a single character with
// a special meaning in markdown, as a plain string.
var parseString = function(block) {
    var m;
    if ((m = this.match(reMain))) {
        if (this.options.smart) {
            block.appendChild(text(
                m.replace(reEllipses, "\u2026")
                    .replace(reDash, function(chars) {
                        var enCount = 0;
                        var emCount = 0;
                        if (chars.length % 3 === 0) { // If divisible by 3, use all em dashes
                            emCount = chars.length / 3;
                        } else if (chars.length % 2 === 0) { // If divisible by 2, use all en dashes
                            enCount = chars.length / 2;
                        } else if (chars.length % 3 === 2) { // If 2 extra dashes, use en dash for last 2; em dashes for rest
                            enCount = 1;
                            emCount = (chars.length - 2) / 3;
                        } else { // Use en dashes for last 4 hyphens; em dashes for rest
                            enCount = 2;
                            emCount = (chars.length - 4) / 3;
                        }
                        return "\u2014".repeat(emCount) + "\u2013".repeat(enCount);
                    })));
        } else {
            block.appendChild(text(m));
        }
        return true;
    } else {
        return false;
    }
};

// Parse a newline.  If it was preceded by two spaces, return a hard
// line break; otherwise a soft line break.
var parseNewline = function(block) {
    this.pos += 1; // assume we're at a \n
    // check previous node for trailing spaces
    var lastc = block._lastChild;
    if (lastc && lastc.type === 'text' && lastc._literal[lastc._literal.length - 1] === ' ') {
        var hardbreak = lastc._literal[lastc._literal.length - 2] === ' ';
        lastc._literal = lastc._literal.replace(reFinalSpace, '');
        block.appendChild(new Node(hardbreak ? 'linebreak' : 'softbreak'));
    } else {
        block.appendChild(new Node('softbreak'));
    }
    this.match(reInitialSpace); // gobble leading spaces in next line
    return true;
};

// Attempt to parse a link reference, modifying refmap.
var parseReference = function(s, refmap) {
    this.subject = s;
    this.pos = 0;
    var rawlabel;
    var dest;
    var title;
    var matchChars;
    var startpos = this.pos;

    // label:
    matchChars = this.parseLinkLabel();
    if (matchChars === 0) {
        return 0;
    } else {
        rawlabel = this.subject.substr(0, matchChars);
    }

    // colon:
    if (this.peek() === C_COLON) {
        this.pos++;
    } else {
        this.pos = startpos;
        return 0;
    }

    //  link url
    this.spnl();

    dest = this.parseLinkDestination();
    if (dest === null || dest.length === 0) {
        this.pos = startpos;
        return 0;
    }

    var beforetitle = this.pos;
    this.spnl();
    title = this.parseLinkTitle();
    if (title === null) {
        title = '';
        // rewind before spaces
        this.pos = beforetitle;
    }

    // make sure we're at line end:
    var atLineEnd = true;
    if (this.match(reSpaceAtEndOfLine) === null) {
        if (title === '') {
            atLineEnd = false;
        } else {
            // the potential title we found is not at the line end,
            // but it could still be a legal link reference if we
            // discard the title
            title = '';
            // rewind before spaces
            this.pos = beforetitle;
            // and instead check if the link URL is at the line end
            atLineEnd = this.match(reSpaceAtEndOfLine) !== null;
        }
    }

    if (!atLineEnd) {
        this.pos = startpos;
        return 0;
    }

    var normlabel = normalizeReference(rawlabel);
    if (normlabel === '') {
        // label must contain non-whitespace characters
        this.pos = startpos;
        return 0;
    }

    if (!refmap[normlabel]) {
        refmap[normlabel] = { destination: dest, title: title };
    }
    return this.pos - startpos;
};

// Parse the next inline element in subject, advancing subject position.
// On success, add the result to block's children and return true.
// On failure, return false.
var parseInline = function(block) {
    var res = false;
    var c = this.peek();
    if (c === -1) {
        return false;
    }
    switch(c) {
    case C_NEWLINE:
        res = this.parseNewline(block);
        break;
    case C_BACKSLASH:
        res = this.parseBackslash(block);
        break;
    case C_BACKTICK:
        res = this.parseBackticks(block);
        break;
    case C_ASTERISK:
    case C_UNDERSCORE:
        res = this.handleDelim(c, block);
        break;
    case C_SINGLEQUOTE:
    case C_DOUBLEQUOTE:
        res = this.options.smart && this.handleDelim(c, block);
        break;
    case C_OPEN_BRACKET:
        res = this.parseOpenBracket(block);
        break;
    case C_BANG:
        res = this.parseBang(block);
        break;
    case C_CLOSE_BRACKET:
        res = this.parseCloseBracket(block);
        break;
    case C_LESSTHAN:
        res = this.parseAutolink(block) || this.parseHtmlTag(block);
        break;
    case C_AMPERSAND:
        res = this.parseEntity(block);
        break;
    default:
        res = this.parseString(block);
        break;
    }
    if (!res) {
        this.pos += 1;
        block.appendChild(text(fromCodePoint(c)));
    }

    return true;
};

// Parse string content in block into inline children,
// using refmap to resolve references.
var parseInlines = function(block) {
    this.subject = block._string_content.trim();
    this.pos = 0;
    this.delimiters = null;
    this.brackets = null;
    while (this.parseInline(block)) {
    }
    block._string_content = null; // allow raw string to be garbage collected
    this.processEmphasis(null);
};

// The InlineParser object.
function InlineParser(options){
    return {
        subject: '',
        delimiters: null,  // used by handleDelim method
        brackets: null,
        pos: 0,
        refmap: {},
        match: match,
        peek: peek,
        spnl: spnl,
        parseBackticks: parseBackticks,
        parseBackslash: parseBackslash,
        parseAutolink: parseAutolink,
        parseHtmlTag: parseHtmlTag,
        scanDelims: scanDelims,
        handleDelim: handleDelim,
        parseLinkTitle: parseLinkTitle,
        parseLinkDestination: parseLinkDestination,
        parseLinkLabel: parseLinkLabel,
        parseOpenBracket: parseOpenBracket,
        parseBang: parseBang,
        parseCloseBracket: parseCloseBracket,
        addBracket: addBracket,
        removeBracket: removeBracket,
        parseEntity: parseEntity,
        parseString: parseString,
        parseNewline: parseNewline,
        parseReference: parseReference,
        parseInline: parseInline,
        processEmphasis: processEmphasis,
        removeDelimiter: removeDelimiter,
        options: options || {},
        parse: parseInlines
    };
}

module.exports = InlineParser;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* The bulk of this code derives from https://github.com/dmoscrop/fold-case
But in addition to case-folding, we also normalize whitespace.

fold-case is Copyright Mathias Bynens <https://mathiasbynens.be/>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/*eslint-disable  key-spacing, comma-spacing */

var regex = /[ \t\r\n]+|[A-Z\xB5\xC0-\xD6\xD8-\xDF\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u0149\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u017F\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C5\u01C7\u01C8\u01CA\u01CB\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F0-\u01F2\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0345\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03AB\u03B0\u03C2\u03CF-\u03D1\u03D5\u03D6\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F0\u03F1\u03F4\u03F5\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u0587\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E96-\u1E9B\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F50\u1F52\u1F54\u1F56\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1F80-\u1FAF\u1FB2-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD2\u1FD3\u1FD6-\u1FDB\u1FE2-\u1FE4\u1FE6-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2126\u212A\u212B\u2132\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0\uA7B1\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27]|\uD806[\uDCA0-\uDCBF]/g;

var map = {'A':'a','B':'b','C':'c','D':'d','E':'e','F':'f','G':'g','H':'h','I':'i','J':'j','K':'k','L':'l','M':'m','N':'n','O':'o','P':'p','Q':'q','R':'r','S':'s','T':'t','U':'u','V':'v','W':'w','X':'x','Y':'y','Z':'z','\xB5':'\u03BC','\xC0':'\xE0','\xC1':'\xE1','\xC2':'\xE2','\xC3':'\xE3','\xC4':'\xE4','\xC5':'\xE5','\xC6':'\xE6','\xC7':'\xE7','\xC8':'\xE8','\xC9':'\xE9','\xCA':'\xEA','\xCB':'\xEB','\xCC':'\xEC','\xCD':'\xED','\xCE':'\xEE','\xCF':'\xEF','\xD0':'\xF0','\xD1':'\xF1','\xD2':'\xF2','\xD3':'\xF3','\xD4':'\xF4','\xD5':'\xF5','\xD6':'\xF6','\xD8':'\xF8','\xD9':'\xF9','\xDA':'\xFA','\xDB':'\xFB','\xDC':'\xFC','\xDD':'\xFD','\xDE':'\xFE','\u0100':'\u0101','\u0102':'\u0103','\u0104':'\u0105','\u0106':'\u0107','\u0108':'\u0109','\u010A':'\u010B','\u010C':'\u010D','\u010E':'\u010F','\u0110':'\u0111','\u0112':'\u0113','\u0114':'\u0115','\u0116':'\u0117','\u0118':'\u0119','\u011A':'\u011B','\u011C':'\u011D','\u011E':'\u011F','\u0120':'\u0121','\u0122':'\u0123','\u0124':'\u0125','\u0126':'\u0127','\u0128':'\u0129','\u012A':'\u012B','\u012C':'\u012D','\u012E':'\u012F','\u0132':'\u0133','\u0134':'\u0135','\u0136':'\u0137','\u0139':'\u013A','\u013B':'\u013C','\u013D':'\u013E','\u013F':'\u0140','\u0141':'\u0142','\u0143':'\u0144','\u0145':'\u0146','\u0147':'\u0148','\u014A':'\u014B','\u014C':'\u014D','\u014E':'\u014F','\u0150':'\u0151','\u0152':'\u0153','\u0154':'\u0155','\u0156':'\u0157','\u0158':'\u0159','\u015A':'\u015B','\u015C':'\u015D','\u015E':'\u015F','\u0160':'\u0161','\u0162':'\u0163','\u0164':'\u0165','\u0166':'\u0167','\u0168':'\u0169','\u016A':'\u016B','\u016C':'\u016D','\u016E':'\u016F','\u0170':'\u0171','\u0172':'\u0173','\u0174':'\u0175','\u0176':'\u0177','\u0178':'\xFF','\u0179':'\u017A','\u017B':'\u017C','\u017D':'\u017E','\u017F':'s','\u0181':'\u0253','\u0182':'\u0183','\u0184':'\u0185','\u0186':'\u0254','\u0187':'\u0188','\u0189':'\u0256','\u018A':'\u0257','\u018B':'\u018C','\u018E':'\u01DD','\u018F':'\u0259','\u0190':'\u025B','\u0191':'\u0192','\u0193':'\u0260','\u0194':'\u0263','\u0196':'\u0269','\u0197':'\u0268','\u0198':'\u0199','\u019C':'\u026F','\u019D':'\u0272','\u019F':'\u0275','\u01A0':'\u01A1','\u01A2':'\u01A3','\u01A4':'\u01A5','\u01A6':'\u0280','\u01A7':'\u01A8','\u01A9':'\u0283','\u01AC':'\u01AD','\u01AE':'\u0288','\u01AF':'\u01B0','\u01B1':'\u028A','\u01B2':'\u028B','\u01B3':'\u01B4','\u01B5':'\u01B6','\u01B7':'\u0292','\u01B8':'\u01B9','\u01BC':'\u01BD','\u01C4':'\u01C6','\u01C5':'\u01C6','\u01C7':'\u01C9','\u01C8':'\u01C9','\u01CA':'\u01CC','\u01CB':'\u01CC','\u01CD':'\u01CE','\u01CF':'\u01D0','\u01D1':'\u01D2','\u01D3':'\u01D4','\u01D5':'\u01D6','\u01D7':'\u01D8','\u01D9':'\u01DA','\u01DB':'\u01DC','\u01DE':'\u01DF','\u01E0':'\u01E1','\u01E2':'\u01E3','\u01E4':'\u01E5','\u01E6':'\u01E7','\u01E8':'\u01E9','\u01EA':'\u01EB','\u01EC':'\u01ED','\u01EE':'\u01EF','\u01F1':'\u01F3','\u01F2':'\u01F3','\u01F4':'\u01F5','\u01F6':'\u0195','\u01F7':'\u01BF','\u01F8':'\u01F9','\u01FA':'\u01FB','\u01FC':'\u01FD','\u01FE':'\u01FF','\u0200':'\u0201','\u0202':'\u0203','\u0204':'\u0205','\u0206':'\u0207','\u0208':'\u0209','\u020A':'\u020B','\u020C':'\u020D','\u020E':'\u020F','\u0210':'\u0211','\u0212':'\u0213','\u0214':'\u0215','\u0216':'\u0217','\u0218':'\u0219','\u021A':'\u021B','\u021C':'\u021D','\u021E':'\u021F','\u0220':'\u019E','\u0222':'\u0223','\u0224':'\u0225','\u0226':'\u0227','\u0228':'\u0229','\u022A':'\u022B','\u022C':'\u022D','\u022E':'\u022F','\u0230':'\u0231','\u0232':'\u0233','\u023A':'\u2C65','\u023B':'\u023C','\u023D':'\u019A','\u023E':'\u2C66','\u0241':'\u0242','\u0243':'\u0180','\u0244':'\u0289','\u0245':'\u028C','\u0246':'\u0247','\u0248':'\u0249','\u024A':'\u024B','\u024C':'\u024D','\u024E':'\u024F','\u0345':'\u03B9','\u0370':'\u0371','\u0372':'\u0373','\u0376':'\u0377','\u037F':'\u03F3','\u0386':'\u03AC','\u0388':'\u03AD','\u0389':'\u03AE','\u038A':'\u03AF','\u038C':'\u03CC','\u038E':'\u03CD','\u038F':'\u03CE','\u0391':'\u03B1','\u0392':'\u03B2','\u0393':'\u03B3','\u0394':'\u03B4','\u0395':'\u03B5','\u0396':'\u03B6','\u0397':'\u03B7','\u0398':'\u03B8','\u0399':'\u03B9','\u039A':'\u03BA','\u039B':'\u03BB','\u039C':'\u03BC','\u039D':'\u03BD','\u039E':'\u03BE','\u039F':'\u03BF','\u03A0':'\u03C0','\u03A1':'\u03C1','\u03A3':'\u03C3','\u03A4':'\u03C4','\u03A5':'\u03C5','\u03A6':'\u03C6','\u03A7':'\u03C7','\u03A8':'\u03C8','\u03A9':'\u03C9','\u03AA':'\u03CA','\u03AB':'\u03CB','\u03C2':'\u03C3','\u03CF':'\u03D7','\u03D0':'\u03B2','\u03D1':'\u03B8','\u03D5':'\u03C6','\u03D6':'\u03C0','\u03D8':'\u03D9','\u03DA':'\u03DB','\u03DC':'\u03DD','\u03DE':'\u03DF','\u03E0':'\u03E1','\u03E2':'\u03E3','\u03E4':'\u03E5','\u03E6':'\u03E7','\u03E8':'\u03E9','\u03EA':'\u03EB','\u03EC':'\u03ED','\u03EE':'\u03EF','\u03F0':'\u03BA','\u03F1':'\u03C1','\u03F4':'\u03B8','\u03F5':'\u03B5','\u03F7':'\u03F8','\u03F9':'\u03F2','\u03FA':'\u03FB','\u03FD':'\u037B','\u03FE':'\u037C','\u03FF':'\u037D','\u0400':'\u0450','\u0401':'\u0451','\u0402':'\u0452','\u0403':'\u0453','\u0404':'\u0454','\u0405':'\u0455','\u0406':'\u0456','\u0407':'\u0457','\u0408':'\u0458','\u0409':'\u0459','\u040A':'\u045A','\u040B':'\u045B','\u040C':'\u045C','\u040D':'\u045D','\u040E':'\u045E','\u040F':'\u045F','\u0410':'\u0430','\u0411':'\u0431','\u0412':'\u0432','\u0413':'\u0433','\u0414':'\u0434','\u0415':'\u0435','\u0416':'\u0436','\u0417':'\u0437','\u0418':'\u0438','\u0419':'\u0439','\u041A':'\u043A','\u041B':'\u043B','\u041C':'\u043C','\u041D':'\u043D','\u041E':'\u043E','\u041F':'\u043F','\u0420':'\u0440','\u0421':'\u0441','\u0422':'\u0442','\u0423':'\u0443','\u0424':'\u0444','\u0425':'\u0445','\u0426':'\u0446','\u0427':'\u0447','\u0428':'\u0448','\u0429':'\u0449','\u042A':'\u044A','\u042B':'\u044B','\u042C':'\u044C','\u042D':'\u044D','\u042E':'\u044E','\u042F':'\u044F','\u0460':'\u0461','\u0462':'\u0463','\u0464':'\u0465','\u0466':'\u0467','\u0468':'\u0469','\u046A':'\u046B','\u046C':'\u046D','\u046E':'\u046F','\u0470':'\u0471','\u0472':'\u0473','\u0474':'\u0475','\u0476':'\u0477','\u0478':'\u0479','\u047A':'\u047B','\u047C':'\u047D','\u047E':'\u047F','\u0480':'\u0481','\u048A':'\u048B','\u048C':'\u048D','\u048E':'\u048F','\u0490':'\u0491','\u0492':'\u0493','\u0494':'\u0495','\u0496':'\u0497','\u0498':'\u0499','\u049A':'\u049B','\u049C':'\u049D','\u049E':'\u049F','\u04A0':'\u04A1','\u04A2':'\u04A3','\u04A4':'\u04A5','\u04A6':'\u04A7','\u04A8':'\u04A9','\u04AA':'\u04AB','\u04AC':'\u04AD','\u04AE':'\u04AF','\u04B0':'\u04B1','\u04B2':'\u04B3','\u04B4':'\u04B5','\u04B6':'\u04B7','\u04B8':'\u04B9','\u04BA':'\u04BB','\u04BC':'\u04BD','\u04BE':'\u04BF','\u04C0':'\u04CF','\u04C1':'\u04C2','\u04C3':'\u04C4','\u04C5':'\u04C6','\u04C7':'\u04C8','\u04C9':'\u04CA','\u04CB':'\u04CC','\u04CD':'\u04CE','\u04D0':'\u04D1','\u04D2':'\u04D3','\u04D4':'\u04D5','\u04D6':'\u04D7','\u04D8':'\u04D9','\u04DA':'\u04DB','\u04DC':'\u04DD','\u04DE':'\u04DF','\u04E0':'\u04E1','\u04E2':'\u04E3','\u04E4':'\u04E5','\u04E6':'\u04E7','\u04E8':'\u04E9','\u04EA':'\u04EB','\u04EC':'\u04ED','\u04EE':'\u04EF','\u04F0':'\u04F1','\u04F2':'\u04F3','\u04F4':'\u04F5','\u04F6':'\u04F7','\u04F8':'\u04F9','\u04FA':'\u04FB','\u04FC':'\u04FD','\u04FE':'\u04FF','\u0500':'\u0501','\u0502':'\u0503','\u0504':'\u0505','\u0506':'\u0507','\u0508':'\u0509','\u050A':'\u050B','\u050C':'\u050D','\u050E':'\u050F','\u0510':'\u0511','\u0512':'\u0513','\u0514':'\u0515','\u0516':'\u0517','\u0518':'\u0519','\u051A':'\u051B','\u051C':'\u051D','\u051E':'\u051F','\u0520':'\u0521','\u0522':'\u0523','\u0524':'\u0525','\u0526':'\u0527','\u0528':'\u0529','\u052A':'\u052B','\u052C':'\u052D','\u052E':'\u052F','\u0531':'\u0561','\u0532':'\u0562','\u0533':'\u0563','\u0534':'\u0564','\u0535':'\u0565','\u0536':'\u0566','\u0537':'\u0567','\u0538':'\u0568','\u0539':'\u0569','\u053A':'\u056A','\u053B':'\u056B','\u053C':'\u056C','\u053D':'\u056D','\u053E':'\u056E','\u053F':'\u056F','\u0540':'\u0570','\u0541':'\u0571','\u0542':'\u0572','\u0543':'\u0573','\u0544':'\u0574','\u0545':'\u0575','\u0546':'\u0576','\u0547':'\u0577','\u0548':'\u0578','\u0549':'\u0579','\u054A':'\u057A','\u054B':'\u057B','\u054C':'\u057C','\u054D':'\u057D','\u054E':'\u057E','\u054F':'\u057F','\u0550':'\u0580','\u0551':'\u0581','\u0552':'\u0582','\u0553':'\u0583','\u0554':'\u0584','\u0555':'\u0585','\u0556':'\u0586','\u10A0':'\u2D00','\u10A1':'\u2D01','\u10A2':'\u2D02','\u10A3':'\u2D03','\u10A4':'\u2D04','\u10A5':'\u2D05','\u10A6':'\u2D06','\u10A7':'\u2D07','\u10A8':'\u2D08','\u10A9':'\u2D09','\u10AA':'\u2D0A','\u10AB':'\u2D0B','\u10AC':'\u2D0C','\u10AD':'\u2D0D','\u10AE':'\u2D0E','\u10AF':'\u2D0F','\u10B0':'\u2D10','\u10B1':'\u2D11','\u10B2':'\u2D12','\u10B3':'\u2D13','\u10B4':'\u2D14','\u10B5':'\u2D15','\u10B6':'\u2D16','\u10B7':'\u2D17','\u10B8':'\u2D18','\u10B9':'\u2D19','\u10BA':'\u2D1A','\u10BB':'\u2D1B','\u10BC':'\u2D1C','\u10BD':'\u2D1D','\u10BE':'\u2D1E','\u10BF':'\u2D1F','\u10C0':'\u2D20','\u10C1':'\u2D21','\u10C2':'\u2D22','\u10C3':'\u2D23','\u10C4':'\u2D24','\u10C5':'\u2D25','\u10C7':'\u2D27','\u10CD':'\u2D2D','\u1E00':'\u1E01','\u1E02':'\u1E03','\u1E04':'\u1E05','\u1E06':'\u1E07','\u1E08':'\u1E09','\u1E0A':'\u1E0B','\u1E0C':'\u1E0D','\u1E0E':'\u1E0F','\u1E10':'\u1E11','\u1E12':'\u1E13','\u1E14':'\u1E15','\u1E16':'\u1E17','\u1E18':'\u1E19','\u1E1A':'\u1E1B','\u1E1C':'\u1E1D','\u1E1E':'\u1E1F','\u1E20':'\u1E21','\u1E22':'\u1E23','\u1E24':'\u1E25','\u1E26':'\u1E27','\u1E28':'\u1E29','\u1E2A':'\u1E2B','\u1E2C':'\u1E2D','\u1E2E':'\u1E2F','\u1E30':'\u1E31','\u1E32':'\u1E33','\u1E34':'\u1E35','\u1E36':'\u1E37','\u1E38':'\u1E39','\u1E3A':'\u1E3B','\u1E3C':'\u1E3D','\u1E3E':'\u1E3F','\u1E40':'\u1E41','\u1E42':'\u1E43','\u1E44':'\u1E45','\u1E46':'\u1E47','\u1E48':'\u1E49','\u1E4A':'\u1E4B','\u1E4C':'\u1E4D','\u1E4E':'\u1E4F','\u1E50':'\u1E51','\u1E52':'\u1E53','\u1E54':'\u1E55','\u1E56':'\u1E57','\u1E58':'\u1E59','\u1E5A':'\u1E5B','\u1E5C':'\u1E5D','\u1E5E':'\u1E5F','\u1E60':'\u1E61','\u1E62':'\u1E63','\u1E64':'\u1E65','\u1E66':'\u1E67','\u1E68':'\u1E69','\u1E6A':'\u1E6B','\u1E6C':'\u1E6D','\u1E6E':'\u1E6F','\u1E70':'\u1E71','\u1E72':'\u1E73','\u1E74':'\u1E75','\u1E76':'\u1E77','\u1E78':'\u1E79','\u1E7A':'\u1E7B','\u1E7C':'\u1E7D','\u1E7E':'\u1E7F','\u1E80':'\u1E81','\u1E82':'\u1E83','\u1E84':'\u1E85','\u1E86':'\u1E87','\u1E88':'\u1E89','\u1E8A':'\u1E8B','\u1E8C':'\u1E8D','\u1E8E':'\u1E8F','\u1E90':'\u1E91','\u1E92':'\u1E93','\u1E94':'\u1E95','\u1E9B':'\u1E61','\u1EA0':'\u1EA1','\u1EA2':'\u1EA3','\u1EA4':'\u1EA5','\u1EA6':'\u1EA7','\u1EA8':'\u1EA9','\u1EAA':'\u1EAB','\u1EAC':'\u1EAD','\u1EAE':'\u1EAF','\u1EB0':'\u1EB1','\u1EB2':'\u1EB3','\u1EB4':'\u1EB5','\u1EB6':'\u1EB7','\u1EB8':'\u1EB9','\u1EBA':'\u1EBB','\u1EBC':'\u1EBD','\u1EBE':'\u1EBF','\u1EC0':'\u1EC1','\u1EC2':'\u1EC3','\u1EC4':'\u1EC5','\u1EC6':'\u1EC7','\u1EC8':'\u1EC9','\u1ECA':'\u1ECB','\u1ECC':'\u1ECD','\u1ECE':'\u1ECF','\u1ED0':'\u1ED1','\u1ED2':'\u1ED3','\u1ED4':'\u1ED5','\u1ED6':'\u1ED7','\u1ED8':'\u1ED9','\u1EDA':'\u1EDB','\u1EDC':'\u1EDD','\u1EDE':'\u1EDF','\u1EE0':'\u1EE1','\u1EE2':'\u1EE3','\u1EE4':'\u1EE5','\u1EE6':'\u1EE7','\u1EE8':'\u1EE9','\u1EEA':'\u1EEB','\u1EEC':'\u1EED','\u1EEE':'\u1EEF','\u1EF0':'\u1EF1','\u1EF2':'\u1EF3','\u1EF4':'\u1EF5','\u1EF6':'\u1EF7','\u1EF8':'\u1EF9','\u1EFA':'\u1EFB','\u1EFC':'\u1EFD','\u1EFE':'\u1EFF','\u1F08':'\u1F00','\u1F09':'\u1F01','\u1F0A':'\u1F02','\u1F0B':'\u1F03','\u1F0C':'\u1F04','\u1F0D':'\u1F05','\u1F0E':'\u1F06','\u1F0F':'\u1F07','\u1F18':'\u1F10','\u1F19':'\u1F11','\u1F1A':'\u1F12','\u1F1B':'\u1F13','\u1F1C':'\u1F14','\u1F1D':'\u1F15','\u1F28':'\u1F20','\u1F29':'\u1F21','\u1F2A':'\u1F22','\u1F2B':'\u1F23','\u1F2C':'\u1F24','\u1F2D':'\u1F25','\u1F2E':'\u1F26','\u1F2F':'\u1F27','\u1F38':'\u1F30','\u1F39':'\u1F31','\u1F3A':'\u1F32','\u1F3B':'\u1F33','\u1F3C':'\u1F34','\u1F3D':'\u1F35','\u1F3E':'\u1F36','\u1F3F':'\u1F37','\u1F48':'\u1F40','\u1F49':'\u1F41','\u1F4A':'\u1F42','\u1F4B':'\u1F43','\u1F4C':'\u1F44','\u1F4D':'\u1F45','\u1F59':'\u1F51','\u1F5B':'\u1F53','\u1F5D':'\u1F55','\u1F5F':'\u1F57','\u1F68':'\u1F60','\u1F69':'\u1F61','\u1F6A':'\u1F62','\u1F6B':'\u1F63','\u1F6C':'\u1F64','\u1F6D':'\u1F65','\u1F6E':'\u1F66','\u1F6F':'\u1F67','\u1FB8':'\u1FB0','\u1FB9':'\u1FB1','\u1FBA':'\u1F70','\u1FBB':'\u1F71','\u1FBE':'\u03B9','\u1FC8':'\u1F72','\u1FC9':'\u1F73','\u1FCA':'\u1F74','\u1FCB':'\u1F75','\u1FD8':'\u1FD0','\u1FD9':'\u1FD1','\u1FDA':'\u1F76','\u1FDB':'\u1F77','\u1FE8':'\u1FE0','\u1FE9':'\u1FE1','\u1FEA':'\u1F7A','\u1FEB':'\u1F7B','\u1FEC':'\u1FE5','\u1FF8':'\u1F78','\u1FF9':'\u1F79','\u1FFA':'\u1F7C','\u1FFB':'\u1F7D','\u2126':'\u03C9','\u212A':'k','\u212B':'\xE5','\u2132':'\u214E','\u2160':'\u2170','\u2161':'\u2171','\u2162':'\u2172','\u2163':'\u2173','\u2164':'\u2174','\u2165':'\u2175','\u2166':'\u2176','\u2167':'\u2177','\u2168':'\u2178','\u2169':'\u2179','\u216A':'\u217A','\u216B':'\u217B','\u216C':'\u217C','\u216D':'\u217D','\u216E':'\u217E','\u216F':'\u217F','\u2183':'\u2184','\u24B6':'\u24D0','\u24B7':'\u24D1','\u24B8':'\u24D2','\u24B9':'\u24D3','\u24BA':'\u24D4','\u24BB':'\u24D5','\u24BC':'\u24D6','\u24BD':'\u24D7','\u24BE':'\u24D8','\u24BF':'\u24D9','\u24C0':'\u24DA','\u24C1':'\u24DB','\u24C2':'\u24DC','\u24C3':'\u24DD','\u24C4':'\u24DE','\u24C5':'\u24DF','\u24C6':'\u24E0','\u24C7':'\u24E1','\u24C8':'\u24E2','\u24C9':'\u24E3','\u24CA':'\u24E4','\u24CB':'\u24E5','\u24CC':'\u24E6','\u24CD':'\u24E7','\u24CE':'\u24E8','\u24CF':'\u24E9','\u2C00':'\u2C30','\u2C01':'\u2C31','\u2C02':'\u2C32','\u2C03':'\u2C33','\u2C04':'\u2C34','\u2C05':'\u2C35','\u2C06':'\u2C36','\u2C07':'\u2C37','\u2C08':'\u2C38','\u2C09':'\u2C39','\u2C0A':'\u2C3A','\u2C0B':'\u2C3B','\u2C0C':'\u2C3C','\u2C0D':'\u2C3D','\u2C0E':'\u2C3E','\u2C0F':'\u2C3F','\u2C10':'\u2C40','\u2C11':'\u2C41','\u2C12':'\u2C42','\u2C13':'\u2C43','\u2C14':'\u2C44','\u2C15':'\u2C45','\u2C16':'\u2C46','\u2C17':'\u2C47','\u2C18':'\u2C48','\u2C19':'\u2C49','\u2C1A':'\u2C4A','\u2C1B':'\u2C4B','\u2C1C':'\u2C4C','\u2C1D':'\u2C4D','\u2C1E':'\u2C4E','\u2C1F':'\u2C4F','\u2C20':'\u2C50','\u2C21':'\u2C51','\u2C22':'\u2C52','\u2C23':'\u2C53','\u2C24':'\u2C54','\u2C25':'\u2C55','\u2C26':'\u2C56','\u2C27':'\u2C57','\u2C28':'\u2C58','\u2C29':'\u2C59','\u2C2A':'\u2C5A','\u2C2B':'\u2C5B','\u2C2C':'\u2C5C','\u2C2D':'\u2C5D','\u2C2E':'\u2C5E','\u2C60':'\u2C61','\u2C62':'\u026B','\u2C63':'\u1D7D','\u2C64':'\u027D','\u2C67':'\u2C68','\u2C69':'\u2C6A','\u2C6B':'\u2C6C','\u2C6D':'\u0251','\u2C6E':'\u0271','\u2C6F':'\u0250','\u2C70':'\u0252','\u2C72':'\u2C73','\u2C75':'\u2C76','\u2C7E':'\u023F','\u2C7F':'\u0240','\u2C80':'\u2C81','\u2C82':'\u2C83','\u2C84':'\u2C85','\u2C86':'\u2C87','\u2C88':'\u2C89','\u2C8A':'\u2C8B','\u2C8C':'\u2C8D','\u2C8E':'\u2C8F','\u2C90':'\u2C91','\u2C92':'\u2C93','\u2C94':'\u2C95','\u2C96':'\u2C97','\u2C98':'\u2C99','\u2C9A':'\u2C9B','\u2C9C':'\u2C9D','\u2C9E':'\u2C9F','\u2CA0':'\u2CA1','\u2CA2':'\u2CA3','\u2CA4':'\u2CA5','\u2CA6':'\u2CA7','\u2CA8':'\u2CA9','\u2CAA':'\u2CAB','\u2CAC':'\u2CAD','\u2CAE':'\u2CAF','\u2CB0':'\u2CB1','\u2CB2':'\u2CB3','\u2CB4':'\u2CB5','\u2CB6':'\u2CB7','\u2CB8':'\u2CB9','\u2CBA':'\u2CBB','\u2CBC':'\u2CBD','\u2CBE':'\u2CBF','\u2CC0':'\u2CC1','\u2CC2':'\u2CC3','\u2CC4':'\u2CC5','\u2CC6':'\u2CC7','\u2CC8':'\u2CC9','\u2CCA':'\u2CCB','\u2CCC':'\u2CCD','\u2CCE':'\u2CCF','\u2CD0':'\u2CD1','\u2CD2':'\u2CD3','\u2CD4':'\u2CD5','\u2CD6':'\u2CD7','\u2CD8':'\u2CD9','\u2CDA':'\u2CDB','\u2CDC':'\u2CDD','\u2CDE':'\u2CDF','\u2CE0':'\u2CE1','\u2CE2':'\u2CE3','\u2CEB':'\u2CEC','\u2CED':'\u2CEE','\u2CF2':'\u2CF3','\uA640':'\uA641','\uA642':'\uA643','\uA644':'\uA645','\uA646':'\uA647','\uA648':'\uA649','\uA64A':'\uA64B','\uA64C':'\uA64D','\uA64E':'\uA64F','\uA650':'\uA651','\uA652':'\uA653','\uA654':'\uA655','\uA656':'\uA657','\uA658':'\uA659','\uA65A':'\uA65B','\uA65C':'\uA65D','\uA65E':'\uA65F','\uA660':'\uA661','\uA662':'\uA663','\uA664':'\uA665','\uA666':'\uA667','\uA668':'\uA669','\uA66A':'\uA66B','\uA66C':'\uA66D','\uA680':'\uA681','\uA682':'\uA683','\uA684':'\uA685','\uA686':'\uA687','\uA688':'\uA689','\uA68A':'\uA68B','\uA68C':'\uA68D','\uA68E':'\uA68F','\uA690':'\uA691','\uA692':'\uA693','\uA694':'\uA695','\uA696':'\uA697','\uA698':'\uA699','\uA69A':'\uA69B','\uA722':'\uA723','\uA724':'\uA725','\uA726':'\uA727','\uA728':'\uA729','\uA72A':'\uA72B','\uA72C':'\uA72D','\uA72E':'\uA72F','\uA732':'\uA733','\uA734':'\uA735','\uA736':'\uA737','\uA738':'\uA739','\uA73A':'\uA73B','\uA73C':'\uA73D','\uA73E':'\uA73F','\uA740':'\uA741','\uA742':'\uA743','\uA744':'\uA745','\uA746':'\uA747','\uA748':'\uA749','\uA74A':'\uA74B','\uA74C':'\uA74D','\uA74E':'\uA74F','\uA750':'\uA751','\uA752':'\uA753','\uA754':'\uA755','\uA756':'\uA757','\uA758':'\uA759','\uA75A':'\uA75B','\uA75C':'\uA75D','\uA75E':'\uA75F','\uA760':'\uA761','\uA762':'\uA763','\uA764':'\uA765','\uA766':'\uA767','\uA768':'\uA769','\uA76A':'\uA76B','\uA76C':'\uA76D','\uA76E':'\uA76F','\uA779':'\uA77A','\uA77B':'\uA77C','\uA77D':'\u1D79','\uA77E':'\uA77F','\uA780':'\uA781','\uA782':'\uA783','\uA784':'\uA785','\uA786':'\uA787','\uA78B':'\uA78C','\uA78D':'\u0265','\uA790':'\uA791','\uA792':'\uA793','\uA796':'\uA797','\uA798':'\uA799','\uA79A':'\uA79B','\uA79C':'\uA79D','\uA79E':'\uA79F','\uA7A0':'\uA7A1','\uA7A2':'\uA7A3','\uA7A4':'\uA7A5','\uA7A6':'\uA7A7','\uA7A8':'\uA7A9','\uA7AA':'\u0266','\uA7AB':'\u025C','\uA7AC':'\u0261','\uA7AD':'\u026C','\uA7B0':'\u029E','\uA7B1':'\u0287','\uFF21':'\uFF41','\uFF22':'\uFF42','\uFF23':'\uFF43','\uFF24':'\uFF44','\uFF25':'\uFF45','\uFF26':'\uFF46','\uFF27':'\uFF47','\uFF28':'\uFF48','\uFF29':'\uFF49','\uFF2A':'\uFF4A','\uFF2B':'\uFF4B','\uFF2C':'\uFF4C','\uFF2D':'\uFF4D','\uFF2E':'\uFF4E','\uFF2F':'\uFF4F','\uFF30':'\uFF50','\uFF31':'\uFF51','\uFF32':'\uFF52','\uFF33':'\uFF53','\uFF34':'\uFF54','\uFF35':'\uFF55','\uFF36':'\uFF56','\uFF37':'\uFF57','\uFF38':'\uFF58','\uFF39':'\uFF59','\uFF3A':'\uFF5A','\uD801\uDC00':'\uD801\uDC28','\uD801\uDC01':'\uD801\uDC29','\uD801\uDC02':'\uD801\uDC2A','\uD801\uDC03':'\uD801\uDC2B','\uD801\uDC04':'\uD801\uDC2C','\uD801\uDC05':'\uD801\uDC2D','\uD801\uDC06':'\uD801\uDC2E','\uD801\uDC07':'\uD801\uDC2F','\uD801\uDC08':'\uD801\uDC30','\uD801\uDC09':'\uD801\uDC31','\uD801\uDC0A':'\uD801\uDC32','\uD801\uDC0B':'\uD801\uDC33','\uD801\uDC0C':'\uD801\uDC34','\uD801\uDC0D':'\uD801\uDC35','\uD801\uDC0E':'\uD801\uDC36','\uD801\uDC0F':'\uD801\uDC37','\uD801\uDC10':'\uD801\uDC38','\uD801\uDC11':'\uD801\uDC39','\uD801\uDC12':'\uD801\uDC3A','\uD801\uDC13':'\uD801\uDC3B','\uD801\uDC14':'\uD801\uDC3C','\uD801\uDC15':'\uD801\uDC3D','\uD801\uDC16':'\uD801\uDC3E','\uD801\uDC17':'\uD801\uDC3F','\uD801\uDC18':'\uD801\uDC40','\uD801\uDC19':'\uD801\uDC41','\uD801\uDC1A':'\uD801\uDC42','\uD801\uDC1B':'\uD801\uDC43','\uD801\uDC1C':'\uD801\uDC44','\uD801\uDC1D':'\uD801\uDC45','\uD801\uDC1E':'\uD801\uDC46','\uD801\uDC1F':'\uD801\uDC47','\uD801\uDC20':'\uD801\uDC48','\uD801\uDC21':'\uD801\uDC49','\uD801\uDC22':'\uD801\uDC4A','\uD801\uDC23':'\uD801\uDC4B','\uD801\uDC24':'\uD801\uDC4C','\uD801\uDC25':'\uD801\uDC4D','\uD801\uDC26':'\uD801\uDC4E','\uD801\uDC27':'\uD801\uDC4F','\uD806\uDCA0':'\uD806\uDCC0','\uD806\uDCA1':'\uD806\uDCC1','\uD806\uDCA2':'\uD806\uDCC2','\uD806\uDCA3':'\uD806\uDCC3','\uD806\uDCA4':'\uD806\uDCC4','\uD806\uDCA5':'\uD806\uDCC5','\uD806\uDCA6':'\uD806\uDCC6','\uD806\uDCA7':'\uD806\uDCC7','\uD806\uDCA8':'\uD806\uDCC8','\uD806\uDCA9':'\uD806\uDCC9','\uD806\uDCAA':'\uD806\uDCCA','\uD806\uDCAB':'\uD806\uDCCB','\uD806\uDCAC':'\uD806\uDCCC','\uD806\uDCAD':'\uD806\uDCCD','\uD806\uDCAE':'\uD806\uDCCE','\uD806\uDCAF':'\uD806\uDCCF','\uD806\uDCB0':'\uD806\uDCD0','\uD806\uDCB1':'\uD806\uDCD1','\uD806\uDCB2':'\uD806\uDCD2','\uD806\uDCB3':'\uD806\uDCD3','\uD806\uDCB4':'\uD806\uDCD4','\uD806\uDCB5':'\uD806\uDCD5','\uD806\uDCB6':'\uD806\uDCD6','\uD806\uDCB7':'\uD806\uDCD7','\uD806\uDCB8':'\uD806\uDCD8','\uD806\uDCB9':'\uD806\uDCD9','\uD806\uDCBA':'\uD806\uDCDA','\uD806\uDCBB':'\uD806\uDCDB','\uD806\uDCBC':'\uD806\uDCDC','\uD806\uDCBD':'\uD806\uDCDD','\uD806\uDCBE':'\uD806\uDCDE','\uD806\uDCBF':'\uD806\uDCDF','\xDF':'ss','\u0130':'i\u0307','\u0149':'\u02BCn','\u01F0':'j\u030C','\u0390':'\u03B9\u0308\u0301','\u03B0':'\u03C5\u0308\u0301','\u0587':'\u0565\u0582','\u1E96':'h\u0331','\u1E97':'t\u0308','\u1E98':'w\u030A','\u1E99':'y\u030A','\u1E9A':'a\u02BE','\u1E9E':'ss','\u1F50':'\u03C5\u0313','\u1F52':'\u03C5\u0313\u0300','\u1F54':'\u03C5\u0313\u0301','\u1F56':'\u03C5\u0313\u0342','\u1F80':'\u1F00\u03B9','\u1F81':'\u1F01\u03B9','\u1F82':'\u1F02\u03B9','\u1F83':'\u1F03\u03B9','\u1F84':'\u1F04\u03B9','\u1F85':'\u1F05\u03B9','\u1F86':'\u1F06\u03B9','\u1F87':'\u1F07\u03B9','\u1F88':'\u1F00\u03B9','\u1F89':'\u1F01\u03B9','\u1F8A':'\u1F02\u03B9','\u1F8B':'\u1F03\u03B9','\u1F8C':'\u1F04\u03B9','\u1F8D':'\u1F05\u03B9','\u1F8E':'\u1F06\u03B9','\u1F8F':'\u1F07\u03B9','\u1F90':'\u1F20\u03B9','\u1F91':'\u1F21\u03B9','\u1F92':'\u1F22\u03B9','\u1F93':'\u1F23\u03B9','\u1F94':'\u1F24\u03B9','\u1F95':'\u1F25\u03B9','\u1F96':'\u1F26\u03B9','\u1F97':'\u1F27\u03B9','\u1F98':'\u1F20\u03B9','\u1F99':'\u1F21\u03B9','\u1F9A':'\u1F22\u03B9','\u1F9B':'\u1F23\u03B9','\u1F9C':'\u1F24\u03B9','\u1F9D':'\u1F25\u03B9','\u1F9E':'\u1F26\u03B9','\u1F9F':'\u1F27\u03B9','\u1FA0':'\u1F60\u03B9','\u1FA1':'\u1F61\u03B9','\u1FA2':'\u1F62\u03B9','\u1FA3':'\u1F63\u03B9','\u1FA4':'\u1F64\u03B9','\u1FA5':'\u1F65\u03B9','\u1FA6':'\u1F66\u03B9','\u1FA7':'\u1F67\u03B9','\u1FA8':'\u1F60\u03B9','\u1FA9':'\u1F61\u03B9','\u1FAA':'\u1F62\u03B9','\u1FAB':'\u1F63\u03B9','\u1FAC':'\u1F64\u03B9','\u1FAD':'\u1F65\u03B9','\u1FAE':'\u1F66\u03B9','\u1FAF':'\u1F67\u03B9','\u1FB2':'\u1F70\u03B9','\u1FB3':'\u03B1\u03B9','\u1FB4':'\u03AC\u03B9','\u1FB6':'\u03B1\u0342','\u1FB7':'\u03B1\u0342\u03B9','\u1FBC':'\u03B1\u03B9','\u1FC2':'\u1F74\u03B9','\u1FC3':'\u03B7\u03B9','\u1FC4':'\u03AE\u03B9','\u1FC6':'\u03B7\u0342','\u1FC7':'\u03B7\u0342\u03B9','\u1FCC':'\u03B7\u03B9','\u1FD2':'\u03B9\u0308\u0300','\u1FD3':'\u03B9\u0308\u0301','\u1FD6':'\u03B9\u0342','\u1FD7':'\u03B9\u0308\u0342','\u1FE2':'\u03C5\u0308\u0300','\u1FE3':'\u03C5\u0308\u0301','\u1FE4':'\u03C1\u0313','\u1FE6':'\u03C5\u0342','\u1FE7':'\u03C5\u0308\u0342','\u1FF2':'\u1F7C\u03B9','\u1FF3':'\u03C9\u03B9','\u1FF4':'\u03CE\u03B9','\u1FF6':'\u03C9\u0342','\u1FF7':'\u03C9\u0342\u03B9','\u1FFC':'\u03C9\u03B9','\uFB00':'ff','\uFB01':'fi','\uFB02':'fl','\uFB03':'ffi','\uFB04':'ffl','\uFB05':'st','\uFB06':'st','\uFB13':'\u0574\u0576','\uFB14':'\u0574\u0565','\uFB15':'\u0574\u056B','\uFB16':'\u057E\u0576','\uFB17':'\u0574\u056D'};

// Normalize reference label: collapse internal whitespace
// to single space, remove leading/trailing whitespace, case fold.
module.exports = function(string) {
    return string.slice(1, string.length - 1).trim().replace(regex, function($0) {
        // Note: there is no need to check `hasOwnProperty($0)` here.
        // If character not found in lookup table, it must be whitespace.
        return map[$0] || ' ';
    });
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// derived from https://github.com/mathiasbynens/String.fromCodePoint
/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
if (String.fromCodePoint) {
    module.exports = function (_) {
        try {
            return String.fromCodePoint(_);
        } catch (e) {
            if (e instanceof RangeError) {
                return String.fromCharCode(0xFFFD);
            }
            throw e;
        }
    };

} else {

  var stringFromCharCode = String.fromCharCode;
  var floor = Math.floor;
  var fromCodePoint = function() {
      var MAX_SIZE = 0x4000;
      var codeUnits = [];
      var highSurrogate;
      var lowSurrogate;
      var index = -1;
      var length = arguments.length;
      if (!length) {
          return '';
      }
      var result = '';
      while (++index < length) {
          var codePoint = Number(arguments[index]);
          if (
              !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                  codePoint < 0 || // not a valid Unicode code point
                  codePoint > 0x10FFFF || // not a valid Unicode code point
                  floor(codePoint) !== codePoint // not an integer
          ) {
              return String.fromCharCode(0xFFFD);
          }
          if (codePoint <= 0xFFFF) { // BMP code point
              codeUnits.push(codePoint);
          } else { // Astral code point; split in surrogate halves
              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
              codePoint -= 0x10000;
              highSurrogate = (codePoint >> 10) + 0xD800;
              lowSurrogate = (codePoint % 0x400) + 0xDC00;
              codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
          }
      }
      return result;
  };
  module.exports = fromCodePoint;
}


/***/ }),
/* 72 */
/***/ (function(module, exports) {

/*! http://mths.be/repeat v0.2.0 by @mathias */
if (!String.prototype.repeat) {
	(function() {
		'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var repeat = function(count) {
			if (this == null) {
				throw TypeError();
			}
			var string = String(this);
			// `ToInteger`
			var n = count ? Number(count) : 0;
			if (n != n) { // better `isNaN`
				n = 0;
			}
			// Account for out-of-bounds indices
			if (n < 0 || n == Infinity) {
				throw RangeError();
			}
			var result = '';
			while (n) {
				if (n % 2 == 1) {
					result += string;
				}
				if (n > 1) {
					string += string;
				}
				n >>= 1;
			}
			return result;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'repeat', {
				'value': repeat,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.repeat = repeat;
		}
	}());
}


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Renderer = __webpack_require__(15);

var reUnsafeProtocol = /^javascript:|vbscript:|file:|data:/i;
var reSafeDataProtocol = /^data:image\/(?:png|gif|jpeg|webp)/i;

var potentiallyUnsafe = function(url) {
  return reUnsafeProtocol.test(url) &&
      !reSafeDataProtocol.test(url);
};

// Helper function to produce an HTML tag.
function tag(name, attrs, selfclosing) {
  if (this.disableTags > 0) {
    return;
  }
  this.buffer += ('<' + name);
  if (attrs && attrs.length > 0) {
    var i = 0;
    var attrib;
    while ((attrib = attrs[i]) !== undefined) {
      this.buffer += (' ' + attrib[0] + '="' + attrib[1] + '"');
      i++;
    }
  }
  if (selfclosing) {
    this.buffer += ' /';
  }
  this.buffer += '>';
  this.lastOut = '>';
}

function HtmlRenderer(options) {
  options = options || {};
  // by default, soft breaks are rendered as newlines in HTML
  options.softbreak = options.softbreak || '\n';
  // set to "<br />" to make them hard breaks
  // set to " " if you want to ignore line wrapping in source

  this.disableTags = 0;
  this.lastOut = "\n";
  this.options = options;
}

/* Node methods */

function text(node) {
  this.out(node.literal);
}

function softbreak() {
  this.lit(this.options.softbreak);
}

function linebreak() {
  this.tag('br', [], true);
  this.cr();
}

function link(node, entering) {
  var attrs = this.attrs(node);
  if (entering) {
    if (!(this.options.safe && potentiallyUnsafe(node.destination))) {
      attrs.push(['href', this.esc(node.destination, true)]);
    }
    if (node.title) {
      attrs.push(['title', this.esc(node.title, true)]);
    }
    this.tag('a', attrs);
  } else {
    this.tag('/a');
  }
}

function image(node, entering) {
  if (entering) {
    if (this.disableTags === 0) {
      if (this.options.safe && potentiallyUnsafe(node.destination)) {
        this.lit('<img src="" alt="');
      } else {
        this.lit('<img src="' + this.esc(node.destination, true) +
            '" alt="');
      }
    }
    this.disableTags += 1;
  } else {
    this.disableTags -= 1;
    if (this.disableTags === 0) {
      if (node.title) {
        this.lit('" title="' + this.esc(node.title, true));
      }
      this.lit('" />');
    }
  }
}

function emph(node, entering) {
  this.tag(entering ? 'em' : '/em');
}

function strong(node, entering) {
  this.tag(entering ? 'strong' : '/strong');
}

function paragraph(node, entering) {
  var grandparent = node.parent.parent
    , attrs = this.attrs(node);
  if (grandparent !== null &&
    grandparent.type === 'list') {
    if (grandparent.listTight) {
      return;
    }
  }
  if (entering) {
    this.cr();
    this.tag('p', attrs);
  } else {
    this.tag('/p');
    this.cr();
  }
}

function heading(node, entering) {
  var tagname = 'h' + node.level
    , attrs = this.attrs(node);
  if (entering) {
    this.cr();
    this.tag(tagname, attrs);
  } else {
    this.tag('/' + tagname);
    this.cr();
  }
}

function code(node) {
  this.tag('code');
  this.out(node.literal);
  this.tag('/code');
}

function code_block(node) {
  var info_words = node.info ? node.info.split(/\s+/) : []
    , attrs = this.attrs(node);
  if (info_words.length > 0 && info_words[0].length > 0) {
    attrs.push(['class', 'language-' + this.esc(info_words[0], true)]);
  }
  this.cr();
  this.tag('pre');
  this.tag('code', attrs);
  this.out(node.literal);
  this.tag('/code');
  this.tag('/pre');
  this.cr();
}

function thematic_break(node) {
  var attrs = this.attrs(node);
  this.cr();
  this.tag('hr', attrs, true);
  this.cr();
}

function block_quote(node, entering) {
  var attrs = this.attrs(node);
  if (entering) {
    this.cr();
    this.tag('blockquote', attrs);
    this.cr();
  } else {
    this.cr();
    this.tag('/blockquote');
    this.cr();
  }
}

function list(node, entering) {
  var tagname = node.listType === 'bullet' ? 'ul' : 'ol'
    , attrs = this.attrs(node);

  if (entering) {
    var start = node.listStart;
    if (start !== null && start !== 1) {
      attrs.push(['start', start.toString()]);
    }
    this.cr();
    this.tag(tagname, attrs);
    this.cr();
  } else {
    this.cr();
    this.tag('/' + tagname);
    this.cr();
  }
}

function item(node, entering) {
  var attrs = this.attrs(node);
  if (entering) {
    this.tag('li', attrs);
  } else {
    this.tag('/li');
    this.cr();
  }
}

function html_inline(node) {
  if (this.options.safe) {
    this.lit('<!-- raw HTML omitted -->');
  } else {
    this.lit(node.literal);
  }
}

function html_block(node) {
  this.cr();
  if (this.options.safe) {
    this.lit('<!-- raw HTML omitted -->');
  } else {
    this.lit(node.literal);
  }
  this.cr();
}

function custom_inline(node, entering) {
  if (entering && node.onEnter) {
    this.lit(node.onEnter);
  } else if (!entering && node.onExit) {
    this.lit(node.onExit);
  }
}

function custom_block(node, entering) {
  this.cr();
  if (entering && node.onEnter) {
    this.lit(node.onEnter);
  } else if (!entering && node.onExit) {
    this.lit(node.onExit);
  }
  this.cr();
}

/* Helper methods */

function out(s) {
  this.lit(this.esc(s, false));
}

function attrs (node) {
  var att = [];
  if (this.options.sourcepos) {
    var pos = node.sourcepos;
    if (pos) {
      att.push(['data-sourcepos', String(pos[0][0]) + ':' +
        String(pos[0][1]) + '-' + String(pos[1][0]) + ':' +
        String(pos[1][1])]);
    }
  }
  return att;
}

// quick browser-compatible inheritance
HtmlRenderer.prototype = Object.create(Renderer.prototype);

HtmlRenderer.prototype.text = text;
HtmlRenderer.prototype.html_inline = html_inline;
HtmlRenderer.prototype.html_block = html_block;
HtmlRenderer.prototype.softbreak = softbreak;
HtmlRenderer.prototype.linebreak = linebreak;
HtmlRenderer.prototype.link = link;
HtmlRenderer.prototype.image = image;
HtmlRenderer.prototype.emph = emph;
HtmlRenderer.prototype.strong = strong;
HtmlRenderer.prototype.paragraph = paragraph;
HtmlRenderer.prototype.heading = heading;
HtmlRenderer.prototype.code = code;
HtmlRenderer.prototype.code_block = code_block;
HtmlRenderer.prototype.thematic_break = thematic_break;
HtmlRenderer.prototype.block_quote = block_quote;
HtmlRenderer.prototype.list = list;
HtmlRenderer.prototype.item = item;
HtmlRenderer.prototype.custom_inline = custom_inline;
HtmlRenderer.prototype.custom_block = custom_block;

HtmlRenderer.prototype.esc = __webpack_require__(4).escapeXml;

HtmlRenderer.prototype.out = out;
HtmlRenderer.prototype.tag = tag;
HtmlRenderer.prototype.attrs = attrs;

module.exports = HtmlRenderer;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Renderer = __webpack_require__(15);

var reXMLTag = /\<[^>]*\>/;

function toTagName(s) {
  return s.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}

function XmlRenderer(options) {
  options = options || {};

  this.disableTags = 0;
  this.lastOut = "\n";

  this.indentLevel = 0;
  this.indent = '  ';

  this.options = options;
}

function render(ast) {

  this.buffer = '';

  var attrs;
  var tagname;
  var walker = ast.walker();
  var event, node, entering;
  var container;
  var selfClosing;
  var nodetype;

  var options = this.options;

  if (options.time) { console.time("rendering"); }

  this.buffer += '<?xml version="1.0" encoding="UTF-8"?>\n';
  this.buffer += '<!DOCTYPE document SYSTEM "CommonMark.dtd">\n';

  while ((event = walker.next())) {
    entering = event.entering;
    node = event.node;
    nodetype = node.type;

    container = node.isContainer;

    selfClosing = nodetype === 'thematic_break'
      || nodetype === 'linebreak'
      || nodetype === 'softbreak';

    tagname = toTagName(nodetype);

    if (entering) {

        attrs = [];

        switch (nodetype) {
          case 'document':
            attrs.push(['xmlns', 'http://commonmark.org/xml/1.0']);
            break;
          case 'list':
            if (node.listType !== null) {
              attrs.push(['type', node.listType.toLowerCase()]);
            }
            if (node.listStart !== null) {
              attrs.push(['start', String(node.listStart)]);
            }
            if (node.listTight !== null) {
              attrs.push(['tight', (node.listTight ? 'true' : 'false')]);
            }
            var delim = node.listDelimiter;
            if (delim !== null) {
              var delimword = '';
              if (delim === '.') {
                delimword = 'period';
              } else {
                delimword = 'paren';
              }
              attrs.push(['delimiter', delimword]);
            }
            break;
          case 'code_block':
            if (node.info) {
              attrs.push(['info', node.info]);
            }
            break;
          case 'heading':
            attrs.push(['level', String(node.level)]);
            break;
          case 'link':
          case 'image':
            attrs.push(['destination', node.destination]);
            attrs.push(['title', node.title]);
            break;
          case 'custom_inline':
          case 'custom_block':
            attrs.push(['on_enter', node.onEnter]);
            attrs.push(['on_exit', node.onExit]);
            break;
          default:
            break;
        }
        if (options.sourcepos) {
          var pos = node.sourcepos;
          if (pos) {
            attrs.push(['sourcepos', String(pos[0][0]) + ':' +
              String(pos[0][1]) + '-' + String(pos[1][0]) + ':' +
              String(pos[1][1])]);
          }
        }

        this.cr();
        this.out(this.tag(tagname, attrs, selfClosing));
        if (container) {
          this.indentLevel += 1;
        } else if (!container && !selfClosing) {
          var lit = node.literal;
          if (lit) {
            this.out(this.esc(lit));
          }
          this.out(this.tag('/' + tagname));
        }
    } else {
      this.indentLevel -= 1;
      this.cr();
      this.out(this.tag('/' + tagname));
    }
  }
  if (options.time) { console.timeEnd("rendering"); }
  this.buffer += '\n';
  return this.buffer;
}

function out(s) {
  if(this.disableTags > 0) {
    this.buffer += s.replace(reXMLTag, '');
  }else{
    this.buffer += s;
  }
  this.lastOut = s;
}

function cr() {
  if(this.lastOut !== '\n') {
    this.buffer += '\n';
    this.lastOut = '\n';
    for(var i = this.indentLevel; i > 0; i--) {
      this.buffer += this.indent;
    }
  }
}

// Helper function to produce an XML tag.
function tag(name, attrs, selfclosing) {
  var result = '<' + name;
  if(attrs && attrs.length > 0) {
    var i = 0;
    var attrib;
    while ((attrib = attrs[i]) !== undefined) {
      result += ' ' + attrib[0] + '="' + this.esc(attrib[1]) + '"';
      i++;
    }
  }
  if(selfclosing) {
    result += ' /';
  }
  result += '>';
  return result;
}

// quick browser-compatible inheritance
XmlRenderer.prototype = Object.create(Renderer.prototype);

XmlRenderer.prototype.render = render;
XmlRenderer.prototype.out = out;
XmlRenderer.prototype.cr = cr;
XmlRenderer.prototype.tag = tag;
XmlRenderer.prototype.esc = __webpack_require__(4).escapeXml;

module.exports = XmlRenderer;


/***/ }),
/* 75 */
/***/ (function(module, exports) {

const metaTagGenerator = function(){
    // expects at least one string of type `attribute="value"`
    const argArr = [...arguments];
    const checkForElement = document.querySelector('head [' + argArr.join('][') + ']');
    if (!checkForElement){
        const metaElement = document.createElement('meta');
        for (let argument of argArr){
            const split = argument.split('="');
            metaElement.setAttribute(split[0], split[1].substring(0, split[1].length-1));
        }
        document.head.appendChild(metaElement);
        return metaElement;
    }
    else return checkForElement;
}
module.exports = function(document) {
    // some good practices (especially for fragments)
    // add <meta charset="UTF-8">
    metaTagGenerator('charset="UTF-8"');
    // <meta name="viewport" content="width=device-width, initial-scale=1.0">
    metaTagGenerator('name="viewport"', 'content="width=device-width, initial-scale=1.0"')
    // <meta http-equiv="X-UA-Compatible" content="ie=edge">
    metaTagGenerator('http-equiv="X-UA-Compatible"', 'content="ie=edge"');

};


/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = function(document) {
  const TAGNAMES = [
    'body',
    'chapter',
    'section',
    'theorem',
    'lemma',
    'proposition',
    'corollary',
    'proof',
    'abstract',
    'figure'
  ];
  const candidates = document.querySelectorAll(TAGNAMES.join(','));
  for (let candidate of candidates) {
    // for (let child of candidate.childNodes) {
    //   if (child.nodeType === 3 && child.nodeValue.trim() !== '') {
    //     child.nodeValue = '\n' + child.nodeValue.replace(/\n/g, '\n\n') + '\n';
    //   }
    // }
    const text = document.createTextNode('\n\n');
    candidate.appendChild(text);
    candidate.insertBefore(text.cloneNode(true), candidate.firstChild);
  }
};

// wrap phrasing content in p

// const PHRASING_TAGNAMES = ['abbr', 'audio', 'b', 'bdo', 'br', 'button', 'canvas', 'cite', 'code', 'command', 'data', 'datalist', 'dfn', 'em', 'embed', 'i', 'iframe', 'img', 'input', 'kbd', 'keygen', 'label', 'mark', 'math', 'meter', 'noscript', 'object', 'output', 'progress', 'q', 'ruby', 'samp', 'script', 'select', 'small', 'span', 'strong', 'sub', 'sup', 'svg', 'textarea', 'time', 'var', 'video', 'wbr', 'a', 'del', 'ins']
// const candidates = []//document.querySelectorAll('body, section, figure');
// for (let candidate of candidates){
//   // console.log(candidate)
//   const childNodes = candidate.childNodes;
//   const arrayofarrays = [[]];
//   for (let childNode of childNodes){
//     const currentBatch = arrayofarrays[arrayofarrays.length -1];
//     // console.log(childNode)
//     if (childNode.nodeType === 3){
//       const lines = childNode.data.split('\n');
//       let temp = childNode;
//       for (let [index, line] of lines.entries()){
//         if (index === 0) {
//           childNode.data = line;
//           currentBatch.push(childNode);
//         }
//         else {
//           const lineElement = document.createTextNode(line);
//           // console.log('Before', childNode.nextSibling)
//           childNode.parentNode.insertBefore(lineElement, temp.nextSibling);
//           temp = lineElement;
//           // console.log('After', childNode.nextSibling)
//           arrayofarrays.push([lineElement]);
//         }
//       }
//     }
//     else if (childNode.nodeType === 8 || PHRASING_TAGNAMES.indexOf(childNode.tagName.toLowerCase()) > -1) {
//       currentBatch.push(childNode);
//     }
//     else if(currentBatch.length > 0)  arrayofarrays.push([]);
//   }
//   console.log(arrayofarrays)
//   for (let array of arrayofarrays){
//     if (array.length === 0) continue
//     const para = document.createElement('p');
//     const first = array[0];
//     // console.log(first);
//     first.parentNode.replaceChild(para, first);
//     for (node of array) para.appendChild(node);
//   }
// }


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgY2U0MmYwMDI2ZGFlOTE1MWVhMmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb21tb25tYXJrL2xpYi9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZXhjZXB0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZmFpbHNhZmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbW1vbm1hcmsvbGliL25vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2pzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VudGl0aWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9tYXBzL3htbC5qc29uIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbW1vbm1hcmsvbGliL3JlbmRlci9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvd29ya2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xhbWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3lhbWxkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2xvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9tYXJrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc3RyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc2VxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvbnVsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Jvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3RpbWVzdGFtcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21lcmdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvYmluYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvb21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3BhaXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvdW5kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvcmVnZXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbm9kZV9tb2R1bGVzL2VzcHJpbWEvZGlzdC9lc3ByaW1hLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2R1bXBlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ByZWFtYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9hYnN0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2VjdGlvbmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RhdGVtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZmlndXJlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2JsYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVmcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2l0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vdGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9iaWJsaW9ncmFwaHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RleDJqYXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbW1vbm1hcmsvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb21tb25tYXJrL2xpYi9ibG9ja3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21kdXJsL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWR1cmwvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9tYXBzL2xlZ2FjeS5qc29uIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZGVjb2RlX2NvZGVwb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW50aXRpZXMvbWFwcy9kZWNvZGUuanNvbiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tbW9ubWFyay9saWIvaW5saW5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tbW9ubWFyay9saWIvbm9ybWFsaXplLXJlZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tbW9ubWFyay9saWIvZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpbmcucHJvdG90eXBlLnJlcGVhdC9yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbW1vbm1hcmsvbGliL3JlbmRlci9odG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb21tb25tYXJrL2xpYi9yZW5kZXIveG1sLmpzIiwid2VicGFjazovLy8uL3NyYy9odG1sLWhlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhcmFnYXBocy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDN0RBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsYUFBYTtBQUMzRSxrRUFBa0UsYUFBYTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEJBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxREE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkI7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLGlDQUFpQyxFQUFFO0FBQzNFO0FBQ0E7O0FBRUEsb0NBQW9DLDZCQUE2QixFQUFFO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7Ozs7Ozs7QUMzR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2QkFBNkIsSUFBSSxRQUFRLElBQUksZUFBZSxLQUFLLEVBQUU7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLGlCQUFpQixFQUFFOztBQUV0RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0R0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUMzQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUN4QkQ7QUFDQTs7O0FBR0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ2hCRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hELENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsc0JBQXNCLEVBQUU7QUFDN0Msc0JBQXNCLG1CQUFtQjtBQUN6QyxDQUFDOztBQUVEO0FBQ0EscUJBQXFCLDBCQUEwQixFQUFFO0FBQ2pELHNCQUFzQix1QkFBdUI7QUFDN0MsQ0FBQzs7QUFFRDtBQUNBLHFCQUFxQixvQkFBb0IsRUFBRTtBQUMzQyxzQkFBc0IsaUJBQWlCO0FBQ3ZDLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsbUJBQW1CLEVBQUU7QUFDMUMsc0JBQXNCLGdCQUFnQjtBQUN0QyxDQUFDOztBQUVEO0FBQ0EscUJBQXFCLG9CQUFvQixFQUFFO0FBQzNDLHNCQUFzQixpQkFBaUI7QUFDdkMsQ0FBQzs7QUFFRDtBQUNBLHFCQUFxQiw0QkFBNEIsRUFBRTtBQUNuRCxzQkFBc0IseUJBQXlCO0FBQy9DLENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsNkJBQTZCLEVBQUU7QUFDcEQsc0JBQXNCLDBCQUEwQjtBQUNoRCxDQUFDOztBQUVEO0FBQ0EscUJBQXFCLDZCQUE2QixFQUFFO0FBQ3BELHNCQUFzQiwwQkFBMEI7QUFDaEQsQ0FBQzs7QUFFRDtBQUNBLHFCQUFxQixpQ0FBaUMsRUFBRTtBQUN4RCwwQkFBMEIsa0NBQWtDO0FBQzVELENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsc0JBQXNCLEVBQUU7QUFDN0Msc0JBQXNCLG1CQUFtQjtBQUN6QyxDQUFDOztBQUVEO0FBQ0EscUJBQXFCLHFCQUFxQixFQUFFO0FBQzVDLHNCQUFzQixrQkFBa0I7QUFDeEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDakJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUN4QkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaENBLGtCQUFrQixtRDs7Ozs7O0FDQWxCLGtCQUFrQixzL1ZBQXMvVixnSUFBZ0ksdXFTQUF1cVMsZ0lBQWdJLG80REFBbzRELHFwTTs7Ozs7OztBQ0FuenNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzFFQTtBQUNBLE9BQU8sUUFBUTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQzFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7O0FDdkx0QyxPQUFPLFlBQVk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOUJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWkE7OztBQUdBOzs7QUFHQTs7Ozs7Ozs7QUNOQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDZDQUE2QyxFQUFFO0FBQy9DO0FBQ0Esb0RBQW9ELEVBQUUsZUFBZSxFQUFFLFlBQVk7OztBQUduRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDLDBCQUEwQixVQUFVO0FBQ3BDLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxxQkFBcUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7O0FBRUEsK0NBQStDLGtCQUFrQjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxjQUFjLGVBQWU7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLEdBQUcseUJBQXlCO0FBQzVCLHNCQUFzQixJQUFJO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQSw0RUFBNEU7QUFDNUUsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSwrQ0FBK0M7QUFDdkQ7O0FBRUE7QUFDQSxVQUFVLCtDQUErQztBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1AsNERBQTRELHNCQUFzQjtBQUNsRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1QsbUVBQW1FOztBQUVuRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQSxPQUFPO0FBQ1AsOERBQThEOztBQUU5RCxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxLQUFLO0FBQ0wsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUSwrQ0FBK0M7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQSxHQUFHO0FBQ0g7O0FBRUEsR0FBRztBQUNIOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FLDBCQUEwQjtBQUM5Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSwrRUFBK0U7QUFDL0U7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMENBQTBDLDhCQUE4QjtBQUN4RSxHQUFHO0FBQ0gseUNBQXlDLDhCQUE4QjtBQUN2RTtBQUNBOzs7QUFHQTtBQUNBLG9DQUFvQyw4QkFBOEI7QUFDbEU7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdqREE7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7Ozs7OztBQzNFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRSxDQUFDOzs7Ozs7OztBQ1BEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFLENBQUM7Ozs7Ozs7O0FDUEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEUsQ0FBQzs7Ozs7Ozs7QUNQRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZLEtBQUs7QUFDN0MsNEJBQTRCLGVBQWUsRUFBRTtBQUM3Qyw0QkFBNEIsZUFBZSxFQUFFO0FBQzdDLDRCQUE0QixlQUFlO0FBQzNDLEdBQUc7QUFDSDtBQUNBLENBQUM7Ozs7Ozs7O0FDakNEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQ0FBa0MsRUFBRTtBQUN0RSxrQ0FBa0Msa0NBQWtDLEVBQUU7QUFDdEUsa0NBQWtDLGtDQUFrQztBQUNwRSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7Ozs7OztBQ2xDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLGFBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQ0FBa0MsRUFBRTtBQUN4RSxvQ0FBb0Msa0NBQWtDLEVBQUU7QUFDeEUsb0NBQW9DLG1DQUFtQyxFQUFFO0FBQ3pFLG9DQUFvQyxpREFBaUQ7QUFDckYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUMzS0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDbkhEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ3ZGRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7WUNYRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLFdBQVc7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDeklEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNXZEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7Ozs7QUNwQkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLFFBQVEsVUFBVTs7QUFFbEI7QUFDQTs7Ozs7OztBQ25GQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDM0NEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLGdCQUFnQjtBQUN6RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ3BERDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQzVCRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQzNCRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O1lDM0REOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxjQUFjOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQSwwQ0FBMEMsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ25GRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNwRiwwQkFBMEIsdURBQXVEO0FBQ2pGO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxxRUFBcUU7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxNQUFNO0FBQ047QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5QjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELDJCQUEyQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsMkJBQTJCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdCQUF3QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDZCQUE2QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkJBQTZCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsZUFBZTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsZUFBZTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxjQUFjO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG9FQUFvRTtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQyw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzREFBc0Q7QUFDeEY7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNEQUFzRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLCtCQUErQjtBQUMvQiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxNQUFNLElBQUksTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCLGlCQUFpQixFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNELEM7Ozs7Ozs7QUMzaU5BOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQyxLQUFLO0FBQzFDLHFDQUFxQztBQUNyQyxxQ0FBcUMsS0FBSzs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzREFBc0QsZ0JBQWdCO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixFQUFFO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLGdCQUFnQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyw4QkFBOEI7QUFDbEU7O0FBRUE7QUFDQTs7Ozs7OztBQ2x6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaERBLE9BQU8sWUFBWTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBLE9BQU8sWUFBWTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBLE9BQU8sWUFBWTtBQUNuQjtBQUNBO0FBQ0E7Ozs7Ozs7QUNIQSxPQUFPLFlBQVk7O0FBRW5CO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUIsWUFBWSxzQkFBc0I7QUFDbEMsZ0JBQWdCLDBCQUEwQjtBQUMxQyxVQUFVLG9CQUFvQjtBQUM5QixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNkQSxPQUFPLFlBQVk7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNUQSxPQUFPLFlBQVk7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7Ozs7OztBQ2ZBLE9BQU8sWUFBWTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4QkEsT0FBTyxZQUFZOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQ0EsT0FBTyxZQUFZOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQWdFLElBQUksUUFBUSxJQUFJO0FBQ2hGOztBQUVBLHNEQUFzRCxJQUFJOztBQUUxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJLE1BQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxHQUFHLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBLDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnREFBZ0QsV0FBVztBQUNoRTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx5QkFBeUI7QUFDOUI7QUFDQSxLQUFLLHlCQUF5QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDblZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUc7O0FBRTNFOztBQUVBOztBQUVBOztBQUVBLGdDQUFnQyxJQUFJOztBQUVwQyw2QkFBNkIsSUFBSTs7QUFFakMsc0JBQXNCLEdBQUcsV0FBVyxHQUFHOztBQUV2QyxnQ0FBZ0MsR0FBRyxHQUFHLEdBQUc7O0FBRXpDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVUsRUFBRTtBQUMxQyw4QkFBOEIsUUFBUSxFQUFFO0FBQ3hDLGlDQUFpQyx1QkFBdUIsRUFBRTtBQUMxRDtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QixVQUFVLEVBQUU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlDQUFpQyx1QkFBdUIsRUFBRTtBQUMxRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsOEJBQThCLFFBQVEsRUFBRTtBQUN4QyxpQ0FBaUMsdUJBQXVCLEVBQUU7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4QixRQUFRLEVBQUU7QUFDeEMsaUNBQWlDLHVCQUF1QixFQUFFO0FBQzFEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4QixRQUFRLEVBQUU7QUFDeEMsZ0NBQWdDLGNBQWMsRUFBRTtBQUNoRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4QkFBOEIsUUFBUSxFQUFFO0FBQ3hDLGdDQUFnQyxjQUFjLEVBQUU7QUFDaEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLFNBQVM7QUFDVCxnQ0FBZ0MsY0FBYyxFQUFFO0FBQ2hEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxTQUFTO0FBQ1QsZ0NBQWdDLGNBQWMsRUFBRTtBQUNoRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLGNBQWMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUssT0FBTzs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQ0FBb0M7QUFDaEUsNEJBQTRCLCtCQUErQjtBQUMzRCxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtDQUFrQztBQUM5RCw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0EsNEJBQTRCLG1DQUFtQztBQUMvRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDdjJCQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7O0FBRTVCOztBQUVBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDLE9BQU87QUFDdkM7O0FBRUE7QUFDQSxxQkFBcUIsRUFBRTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOzs7QUFHQTs7Ozs7Ozs7O0FDaEdBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxjQUFjOztBQUU1Qjs7QUFFQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLEVBQUU7QUFDdEM7QUFDQTs7QUFFQSwrQkFBK0IsT0FBTztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLDBCQUEwQjtBQUMxQjs7O0FBR0E7Ozs7Ozs7QUN6SEE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxFQUFFLElBQUk7QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSCxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQSxtRUFBbUUsUUFBUTtBQUMzRTs7QUFFQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDdkVBLGtCQUFrQix3dUM7Ozs7OztBQ0FsQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6QkEsa0JBQWtCLHlTOzs7Ozs7O0FDQWxCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUFtQzs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtREFBbUQsYUFBYSxFQUFFOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxREFBcUQsRUFBRSxnQ0FBZ0MsS0FBSyw2Q0FBNkMsS0FBSzs7QUFFOUksMkNBQTJDLEtBQUs7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsVUFBVSxPQUFPOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLLE9BQU87O0FBRVosNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBLHlCQUF5QixtQ0FBbUMsOENBQThDO0FBQzFHO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxxQ0FBcUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNwN0JBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7O0FDekNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsV0FBVyxPQUFPLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7Ozs7OztBQ2pEQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNqU0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLDJCQUEyQjs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJsYW1sLWJyb3dzZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgY2U0MmYwMDI2ZGFlOTE1MWVhMmUiLCIndXNlIHN0cmljdCc7XG5cbnZhciBZQU1MRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcblxudmFyIFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUyA9IFtcbiAgJ2tpbmQnLFxuICAncmVzb2x2ZScsXG4gICdjb25zdHJ1Y3QnLFxuICAnaW5zdGFuY2VPZicsXG4gICdwcmVkaWNhdGUnLFxuICAncmVwcmVzZW50JyxcbiAgJ2RlZmF1bHRTdHlsZScsXG4gICdzdHlsZUFsaWFzZXMnXG5dO1xuXG52YXIgWUFNTF9OT0RFX0tJTkRTID0gW1xuICAnc2NhbGFyJyxcbiAgJ3NlcXVlbmNlJyxcbiAgJ21hcHBpbmcnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVBbGlhc2VzKG1hcCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIG1hcFtzdHlsZV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0W1N0cmluZyhhbGlhcyldID0gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFR5cGUodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBvcHRpb24gXCInICsgbmFtZSArICdcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVE9ETzogQWRkIHRhZyBmb3JtYXQgY2hlY2suXG4gIHRoaXMudGFnICAgICAgICAgID0gdGFnO1xuICB0aGlzLmtpbmQgICAgICAgICA9IG9wdGlvbnNbJ2tpbmQnXSAgICAgICAgIHx8IG51bGw7XG4gIHRoaXMucmVzb2x2ZSAgICAgID0gb3B0aW9uc1sncmVzb2x2ZSddICAgICAgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgdGhpcy5jb25zdHJ1Y3QgICAgPSBvcHRpb25zWydjb25zdHJ1Y3QnXSAgICB8fCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YTsgfTtcbiAgdGhpcy5pbnN0YW5jZU9mICAgPSBvcHRpb25zWydpbnN0YW5jZU9mJ10gICB8fCBudWxsO1xuICB0aGlzLnByZWRpY2F0ZSAgICA9IG9wdGlvbnNbJ3ByZWRpY2F0ZSddICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50ICAgID0gb3B0aW9uc1sncmVwcmVzZW50J10gICAgfHwgbnVsbDtcbiAgdGhpcy5kZWZhdWx0U3R5bGUgPSBvcHRpb25zWydkZWZhdWx0U3R5bGUnXSB8fCBudWxsO1xuICB0aGlzLnN0eWxlQWxpYXNlcyA9IGNvbXBpbGVTdHlsZUFsaWFzZXMob3B0aW9uc1snc3R5bGVBbGlhc2VzJ10gfHwgbnVsbCk7XG5cbiAgaWYgKFlBTUxfTk9ERV9LSU5EUy5pbmRleE9mKHRoaXMua2luZCkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1Vua25vd24ga2luZCBcIicgKyB0aGlzLmtpbmQgKyAnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIgIC8vIFNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI3NDA0NjAyLzEzMzk2NTFcbm1vZHVsZS5leHBvcnRzLnJlbmFtZVRhZyA9IGZ1bmN0aW9uKGRvY3VtZW50LCBub2RlT3JTZWxlY3RvciwgbmV3VGFnTmFtZSwgY2xhc3NPclRydWUpIHtcbiAgICBsZXQgbm9kZSA9IG5vZGVPclNlbGVjdG9yO1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG5vZGVPclNlbGVjdG9yKTtcbiAgICBpZiAoIW5vZGUpIHJldHVybiBuZXcgRXJyb3IoJ05vIG5vZGUgZm91bmQnKTtcbiAgICBsZXQgY2xhc3NOYW1lID0gJyc7XG4gICAgaWYgKGNsYXNzT3JUcnVlICYmIGNsYXNzT3JUcnVlID09PSB0cnVlKSBjbGFzc05hbWUgPSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodHlwZW9mIGNsYXNzT3JUcnVlID09PSAnc3RyaW5nJykgY2xhc3NOYW1lID0gY2xhc3NPclRydWU7XG5cbiAgICBjb25zdCBuZXdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuZXdUYWdOYW1lKTtcbiAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSBuZXdOb2RlLmFwcGVuZENoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgZm9yIChsZXQgYXR0cmlidXRlIG9mIG5vZGUuYXR0cmlidXRlcykge1xuICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XG4gICAgfVxuICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsVGFnTmFtZScsIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSAnJykgbmV3Tm9kZS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBub2RlKTtcbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2hlbHBlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIGlzTm90aGluZyhzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICd1bmRlZmluZWQnKSB8fCAoc3ViamVjdCA9PT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JykgJiYgKHN1YmplY3QgIT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoc2VxdWVuY2UpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSByZXR1cm4gc2VxdWVuY2U7XG4gIGVsc2UgaWYgKGlzTm90aGluZyhzZXF1ZW5jZSkpIHJldHVybiBbXTtcblxuICByZXR1cm4gWyBzZXF1ZW5jZSBdO1xufVxuXG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIGNvdW50KSB7XG4gIHZhciByZXN1bHQgPSAnJywgY3ljbGU7XG5cbiAgZm9yIChjeWNsZSA9IDA7IGN5Y2xlIDwgY291bnQ7IGN5Y2xlICs9IDEpIHtcbiAgICByZXN1bHQgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyhudW1iZXIpIHtcbiAgcmV0dXJuIChudW1iZXIgPT09IDApICYmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IDEgLyBudW1iZXIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLmlzTm90aGluZyAgICAgID0gaXNOb3RoaW5nO1xubW9kdWxlLmV4cG9ydHMuaXNPYmplY3QgICAgICAgPSBpc09iamVjdDtcbm1vZHVsZS5leHBvcnRzLnRvQXJyYXkgICAgICAgID0gdG9BcnJheTtcbm1vZHVsZS5leHBvcnRzLnJlcGVhdCAgICAgICAgID0gcmVwZWF0O1xubW9kdWxlLmV4cG9ydHMuaXNOZWdhdGl2ZVplcm8gPSBpc05lZ2F0aXZlWmVybztcbm1vZHVsZS5leHBvcnRzLmV4dGVuZCAgICAgICAgID0gZXh0ZW5kO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9jb21tb24uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG52YXIgY29tbW9uICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgVHlwZSAgICAgICAgICA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSwgcmVzdWx0KSB7XG4gIHZhciBleGNsdWRlID0gW107XG5cbiAgc2NoZW1hLmluY2x1ZGUuZm9yRWFjaChmdW5jdGlvbiAoaW5jbHVkZWRTY2hlbWEpIHtcbiAgICByZXN1bHQgPSBjb21waWxlTGlzdChpbmNsdWRlZFNjaGVtYSwgbmFtZSwgcmVzdWx0KTtcbiAgfSk7XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZyAmJiBwcmV2aW91c1R5cGUua2luZCA9PT0gY3VycmVudFR5cGUua2luZCkge1xuICAgICAgICBleGNsdWRlLnB1c2gocHJldmlvdXNJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHQucHVzaChjdXJyZW50VHlwZSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiBleGNsdWRlLmluZGV4T2YoaW5kZXgpID09PSAtMTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzY2FsYXI6IHt9LFxuICAgICAgICBzZXF1ZW5jZToge30sXG4gICAgICAgIG1hcHBpbmc6IHt9LFxuICAgICAgICBmYWxsYmFjazoge31cbiAgICAgIH0sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIHJlc3VsdFt0eXBlLmtpbmRdW3R5cGUudGFnXSA9IHJlc3VsdFsnZmFsbGJhY2snXVt0eXBlLnRhZ10gPSB0eXBlO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIFNjaGVtYShkZWZpbml0aW9uKSB7XG4gIHRoaXMuaW5jbHVkZSAgPSBkZWZpbml0aW9uLmluY2x1ZGUgIHx8IFtdO1xuICB0aGlzLmltcGxpY2l0ID0gZGVmaW5pdGlvbi5pbXBsaWNpdCB8fCBbXTtcbiAgdGhpcy5leHBsaWNpdCA9IGRlZmluaXRpb24uZXhwbGljaXQgfHwgW107XG5cbiAgdGhpcy5pbXBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHR5cGUubG9hZEtpbmQgJiYgdHlwZS5sb2FkS2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdUaGVyZSBpcyBhIG5vbi1zY2FsYXIgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gSW1wbGljaXQgcmVzb2x2aW5nIG9mIHN1Y2ggdHlwZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuY29tcGlsZWRJbXBsaWNpdCA9IGNvbXBpbGVMaXN0KHRoaXMsICdpbXBsaWNpdCcsIFtdKTtcbiAgdGhpcy5jb21waWxlZEV4cGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2V4cGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkVHlwZU1hcCAgPSBjb21waWxlTWFwKHRoaXMuY29tcGlsZWRJbXBsaWNpdCwgdGhpcy5jb21waWxlZEV4cGxpY2l0KTtcbn1cblxuXG5TY2hlbWEuREVGQVVMVCA9IG51bGw7XG5cblxuU2NoZW1hLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYSgpIHtcbiAgdmFyIHNjaGVtYXMsIHR5cGVzO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHNjaGVtYXMgPSBTY2hlbWEuREVGQVVMVDtcbiAgICAgIHR5cGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBzY2hlbWFzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdHlwZXMgPSBhcmd1bWVudHNbMV07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgU2NoZW1hLmNyZWF0ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgc2NoZW1hcyA9IGNvbW1vbi50b0FycmF5KHNjaGVtYXMpO1xuICB0eXBlcyA9IGNvbW1vbi50b0FycmF5KHR5cGVzKTtcblxuICBpZiAoIXNjaGVtYXMuZXZlcnkoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hOyB9KSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBzdXBlciBzY2hlbWFzIChvciBhIHNpbmdsZSBTY2hlbWEgb2JqZWN0KSBjb250YWlucyBhIG5vbi1TY2hlbWEgb2JqZWN0LicpO1xuICB9XG5cbiAgaWYgKCF0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFR5cGU7IH0pKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICBpbmNsdWRlOiBzY2hlbWFzLFxuICAgIGV4cGxpY2l0OiB0eXBlc1xuICB9KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVuY29kZSA9IHJlcXVpcmUoJ21kdXJsL2VuY29kZScpO1xudmFyIGRlY29kZSA9IHJlcXVpcmUoJ21kdXJsL2RlY29kZScpO1xuXG52YXIgQ19CQUNLU0xBU0ggPSA5MjtcblxudmFyIGRlY29kZUhUTUwgPSByZXF1aXJlKCdlbnRpdGllcycpLmRlY29kZUhUTUw7XG5cbnZhciBFTlRJVFkgPSBcIiYoPzojeFthLWYwLTldezEsOH18I1swLTldezEsOH18W2Etel1bYS16MC05XXsxLDMxfSk7XCI7XG5cbnZhciBUQUdOQU1FID0gJ1tBLVphLXpdW0EtWmEtejAtOS1dKic7XG52YXIgQVRUUklCVVRFTkFNRSA9ICdbYS16QS1aXzpdW2EtekEtWjAtOTouXy1dKic7XG52YXIgVU5RVU9URURWQUxVRSA9IFwiW15cXFwiJz08PmBcXFxceDAwLVxcXFx4MjBdK1wiO1xudmFyIFNJTkdMRVFVT1RFRFZBTFVFID0gXCInW14nXSonXCI7XG52YXIgRE9VQkxFUVVPVEVEVkFMVUUgPSAnXCJbXlwiXSpcIic7XG52YXIgQVRUUklCVVRFVkFMVUUgPSBcIig/OlwiICsgVU5RVU9URURWQUxVRSArIFwifFwiICsgU0lOR0xFUVVPVEVEVkFMVUUgKyBcInxcIiArIERPVUJMRVFVT1RFRFZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFVkFMVUVTUEVDID0gXCIoPzpcIiArIFwiXFxcXHMqPVwiICsgXCJcXFxccypcIiArIEFUVFJJQlVURVZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFID0gXCIoPzpcIiArIFwiXFxcXHMrXCIgKyBBVFRSSUJVVEVOQU1FICsgQVRUUklCVVRFVkFMVUVTUEVDICsgXCI/KVwiO1xudmFyIE9QRU5UQUcgPSBcIjxcIiArIFRBR05BTUUgKyBBVFRSSUJVVEUgKyBcIipcIiArIFwiXFxcXHMqLz8+XCI7XG52YXIgQ0xPU0VUQUcgPSBcIjwvXCIgKyBUQUdOQU1FICsgXCJcXFxccypbPl1cIjtcbnZhciBIVE1MQ09NTUVOVCA9IFwiPCEtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPlwiO1xudmFyIFBST0NFU1NJTkdJTlNUUlVDVElPTiA9IFwiWzxdWz9dLio/Wz9dWz5dXCI7XG52YXIgREVDTEFSQVRJT04gPSBcIjwhW0EtWl0rXCIgKyBcIlxcXFxzK1tePl0qPlwiO1xudmFyIENEQVRBID0gXCI8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT5cIjtcbnZhciBIVE1MVEFHID0gXCIoPzpcIiArIE9QRU5UQUcgKyBcInxcIiArIENMT1NFVEFHICsgXCJ8XCIgKyBIVE1MQ09NTUVOVCArIFwifFwiICtcbiAgICAgICAgUFJPQ0VTU0lOR0lOU1RSVUNUSU9OICsgXCJ8XCIgKyBERUNMQVJBVElPTiArIFwifFwiICsgQ0RBVEEgKyBcIilcIjtcbnZhciByZUh0bWxUYWcgPSBuZXcgUmVnRXhwKCdeJyArIEhUTUxUQUcsICdpJyk7XG5cbnZhciByZUJhY2tzbGFzaE9yQW1wID0gL1tcXFxcJl0vO1xuXG52YXIgRVNDQVBBQkxFID0gJ1shXCIjJCUmXFwnKCkqKywuLzo7PD0+P0BbXFxcXFxcXFxcXFxcXV5fYHt8fX4tXSc7XG5cbnZhciByZUVudGl0eU9yRXNjYXBlZENoYXIgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXCcgKyBFU0NBUEFCTEUgKyAnfCcgKyBFTlRJVFksICdnaScpO1xuXG52YXIgWE1MU1BFQ0lBTCA9ICdbJjw+XCJdJztcblxudmFyIHJlWG1sU3BlY2lhbCA9IG5ldyBSZWdFeHAoWE1MU1BFQ0lBTCwgJ2cnKTtcblxudmFyIHJlWG1sU3BlY2lhbE9yRW50aXR5ID0gbmV3IFJlZ0V4cChFTlRJVFkgKyAnfCcgKyBYTUxTUEVDSUFMLCAnZ2knKTtcblxudmFyIHVuZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKHMpIHtcbiAgICBpZiAocy5jaGFyQ29kZUF0KDApID09PSBDX0JBQ0tTTEFTSCkge1xuICAgICAgICByZXR1cm4gcy5jaGFyQXQoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZUhUTUwocyk7XG4gICAgfVxufTtcblxuLy8gUmVwbGFjZSBlbnRpdGllcyBhbmQgYmFja3NsYXNoIGVzY2FwZXMgd2l0aCBsaXRlcmFsIGNoYXJhY3RlcnMuXG52YXIgdW5lc2NhcGVTdHJpbmcgPSBmdW5jdGlvbihzKSB7XG4gICAgaWYgKHJlQmFja3NsYXNoT3JBbXAudGVzdChzKSkge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKHJlRW50aXR5T3JFc2NhcGVkQ2hhciwgdW5lc2NhcGVDaGFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG59O1xuXG52YXIgbm9ybWFsaXplVVJJID0gZnVuY3Rpb24odXJpKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGVuY29kZShkZWNvZGUodXJpKSk7XG4gICAgfVxuICAgIGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH1cbn07XG5cbnZhciByZXBsYWNlVW5zYWZlQ2hhciA9IGZ1bmN0aW9uKHMpIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlICcmJzpcbiAgICAgICAgcmV0dXJuICcmYW1wOyc7XG4gICAgY2FzZSAnPCc6XG4gICAgICAgIHJldHVybiAnJmx0Oyc7XG4gICAgY2FzZSAnPic6XG4gICAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgY2FzZSAnXCInOlxuICAgICAgICByZXR1cm4gJyZxdW90Oyc7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxufTtcblxudmFyIGVzY2FwZVhtbCA9IGZ1bmN0aW9uKHMsIHByZXNlcnZlX2VudGl0aWVzKSB7XG4gICAgaWYgKHJlWG1sU3BlY2lhbC50ZXN0KHMpKSB7XG4gICAgICAgIGlmIChwcmVzZXJ2ZV9lbnRpdGllcykge1xuICAgICAgICAgICAgcmV0dXJuIHMucmVwbGFjZShyZVhtbFNwZWNpYWxPckVudGl0eSwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHMucmVwbGFjZShyZVhtbFNwZWNpYWwsIHJlcGxhY2VVbnNhZmVDaGFyKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyB1bmVzY2FwZVN0cmluZzogdW5lc2NhcGVTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgbm9ybWFsaXplVVJJOiBub3JtYWxpemVVUkksXG4gICAgICAgICAgICAgICAgICAgZXNjYXBlWG1sOiBlc2NhcGVYbWwsXG4gICAgICAgICAgICAgICAgICAgcmVIdG1sVGFnOiByZUh0bWxUYWcsXG4gICAgICAgICAgICAgICAgICAgT1BFTlRBRzogT1BFTlRBRyxcbiAgICAgICAgICAgICAgICAgICBDTE9TRVRBRzogQ0xPU0VUQUcsXG4gICAgICAgICAgICAgICAgICAgRU5USVRZOiBFTlRJVFksXG4gICAgICAgICAgICAgICAgICAgRVNDQVBBQkxFOiBFU0NBUEFCTEVcbiAgICAgICAgICAgICAgICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvbW1vbm1hcmsvbGliL2NvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBZQU1MIGVycm9yIGNsYXNzLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0NTg5ODRcbi8vXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFlBTUxFeGNlcHRpb24ocmVhc29uLCBtYXJrKSB7XG4gIC8vIFN1cGVyIGNvbnN0cnVjdG9yXG4gIEVycm9yLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5uYW1lID0gJ1lBTUxFeGNlcHRpb24nO1xuICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgdGhpcy5tYXJrID0gbWFyaztcbiAgdGhpcy5tZXNzYWdlID0gKHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJykgKyAodGhpcy5tYXJrID8gJyAnICsgdGhpcy5tYXJrLnRvU3RyaW5nKCkgOiAnJyk7XG5cbiAgLy8gSW5jbHVkZSBzdGFjayB0cmFjZSBpbiBlcnJvciBvYmplY3RcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBOb2RlSlNcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGRiwgSUUgMTArIGFuZCBTYWZhcmkgNisuIEZhbGxiYWNrIGZvciBvdGhlcnNcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjayB8fCAnJztcbiAgfVxufVxuXG5cbi8vIEluaGVyaXQgZnJvbSBFcnJvclxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFlBTUxFeGNlcHRpb247XG5cblxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLm5hbWUgKyAnOiAnO1xuXG4gIHJlc3VsdCArPSB0aGlzLnJlYXNvbiB8fCAnKHVua25vd24gcmVhc29uKSc7XG5cbiAgaWYgKCFjb21wYWN0ICYmIHRoaXMubWFyaykge1xuICAgIHJlc3VsdCArPSAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gWUFNTEV4Y2VwdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZXhjZXB0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYHNhZmVMb2FkYCBmdW5jdGlvbi5cbi8vIEl0IGlzIG5vdCBkZXNjcmliZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vXG4vLyBUaGlzIHNjaGVtYSBpcyBiYXNlZCBvbiBzdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEgYW5kIGluY2x1ZGVzIG1vc3Qgb2Zcbi8vIGV4dHJhIHR5cGVzIGRlc2NyaWJlZCBhdCBZQU1MIHRhZyByZXBvc2l0b3J5LiAoaHR0cDovL3lhbWwub3JnL3R5cGUvKVxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vY29yZScpXG4gIF0sXG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS90aW1lc3RhbXAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL21lcmdlJylcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL2JpbmFyeScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvb21hcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvcGFpcnMnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NldCcpXG4gIF1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYGxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIEpTLVlBTUwncyBkZWZhdWx0IHNhZmUgc2NoZW1hIGFuZCBpbmNsdWRlc1xuLy8gSmF2YVNjcmlwdC1zcGVjaWZpYyB0eXBlczogISFqcy91bmRlZmluZWQsICEhanMvcmVnZXhwIGFuZCAhIWpzL2Z1bmN0aW9uLlxuLy9cbi8vIEFsc28gdGhpcyBzY2hlbWEgaXMgdXNlZCBhcyBkZWZhdWx0IGJhc2Ugc2NoZW1hIGF0IGBTY2hlbWEuY3JlYXRlYCBmdW5jdGlvbi5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hLkRFRkFVTFQgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vZGVmYXVsdF9zYWZlJylcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL3VuZGVmaW5lZCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvcmVnZXhwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9mdW5jdGlvbicpXG4gIF1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFN0YW5kYXJkIFlBTUwncyBGYWlsc2FmZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDIzNDZcblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zdHInKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NlcScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWFwJylcbiAgXVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gaXNDb250YWluZXIobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS5fdHlwZSkge1xuICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICBjYXNlICdibG9ja19xdW90ZSc6XG4gICAgY2FzZSAnbGlzdCc6XG4gICAgY2FzZSAnaXRlbSc6XG4gICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICBjYXNlICdoZWFkaW5nJzpcbiAgICBjYXNlICdlbXBoJzpcbiAgICBjYXNlICdzdHJvbmcnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICBjYXNlICdjdXN0b21faW5saW5lJzpcbiAgICBjYXNlICdjdXN0b21fYmxvY2snOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG52YXIgcmVzdW1lQXQgPSBmdW5jdGlvbihub2RlLCBlbnRlcmluZykge1xuICAgIHRoaXMuY3VycmVudCA9IG5vZGU7XG4gICAgdGhpcy5lbnRlcmluZyA9IChlbnRlcmluZyA9PT0gdHJ1ZSk7XG59O1xuXG52YXIgbmV4dCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudDtcbiAgICB2YXIgZW50ZXJpbmcgPSB0aGlzLmVudGVyaW5nO1xuXG4gICAgaWYgKGN1ciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gaXNDb250YWluZXIoY3VyKTtcblxuICAgIGlmIChlbnRlcmluZyAmJiBjb250YWluZXIpIHtcbiAgICAgICAgaWYgKGN1ci5fZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLl9maXJzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdGF5IG9uIG5vZGUgYnV0IGV4aXRcbiAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjdXIgPT09IHRoaXMucm9vdCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgfSBlbHNlIGlmIChjdXIuX25leHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLl9wYXJlbnQ7XG4gICAgICAgIHRoaXMuZW50ZXJpbmcgPSBmYWxzZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5fbmV4dDtcbiAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtlbnRlcmluZzogZW50ZXJpbmcsIG5vZGU6IGN1cn07XG59O1xuXG52YXIgTm9kZVdhbGtlciA9IGZ1bmN0aW9uKHJvb3QpIHtcbiAgICByZXR1cm4geyBjdXJyZW50OiByb290LFxuICAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgICAgZW50ZXJpbmc6IHRydWUsXG4gICAgICAgICAgICAgbmV4dDogbmV4dCxcbiAgICAgICAgICAgICByZXN1bWVBdDogcmVzdW1lQXQgfTtcbn07XG5cbnZhciBOb2RlID0gZnVuY3Rpb24obm9kZVR5cGUsIHNvdXJjZXBvcykge1xuICAgIHRoaXMuX3R5cGUgPSBub2RlVHlwZTtcbiAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuX2ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RDaGlsZCA9IG51bGw7XG4gICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgdGhpcy5fc291cmNlcG9zID0gc291cmNlcG9zO1xuICAgIHRoaXMuX2xhc3RMaW5lQmxhbmsgPSBmYWxzZTtcbiAgICB0aGlzLl9vcGVuID0gdHJ1ZTtcbiAgICB0aGlzLl9zdHJpbmdfY29udGVudCA9IG51bGw7XG4gICAgdGhpcy5fbGl0ZXJhbCA9IG51bGw7XG4gICAgdGhpcy5fbGlzdERhdGEgPSB7fTtcbiAgICB0aGlzLl9pbmZvID0gbnVsbDtcbiAgICB0aGlzLl9kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgdGhpcy5fdGl0bGUgPSBudWxsO1xuICAgIHRoaXMuX2lzRmVuY2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZmVuY2VDaGFyID0gbnVsbDtcbiAgICB0aGlzLl9mZW5jZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZmVuY2VPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMuX2xldmVsID0gbnVsbDtcbiAgICB0aGlzLl9vbkVudGVyID0gbnVsbDtcbiAgICB0aGlzLl9vbkV4aXQgPSBudWxsO1xufTtcblxudmFyIHByb3RvID0gTm9kZS5wcm90b3R5cGU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2lzQ29udGFpbmVyJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNDb250YWluZXIodGhpcyk7IH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICd0eXBlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl90eXBlOyB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnZmlyc3RDaGlsZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZmlyc3RDaGlsZDsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2xhc3RDaGlsZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbGFzdENoaWxkOyB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnbmV4dCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbmV4dDsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ3ByZXYnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3ByZXY7IH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdwYXJlbnQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3BhcmVudDsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ3NvdXJjZXBvcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc291cmNlcG9zOyB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnbGl0ZXJhbCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbGl0ZXJhbDsgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHMpIHsgdGhpcy5fbGl0ZXJhbCA9IHM7IH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdkZXN0aW5hdGlvbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZGVzdGluYXRpb247IH0sXG4gICAgc2V0OiBmdW5jdGlvbihzKSB7IHRoaXMuX2Rlc3RpbmF0aW9uID0gczsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ3RpdGxlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl90aXRsZTsgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHMpIHsgdGhpcy5fdGl0bGUgPSBzOyB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnaW5mbycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5faW5mbzsgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHMpIHsgdGhpcy5faW5mbyA9IHM7IH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdsZXZlbCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbGV2ZWw7IH0sXG4gICAgc2V0OiBmdW5jdGlvbihzKSB7IHRoaXMuX2xldmVsID0gczsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2xpc3RUeXBlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9saXN0RGF0YS50eXBlOyB9LFxuICAgIHNldDogZnVuY3Rpb24odCkgeyB0aGlzLl9saXN0RGF0YS50eXBlID0gdDsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2xpc3RUaWdodCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbGlzdERhdGEudGlnaHQ7IH0sXG4gICAgc2V0OiBmdW5jdGlvbih0KSB7IHRoaXMuX2xpc3REYXRhLnRpZ2h0ID0gdDsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2xpc3RTdGFydCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbGlzdERhdGEuc3RhcnQ7IH0sXG4gICAgc2V0OiBmdW5jdGlvbihuKSB7IHRoaXMuX2xpc3REYXRhLnN0YXJ0ID0gbjsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2xpc3REZWxpbWl0ZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2xpc3REYXRhLmRlbGltaXRlcjsgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGRlbGltKSB7IHRoaXMuX2xpc3REYXRhLmRlbGltaXRlciA9IGRlbGltOyB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnb25FbnRlcicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fb25FbnRlcjsgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHMpIHsgdGhpcy5fb25FbnRlciA9IHM7IH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbkV4aXQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX29uRXhpdDsgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHMpIHsgdGhpcy5fb25FeGl0ID0gczsgfVxufSk7XG5cbk5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICBjaGlsZC51bmxpbmsoKTtcbiAgICBjaGlsZC5fcGFyZW50ID0gdGhpcztcbiAgICBpZiAodGhpcy5fbGFzdENoaWxkKSB7XG4gICAgICAgIHRoaXMuX2xhc3RDaGlsZC5fbmV4dCA9IGNoaWxkO1xuICAgICAgICBjaGlsZC5fcHJldiA9IHRoaXMuX2xhc3RDaGlsZDtcbiAgICAgICAgdGhpcy5fbGFzdENoaWxkID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICB0aGlzLl9sYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICB9XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5wcmVwZW5kQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgIGNoaWxkLnVubGluaygpO1xuICAgIGNoaWxkLl9wYXJlbnQgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9maXJzdENoaWxkKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0Q2hpbGQuX3ByZXYgPSBjaGlsZDtcbiAgICAgICAgY2hpbGQuX25leHQgPSB0aGlzLl9maXJzdENoaWxkO1xuICAgICAgICB0aGlzLl9maXJzdENoaWxkID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICB0aGlzLl9sYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICB9XG59O1xuXG5Ob2RlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcHJldikge1xuICAgICAgICB0aGlzLl9wcmV2Ll9uZXh0ID0gdGhpcy5fbmV4dDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICB0aGlzLl9wYXJlbnQuX2ZpcnN0Q2hpbGQgPSB0aGlzLl9uZXh0O1xuICAgIH1cbiAgICBpZiAodGhpcy5fbmV4dCkge1xuICAgICAgICB0aGlzLl9uZXh0Ll9wcmV2ID0gdGhpcy5fcHJldjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICB0aGlzLl9wYXJlbnQuX2xhc3RDaGlsZCA9IHRoaXMuX3ByZXY7XG4gICAgfVxuICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgdGhpcy5fcHJldiA9IG51bGw7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uKHNpYmxpbmcpIHtcbiAgICBzaWJsaW5nLnVubGluaygpO1xuICAgIHNpYmxpbmcuX25leHQgPSB0aGlzLl9uZXh0O1xuICAgIGlmIChzaWJsaW5nLl9uZXh0KSB7XG4gICAgICAgIHNpYmxpbmcuX25leHQuX3ByZXYgPSBzaWJsaW5nO1xuICAgIH1cbiAgICBzaWJsaW5nLl9wcmV2ID0gdGhpcztcbiAgICB0aGlzLl9uZXh0ID0gc2libGluZztcbiAgICBzaWJsaW5nLl9wYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgaWYgKCFzaWJsaW5nLl9uZXh0KSB7XG4gICAgICAgIHNpYmxpbmcuX3BhcmVudC5fbGFzdENoaWxkID0gc2libGluZztcbiAgICB9XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbihzaWJsaW5nKSB7XG4gICAgc2libGluZy51bmxpbmsoKTtcbiAgICBzaWJsaW5nLl9wcmV2ID0gdGhpcy5fcHJldjtcbiAgICBpZiAoc2libGluZy5fcHJldikge1xuICAgICAgICBzaWJsaW5nLl9wcmV2Ll9uZXh0ID0gc2libGluZztcbiAgICB9XG4gICAgc2libGluZy5fbmV4dCA9IHRoaXM7XG4gICAgdGhpcy5fcHJldiA9IHNpYmxpbmc7XG4gICAgc2libGluZy5fcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgIGlmICghc2libGluZy5fcHJldikge1xuICAgICAgICBzaWJsaW5nLl9wYXJlbnQuX2ZpcnN0Q2hpbGQgPSBzaWJsaW5nO1xuICAgIH1cbn07XG5cbk5vZGUucHJvdG90eXBlLndhbGtlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3YWxrZXIgPSBuZXcgTm9kZVdhbGtlcih0aGlzKTtcbiAgICByZXR1cm4gd2Fsa2VyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuXG5cbi8qIEV4YW1wbGUgb2YgdXNlIG9mIHdhbGtlcjpcblxuIHZhciB3YWxrZXIgPSB3LndhbGtlcigpO1xuIHZhciBldmVudDtcblxuIHdoaWxlIChldmVudCA9IHdhbGtlci5uZXh0KCkpIHtcbiBjb25zb2xlLmxvZyhldmVudC5lbnRlcmluZywgZXZlbnQubm9kZS50eXBlKTtcbiB9XG5cbiAqL1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29tbW9ubWFyay9saWIvbm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBTdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDQ5MjNcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCBDb3JlIHNjaGVtYSBoYXMgbm8gZGlzdGluY3Rpb25zIGZyb20gSlNPTiBzY2hlbWEgaXMgSlMtWUFNTC5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2pzb24nKVxuICBdXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFN0YW5kYXJkIFlBTUwncyBKU09OIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMzIzMVxuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIHRoaXMgc2NoZW1hIGlzIG5vdCBzdWNoIHN0cmljdCBhcyBkZWZpbmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vLyBJdCBhbGxvd3MgbnVtYmVycyBpbiBiaW5hcnkgbm90YWlvbiwgdXNlIGBOdWxsYCBhbmQgYE5VTExgIGFzIGBudWxsYCwgZXRjLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vZmFpbHNhZmUnKVxuICBdLFxuICBpbXBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvbnVsbCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvYm9vbCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvaW50JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9mbG9hdCcpXG4gIF1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVuY29kZSA9IHJlcXVpcmUoXCIuL2xpYi9lbmNvZGUuanNcIiksXG4gICAgZGVjb2RlID0gcmVxdWlyZShcIi4vbGliL2RlY29kZS5qc1wiKTtcblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihkYXRhLCBsZXZlbCl7XG5cdHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBkZWNvZGUuWE1MIDogZGVjb2RlLkhUTUwpKGRhdGEpO1xufTtcblxuZXhwb3J0cy5kZWNvZGVTdHJpY3QgPSBmdW5jdGlvbihkYXRhLCBsZXZlbCl7XG5cdHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBkZWNvZGUuWE1MIDogZGVjb2RlLkhUTUxTdHJpY3QpKGRhdGEpO1xufTtcblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihkYXRhLCBsZXZlbCl7XG5cdHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBlbmNvZGUuWE1MIDogZW5jb2RlLkhUTUwpKGRhdGEpO1xufTtcblxuZXhwb3J0cy5lbmNvZGVYTUwgPSBlbmNvZGUuWE1MO1xuXG5leHBvcnRzLmVuY29kZUhUTUw0ID1cbmV4cG9ydHMuZW5jb2RlSFRNTDUgPVxuZXhwb3J0cy5lbmNvZGVIVE1MICA9IGVuY29kZS5IVE1MO1xuXG5leHBvcnRzLmRlY29kZVhNTCA9XG5leHBvcnRzLmRlY29kZVhNTFN0cmljdCA9IGRlY29kZS5YTUw7XG5cbmV4cG9ydHMuZGVjb2RlSFRNTDQgPVxuZXhwb3J0cy5kZWNvZGVIVE1MNSA9XG5leHBvcnRzLmRlY29kZUhUTUwgPSBkZWNvZGUuSFRNTDtcblxuZXhwb3J0cy5kZWNvZGVIVE1MNFN0cmljdCA9XG5leHBvcnRzLmRlY29kZUhUTUw1U3RyaWN0ID1cbmV4cG9ydHMuZGVjb2RlSFRNTFN0cmljdCA9IGRlY29kZS5IVE1MU3RyaWN0O1xuXG5leHBvcnRzLmVzY2FwZSA9IGVuY29kZS5lc2NhcGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbnRpdGllcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJhbXBcIjpcIiZcIixcImFwb3NcIjpcIidcIixcImd0XCI6XCI+XCIsXCJsdFwiOlwiPFwiLFwicXVvdFwiOlwiXFxcIlwifVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2VudGl0aWVzL21hcHMveG1sLmpzb25cbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1wiQWFjdXRlXCI6XCLDgVwiLFwiYWFjdXRlXCI6XCLDoVwiLFwiQWJyZXZlXCI6XCLEglwiLFwiYWJyZXZlXCI6XCLEg1wiLFwiYWNcIjpcIuKIvlwiLFwiYWNkXCI6XCLiiL9cIixcImFjRVwiOlwi4oi+zLNcIixcIkFjaXJjXCI6XCLDglwiLFwiYWNpcmNcIjpcIsOiXCIsXCJhY3V0ZVwiOlwiwrRcIixcIkFjeVwiOlwi0JBcIixcImFjeVwiOlwi0LBcIixcIkFFbGlnXCI6XCLDhlwiLFwiYWVsaWdcIjpcIsOmXCIsXCJhZlwiOlwi4oGhXCIsXCJBZnJcIjpcIvCdlIRcIixcImFmclwiOlwi8J2UnlwiLFwiQWdyYXZlXCI6XCLDgFwiLFwiYWdyYXZlXCI6XCLDoFwiLFwiYWxlZnN5bVwiOlwi4oS1XCIsXCJhbGVwaFwiOlwi4oS1XCIsXCJBbHBoYVwiOlwizpFcIixcImFscGhhXCI6XCLOsVwiLFwiQW1hY3JcIjpcIsSAXCIsXCJhbWFjclwiOlwixIFcIixcImFtYWxnXCI6XCLiqL9cIixcImFtcFwiOlwiJlwiLFwiQU1QXCI6XCImXCIsXCJhbmRhbmRcIjpcIuKplVwiLFwiQW5kXCI6XCLiqZNcIixcImFuZFwiOlwi4oinXCIsXCJhbmRkXCI6XCLiqZxcIixcImFuZHNsb3BlXCI6XCLiqZhcIixcImFuZHZcIjpcIuKpmlwiLFwiYW5nXCI6XCLiiKBcIixcImFuZ2VcIjpcIuKmpFwiLFwiYW5nbGVcIjpcIuKIoFwiLFwiYW5nbXNkYWFcIjpcIuKmqFwiLFwiYW5nbXNkYWJcIjpcIuKmqVwiLFwiYW5nbXNkYWNcIjpcIuKmqlwiLFwiYW5nbXNkYWRcIjpcIuKmq1wiLFwiYW5nbXNkYWVcIjpcIuKmrFwiLFwiYW5nbXNkYWZcIjpcIuKmrVwiLFwiYW5nbXNkYWdcIjpcIuKmrlwiLFwiYW5nbXNkYWhcIjpcIuKmr1wiLFwiYW5nbXNkXCI6XCLiiKFcIixcImFuZ3J0XCI6XCLiiJ9cIixcImFuZ3J0dmJcIjpcIuKKvlwiLFwiYW5ncnR2YmRcIjpcIuKmnVwiLFwiYW5nc3BoXCI6XCLiiKJcIixcImFuZ3N0XCI6XCLDhVwiLFwiYW5nemFyclwiOlwi4o28XCIsXCJBb2dvblwiOlwixIRcIixcImFvZ29uXCI6XCLEhVwiLFwiQW9wZlwiOlwi8J2UuFwiLFwiYW9wZlwiOlwi8J2VklwiLFwiYXBhY2lyXCI6XCLiqa9cIixcImFwXCI6XCLiiYhcIixcImFwRVwiOlwi4qmwXCIsXCJhcGVcIjpcIuKJilwiLFwiYXBpZFwiOlwi4omLXCIsXCJhcG9zXCI6XCInXCIsXCJBcHBseUZ1bmN0aW9uXCI6XCLigaFcIixcImFwcHJveFwiOlwi4omIXCIsXCJhcHByb3hlcVwiOlwi4omKXCIsXCJBcmluZ1wiOlwiw4VcIixcImFyaW5nXCI6XCLDpVwiLFwiQXNjclwiOlwi8J2SnFwiLFwiYXNjclwiOlwi8J2StlwiLFwiQXNzaWduXCI6XCLiiZRcIixcImFzdFwiOlwiKlwiLFwiYXN5bXBcIjpcIuKJiFwiLFwiYXN5bXBlcVwiOlwi4omNXCIsXCJBdGlsZGVcIjpcIsODXCIsXCJhdGlsZGVcIjpcIsOjXCIsXCJBdW1sXCI6XCLDhFwiLFwiYXVtbFwiOlwiw6RcIixcImF3Y29uaW50XCI6XCLiiLNcIixcImF3aW50XCI6XCLiqJFcIixcImJhY2tjb25nXCI6XCLiiYxcIixcImJhY2tlcHNpbG9uXCI6XCLPtlwiLFwiYmFja3ByaW1lXCI6XCLigLVcIixcImJhY2tzaW1cIjpcIuKIvVwiLFwiYmFja3NpbWVxXCI6XCLii41cIixcIkJhY2tzbGFzaFwiOlwi4oiWXCIsXCJCYXJ2XCI6XCLiq6dcIixcImJhcnZlZVwiOlwi4oq9XCIsXCJiYXJ3ZWRcIjpcIuKMhVwiLFwiQmFyd2VkXCI6XCLijIZcIixcImJhcndlZGdlXCI6XCLijIVcIixcImJicmtcIjpcIuKOtVwiLFwiYmJya3RicmtcIjpcIuKOtlwiLFwiYmNvbmdcIjpcIuKJjFwiLFwiQmN5XCI6XCLQkVwiLFwiYmN5XCI6XCLQsVwiLFwiYmRxdW9cIjpcIuKAnlwiLFwiYmVjYXVzXCI6XCLiiLVcIixcImJlY2F1c2VcIjpcIuKItVwiLFwiQmVjYXVzZVwiOlwi4oi1XCIsXCJiZW1wdHl2XCI6XCLiprBcIixcImJlcHNpXCI6XCLPtlwiLFwiYmVybm91XCI6XCLihKxcIixcIkJlcm5vdWxsaXNcIjpcIuKErFwiLFwiQmV0YVwiOlwizpJcIixcImJldGFcIjpcIs6yXCIsXCJiZXRoXCI6XCLihLZcIixcImJldHdlZW5cIjpcIuKJrFwiLFwiQmZyXCI6XCLwnZSFXCIsXCJiZnJcIjpcIvCdlJ9cIixcImJpZ2NhcFwiOlwi4ouCXCIsXCJiaWdjaXJjXCI6XCLil69cIixcImJpZ2N1cFwiOlwi4ouDXCIsXCJiaWdvZG90XCI6XCLiqIBcIixcImJpZ29wbHVzXCI6XCLiqIFcIixcImJpZ290aW1lc1wiOlwi4qiCXCIsXCJiaWdzcWN1cFwiOlwi4qiGXCIsXCJiaWdzdGFyXCI6XCLimIVcIixcImJpZ3RyaWFuZ2xlZG93blwiOlwi4pa9XCIsXCJiaWd0cmlhbmdsZXVwXCI6XCLilrNcIixcImJpZ3VwbHVzXCI6XCLiqIRcIixcImJpZ3ZlZVwiOlwi4ouBXCIsXCJiaWd3ZWRnZVwiOlwi4ouAXCIsXCJia2Fyb3dcIjpcIuKkjVwiLFwiYmxhY2tsb3plbmdlXCI6XCLip6tcIixcImJsYWNrc3F1YXJlXCI6XCLilqpcIixcImJsYWNrdHJpYW5nbGVcIjpcIuKWtFwiLFwiYmxhY2t0cmlhbmdsZWRvd25cIjpcIuKWvlwiLFwiYmxhY2t0cmlhbmdsZWxlZnRcIjpcIuKXglwiLFwiYmxhY2t0cmlhbmdsZXJpZ2h0XCI6XCLilrhcIixcImJsYW5rXCI6XCLikKNcIixcImJsazEyXCI6XCLilpJcIixcImJsazE0XCI6XCLilpFcIixcImJsazM0XCI6XCLilpNcIixcImJsb2NrXCI6XCLilohcIixcImJuZVwiOlwiPeKDpVwiLFwiYm5lcXVpdlwiOlwi4omh4oOlXCIsXCJiTm90XCI6XCLiq61cIixcImJub3RcIjpcIuKMkFwiLFwiQm9wZlwiOlwi8J2UuVwiLFwiYm9wZlwiOlwi8J2Vk1wiLFwiYm90XCI6XCLiiqVcIixcImJvdHRvbVwiOlwi4oqlXCIsXCJib3d0aWVcIjpcIuKLiFwiLFwiYm94Ym94XCI6XCLip4lcIixcImJveGRsXCI6XCLilJBcIixcImJveGRMXCI6XCLilZVcIixcImJveERsXCI6XCLilZZcIixcImJveERMXCI6XCLilZdcIixcImJveGRyXCI6XCLilIxcIixcImJveGRSXCI6XCLilZJcIixcImJveERyXCI6XCLilZNcIixcImJveERSXCI6XCLilZRcIixcImJveGhcIjpcIuKUgFwiLFwiYm94SFwiOlwi4pWQXCIsXCJib3hoZFwiOlwi4pSsXCIsXCJib3hIZFwiOlwi4pWkXCIsXCJib3hoRFwiOlwi4pWlXCIsXCJib3hIRFwiOlwi4pWmXCIsXCJib3hodVwiOlwi4pS0XCIsXCJib3hIdVwiOlwi4pWnXCIsXCJib3hoVVwiOlwi4pWoXCIsXCJib3hIVVwiOlwi4pWpXCIsXCJib3htaW51c1wiOlwi4oqfXCIsXCJib3hwbHVzXCI6XCLiip5cIixcImJveHRpbWVzXCI6XCLiiqBcIixcImJveHVsXCI6XCLilJhcIixcImJveHVMXCI6XCLilZtcIixcImJveFVsXCI6XCLilZxcIixcImJveFVMXCI6XCLilZ1cIixcImJveHVyXCI6XCLilJRcIixcImJveHVSXCI6XCLilZhcIixcImJveFVyXCI6XCLilZlcIixcImJveFVSXCI6XCLilZpcIixcImJveHZcIjpcIuKUglwiLFwiYm94VlwiOlwi4pWRXCIsXCJib3h2aFwiOlwi4pS8XCIsXCJib3h2SFwiOlwi4pWqXCIsXCJib3hWaFwiOlwi4pWrXCIsXCJib3hWSFwiOlwi4pWsXCIsXCJib3h2bFwiOlwi4pSkXCIsXCJib3h2TFwiOlwi4pWhXCIsXCJib3hWbFwiOlwi4pWiXCIsXCJib3hWTFwiOlwi4pWjXCIsXCJib3h2clwiOlwi4pScXCIsXCJib3h2UlwiOlwi4pWeXCIsXCJib3hWclwiOlwi4pWfXCIsXCJib3hWUlwiOlwi4pWgXCIsXCJicHJpbWVcIjpcIuKAtVwiLFwiYnJldmVcIjpcIsuYXCIsXCJCcmV2ZVwiOlwiy5hcIixcImJydmJhclwiOlwiwqZcIixcImJzY3JcIjpcIvCdkrdcIixcIkJzY3JcIjpcIuKErFwiLFwiYnNlbWlcIjpcIuKBj1wiLFwiYnNpbVwiOlwi4oi9XCIsXCJic2ltZVwiOlwi4ouNXCIsXCJic29sYlwiOlwi4qeFXCIsXCJic29sXCI6XCJcXFxcXCIsXCJic29saHN1YlwiOlwi4p+IXCIsXCJidWxsXCI6XCLigKJcIixcImJ1bGxldFwiOlwi4oCiXCIsXCJidW1wXCI6XCLiiY5cIixcImJ1bXBFXCI6XCLiqq5cIixcImJ1bXBlXCI6XCLiiY9cIixcIkJ1bXBlcVwiOlwi4omOXCIsXCJidW1wZXFcIjpcIuKJj1wiLFwiQ2FjdXRlXCI6XCLEhlwiLFwiY2FjdXRlXCI6XCLEh1wiLFwiY2FwYW5kXCI6XCLiqYRcIixcImNhcGJyY3VwXCI6XCLiqYlcIixcImNhcGNhcFwiOlwi4qmLXCIsXCJjYXBcIjpcIuKIqVwiLFwiQ2FwXCI6XCLii5JcIixcImNhcGN1cFwiOlwi4qmHXCIsXCJjYXBkb3RcIjpcIuKpgFwiLFwiQ2FwaXRhbERpZmZlcmVudGlhbERcIjpcIuKFhVwiLFwiY2Fwc1wiOlwi4oip77iAXCIsXCJjYXJldFwiOlwi4oGBXCIsXCJjYXJvblwiOlwiy4dcIixcIkNheWxleXNcIjpcIuKErVwiLFwiY2NhcHNcIjpcIuKpjVwiLFwiQ2Nhcm9uXCI6XCLEjFwiLFwiY2Nhcm9uXCI6XCLEjVwiLFwiQ2NlZGlsXCI6XCLDh1wiLFwiY2NlZGlsXCI6XCLDp1wiLFwiQ2NpcmNcIjpcIsSIXCIsXCJjY2lyY1wiOlwixIlcIixcIkNjb25pbnRcIjpcIuKIsFwiLFwiY2N1cHNcIjpcIuKpjFwiLFwiY2N1cHNzbVwiOlwi4qmQXCIsXCJDZG90XCI6XCLEilwiLFwiY2RvdFwiOlwixItcIixcImNlZGlsXCI6XCLCuFwiLFwiQ2VkaWxsYVwiOlwiwrhcIixcImNlbXB0eXZcIjpcIuKmslwiLFwiY2VudFwiOlwiwqJcIixcImNlbnRlcmRvdFwiOlwiwrdcIixcIkNlbnRlckRvdFwiOlwiwrdcIixcImNmclwiOlwi8J2UoFwiLFwiQ2ZyXCI6XCLihK1cIixcIkNIY3lcIjpcItCnXCIsXCJjaGN5XCI6XCLRh1wiLFwiY2hlY2tcIjpcIuKck1wiLFwiY2hlY2ttYXJrXCI6XCLinJNcIixcIkNoaVwiOlwizqdcIixcImNoaVwiOlwiz4dcIixcImNpcmNcIjpcIsuGXCIsXCJjaXJjZXFcIjpcIuKJl1wiLFwiY2lyY2xlYXJyb3dsZWZ0XCI6XCLihrpcIixcImNpcmNsZWFycm93cmlnaHRcIjpcIuKGu1wiLFwiY2lyY2xlZGFzdFwiOlwi4oqbXCIsXCJjaXJjbGVkY2lyY1wiOlwi4oqaXCIsXCJjaXJjbGVkZGFzaFwiOlwi4oqdXCIsXCJDaXJjbGVEb3RcIjpcIuKKmVwiLFwiY2lyY2xlZFJcIjpcIsKuXCIsXCJjaXJjbGVkU1wiOlwi4pOIXCIsXCJDaXJjbGVNaW51c1wiOlwi4oqWXCIsXCJDaXJjbGVQbHVzXCI6XCLiipVcIixcIkNpcmNsZVRpbWVzXCI6XCLiipdcIixcImNpclwiOlwi4peLXCIsXCJjaXJFXCI6XCLip4NcIixcImNpcmVcIjpcIuKJl1wiLFwiY2lyZm5pbnRcIjpcIuKokFwiLFwiY2lybWlkXCI6XCLiq69cIixcImNpcnNjaXJcIjpcIuKnglwiLFwiQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6XCLiiLJcIixcIkNsb3NlQ3VybHlEb3VibGVRdW90ZVwiOlwi4oCdXCIsXCJDbG9zZUN1cmx5UXVvdGVcIjpcIuKAmVwiLFwiY2x1YnNcIjpcIuKZo1wiLFwiY2x1YnN1aXRcIjpcIuKZo1wiLFwiY29sb25cIjpcIjpcIixcIkNvbG9uXCI6XCLiiLdcIixcIkNvbG9uZVwiOlwi4qm0XCIsXCJjb2xvbmVcIjpcIuKJlFwiLFwiY29sb25lcVwiOlwi4omUXCIsXCJjb21tYVwiOlwiLFwiLFwiY29tbWF0XCI6XCJAXCIsXCJjb21wXCI6XCLiiIFcIixcImNvbXBmblwiOlwi4oiYXCIsXCJjb21wbGVtZW50XCI6XCLiiIFcIixcImNvbXBsZXhlc1wiOlwi4oSCXCIsXCJjb25nXCI6XCLiiYVcIixcImNvbmdkb3RcIjpcIuKprVwiLFwiQ29uZ3J1ZW50XCI6XCLiiaFcIixcImNvbmludFwiOlwi4oiuXCIsXCJDb25pbnRcIjpcIuKIr1wiLFwiQ29udG91ckludGVncmFsXCI6XCLiiK5cIixcImNvcGZcIjpcIvCdlZRcIixcIkNvcGZcIjpcIuKEglwiLFwiY29wcm9kXCI6XCLiiJBcIixcIkNvcHJvZHVjdFwiOlwi4oiQXCIsXCJjb3B5XCI6XCLCqVwiLFwiQ09QWVwiOlwiwqlcIixcImNvcHlzclwiOlwi4oSXXCIsXCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6XCLiiLNcIixcImNyYXJyXCI6XCLihrVcIixcImNyb3NzXCI6XCLinJdcIixcIkNyb3NzXCI6XCLiqK9cIixcIkNzY3JcIjpcIvCdkp5cIixcImNzY3JcIjpcIvCdkrhcIixcImNzdWJcIjpcIuKrj1wiLFwiY3N1YmVcIjpcIuKrkVwiLFwiY3N1cFwiOlwi4quQXCIsXCJjc3VwZVwiOlwi4quSXCIsXCJjdGRvdFwiOlwi4ouvXCIsXCJjdWRhcnJsXCI6XCLipLhcIixcImN1ZGFycnJcIjpcIuKktVwiLFwiY3VlcHJcIjpcIuKLnlwiLFwiY3Vlc2NcIjpcIuKLn1wiLFwiY3VsYXJyXCI6XCLihrZcIixcImN1bGFycnBcIjpcIuKkvVwiLFwiY3VwYnJjYXBcIjpcIuKpiFwiLFwiY3VwY2FwXCI6XCLiqYZcIixcIkN1cENhcFwiOlwi4omNXCIsXCJjdXBcIjpcIuKIqlwiLFwiQ3VwXCI6XCLii5NcIixcImN1cGN1cFwiOlwi4qmKXCIsXCJjdXBkb3RcIjpcIuKKjVwiLFwiY3Vwb3JcIjpcIuKphVwiLFwiY3Vwc1wiOlwi4oiq77iAXCIsXCJjdXJhcnJcIjpcIuKGt1wiLFwiY3VyYXJybVwiOlwi4qS8XCIsXCJjdXJseWVxcHJlY1wiOlwi4oueXCIsXCJjdXJseWVxc3VjY1wiOlwi4oufXCIsXCJjdXJseXZlZVwiOlwi4ouOXCIsXCJjdXJseXdlZGdlXCI6XCLii49cIixcImN1cnJlblwiOlwiwqRcIixcImN1cnZlYXJyb3dsZWZ0XCI6XCLihrZcIixcImN1cnZlYXJyb3dyaWdodFwiOlwi4oa3XCIsXCJjdXZlZVwiOlwi4ouOXCIsXCJjdXdlZFwiOlwi4ouPXCIsXCJjd2NvbmludFwiOlwi4oiyXCIsXCJjd2ludFwiOlwi4oixXCIsXCJjeWxjdHlcIjpcIuKMrVwiLFwiZGFnZ2VyXCI6XCLigKBcIixcIkRhZ2dlclwiOlwi4oChXCIsXCJkYWxldGhcIjpcIuKEuFwiLFwiZGFyclwiOlwi4oaTXCIsXCJEYXJyXCI6XCLihqFcIixcImRBcnJcIjpcIuKHk1wiLFwiZGFzaFwiOlwi4oCQXCIsXCJEYXNodlwiOlwi4qukXCIsXCJkYXNodlwiOlwi4oqjXCIsXCJkYmthcm93XCI6XCLipI9cIixcImRibGFjXCI6XCLLnVwiLFwiRGNhcm9uXCI6XCLEjlwiLFwiZGNhcm9uXCI6XCLEj1wiLFwiRGN5XCI6XCLQlFwiLFwiZGN5XCI6XCLQtFwiLFwiZGRhZ2dlclwiOlwi4oChXCIsXCJkZGFyclwiOlwi4oeKXCIsXCJERFwiOlwi4oWFXCIsXCJkZFwiOlwi4oWGXCIsXCJERG90cmFoZFwiOlwi4qSRXCIsXCJkZG90c2VxXCI6XCLiqbdcIixcImRlZ1wiOlwiwrBcIixcIkRlbFwiOlwi4oiHXCIsXCJEZWx0YVwiOlwizpRcIixcImRlbHRhXCI6XCLOtFwiLFwiZGVtcHR5dlwiOlwi4qaxXCIsXCJkZmlzaHRcIjpcIuKlv1wiLFwiRGZyXCI6XCLwnZSHXCIsXCJkZnJcIjpcIvCdlKFcIixcImRIYXJcIjpcIuKlpVwiLFwiZGhhcmxcIjpcIuKHg1wiLFwiZGhhcnJcIjpcIuKHglwiLFwiRGlhY3JpdGljYWxBY3V0ZVwiOlwiwrRcIixcIkRpYWNyaXRpY2FsRG90XCI6XCLLmVwiLFwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZVwiOlwiy51cIixcIkRpYWNyaXRpY2FsR3JhdmVcIjpcImBcIixcIkRpYWNyaXRpY2FsVGlsZGVcIjpcIsucXCIsXCJkaWFtXCI6XCLii4RcIixcImRpYW1vbmRcIjpcIuKLhFwiLFwiRGlhbW9uZFwiOlwi4ouEXCIsXCJkaWFtb25kc3VpdFwiOlwi4pmmXCIsXCJkaWFtc1wiOlwi4pmmXCIsXCJkaWVcIjpcIsKoXCIsXCJEaWZmZXJlbnRpYWxEXCI6XCLihYZcIixcImRpZ2FtbWFcIjpcIs+dXCIsXCJkaXNpblwiOlwi4ouyXCIsXCJkaXZcIjpcIsO3XCIsXCJkaXZpZGVcIjpcIsO3XCIsXCJkaXZpZGVvbnRpbWVzXCI6XCLii4dcIixcImRpdm9ueFwiOlwi4ouHXCIsXCJESmN5XCI6XCLQglwiLFwiZGpjeVwiOlwi0ZJcIixcImRsY29yblwiOlwi4oyeXCIsXCJkbGNyb3BcIjpcIuKMjVwiLFwiZG9sbGFyXCI6XCIkXCIsXCJEb3BmXCI6XCLwnZS7XCIsXCJkb3BmXCI6XCLwnZWVXCIsXCJEb3RcIjpcIsKoXCIsXCJkb3RcIjpcIsuZXCIsXCJEb3REb3RcIjpcIuKDnFwiLFwiZG90ZXFcIjpcIuKJkFwiLFwiZG90ZXFkb3RcIjpcIuKJkVwiLFwiRG90RXF1YWxcIjpcIuKJkFwiLFwiZG90bWludXNcIjpcIuKIuFwiLFwiZG90cGx1c1wiOlwi4oiUXCIsXCJkb3RzcXVhcmVcIjpcIuKKoVwiLFwiZG91YmxlYmFyd2VkZ2VcIjpcIuKMhlwiLFwiRG91YmxlQ29udG91ckludGVncmFsXCI6XCLiiK9cIixcIkRvdWJsZURvdFwiOlwiwqhcIixcIkRvdWJsZURvd25BcnJvd1wiOlwi4oeTXCIsXCJEb3VibGVMZWZ0QXJyb3dcIjpcIuKHkFwiLFwiRG91YmxlTGVmdFJpZ2h0QXJyb3dcIjpcIuKHlFwiLFwiRG91YmxlTGVmdFRlZVwiOlwi4qukXCIsXCJEb3VibGVMb25nTGVmdEFycm93XCI6XCLin7hcIixcIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwi4p+6XCIsXCJEb3VibGVMb25nUmlnaHRBcnJvd1wiOlwi4p+5XCIsXCJEb3VibGVSaWdodEFycm93XCI6XCLih5JcIixcIkRvdWJsZVJpZ2h0VGVlXCI6XCLiiqhcIixcIkRvdWJsZVVwQXJyb3dcIjpcIuKHkVwiLFwiRG91YmxlVXBEb3duQXJyb3dcIjpcIuKHlVwiLFwiRG91YmxlVmVydGljYWxCYXJcIjpcIuKIpVwiLFwiRG93bkFycm93QmFyXCI6XCLipJNcIixcImRvd25hcnJvd1wiOlwi4oaTXCIsXCJEb3duQXJyb3dcIjpcIuKGk1wiLFwiRG93bmFycm93XCI6XCLih5NcIixcIkRvd25BcnJvd1VwQXJyb3dcIjpcIuKHtVwiLFwiRG93bkJyZXZlXCI6XCLMkVwiLFwiZG93bmRvd25hcnJvd3NcIjpcIuKHilwiLFwiZG93bmhhcnBvb25sZWZ0XCI6XCLih4NcIixcImRvd25oYXJwb29ucmlnaHRcIjpcIuKHglwiLFwiRG93bkxlZnRSaWdodFZlY3RvclwiOlwi4qWQXCIsXCJEb3duTGVmdFRlZVZlY3RvclwiOlwi4qWeXCIsXCJEb3duTGVmdFZlY3RvckJhclwiOlwi4qWWXCIsXCJEb3duTGVmdFZlY3RvclwiOlwi4oa9XCIsXCJEb3duUmlnaHRUZWVWZWN0b3JcIjpcIuKln1wiLFwiRG93blJpZ2h0VmVjdG9yQmFyXCI6XCLipZdcIixcIkRvd25SaWdodFZlY3RvclwiOlwi4oeBXCIsXCJEb3duVGVlQXJyb3dcIjpcIuKGp1wiLFwiRG93blRlZVwiOlwi4oqkXCIsXCJkcmJrYXJvd1wiOlwi4qSQXCIsXCJkcmNvcm5cIjpcIuKMn1wiLFwiZHJjcm9wXCI6XCLijIxcIixcIkRzY3JcIjpcIvCdkp9cIixcImRzY3JcIjpcIvCdkrlcIixcIkRTY3lcIjpcItCFXCIsXCJkc2N5XCI6XCLRlVwiLFwiZHNvbFwiOlwi4qe2XCIsXCJEc3Ryb2tcIjpcIsSQXCIsXCJkc3Ryb2tcIjpcIsSRXCIsXCJkdGRvdFwiOlwi4ouxXCIsXCJkdHJpXCI6XCLilr9cIixcImR0cmlmXCI6XCLilr5cIixcImR1YXJyXCI6XCLih7VcIixcImR1aGFyXCI6XCLipa9cIixcImR3YW5nbGVcIjpcIuKmplwiLFwiRFpjeVwiOlwi0I9cIixcImR6Y3lcIjpcItGfXCIsXCJkemlncmFyclwiOlwi4p+/XCIsXCJFYWN1dGVcIjpcIsOJXCIsXCJlYWN1dGVcIjpcIsOpXCIsXCJlYXN0ZXJcIjpcIuKprlwiLFwiRWNhcm9uXCI6XCLEmlwiLFwiZWNhcm9uXCI6XCLEm1wiLFwiRWNpcmNcIjpcIsOKXCIsXCJlY2lyY1wiOlwiw6pcIixcImVjaXJcIjpcIuKJllwiLFwiZWNvbG9uXCI6XCLiiZVcIixcIkVjeVwiOlwi0K1cIixcImVjeVwiOlwi0Y1cIixcImVERG90XCI6XCLiqbdcIixcIkVkb3RcIjpcIsSWXCIsXCJlZG90XCI6XCLEl1wiLFwiZURvdFwiOlwi4omRXCIsXCJlZVwiOlwi4oWHXCIsXCJlZkRvdFwiOlwi4omSXCIsXCJFZnJcIjpcIvCdlIhcIixcImVmclwiOlwi8J2UolwiLFwiZWdcIjpcIuKqmlwiLFwiRWdyYXZlXCI6XCLDiFwiLFwiZWdyYXZlXCI6XCLDqFwiLFwiZWdzXCI6XCLiqpZcIixcImVnc2RvdFwiOlwi4qqYXCIsXCJlbFwiOlwi4qqZXCIsXCJFbGVtZW50XCI6XCLiiIhcIixcImVsaW50ZXJzXCI6XCLij6dcIixcImVsbFwiOlwi4oSTXCIsXCJlbHNcIjpcIuKqlVwiLFwiZWxzZG90XCI6XCLiqpdcIixcIkVtYWNyXCI6XCLEklwiLFwiZW1hY3JcIjpcIsSTXCIsXCJlbXB0eVwiOlwi4oiFXCIsXCJlbXB0eXNldFwiOlwi4oiFXCIsXCJFbXB0eVNtYWxsU3F1YXJlXCI6XCLil7tcIixcImVtcHR5dlwiOlwi4oiFXCIsXCJFbXB0eVZlcnlTbWFsbFNxdWFyZVwiOlwi4parXCIsXCJlbXNwMTNcIjpcIuKAhFwiLFwiZW1zcDE0XCI6XCLigIVcIixcImVtc3BcIjpcIuKAg1wiLFwiRU5HXCI6XCLFilwiLFwiZW5nXCI6XCLFi1wiLFwiZW5zcFwiOlwi4oCCXCIsXCJFb2dvblwiOlwixJhcIixcImVvZ29uXCI6XCLEmVwiLFwiRW9wZlwiOlwi8J2UvFwiLFwiZW9wZlwiOlwi8J2VllwiLFwiZXBhclwiOlwi4ouVXCIsXCJlcGFyc2xcIjpcIuKno1wiLFwiZXBsdXNcIjpcIuKpsVwiLFwiZXBzaVwiOlwizrVcIixcIkVwc2lsb25cIjpcIs6VXCIsXCJlcHNpbG9uXCI6XCLOtVwiLFwiZXBzaXZcIjpcIs+1XCIsXCJlcWNpcmNcIjpcIuKJllwiLFwiZXFjb2xvblwiOlwi4omVXCIsXCJlcXNpbVwiOlwi4omCXCIsXCJlcXNsYW50Z3RyXCI6XCLiqpZcIixcImVxc2xhbnRsZXNzXCI6XCLiqpVcIixcIkVxdWFsXCI6XCLiqbVcIixcImVxdWFsc1wiOlwiPVwiLFwiRXF1YWxUaWxkZVwiOlwi4omCXCIsXCJlcXVlc3RcIjpcIuKJn1wiLFwiRXF1aWxpYnJpdW1cIjpcIuKHjFwiLFwiZXF1aXZcIjpcIuKJoVwiLFwiZXF1aXZERFwiOlwi4qm4XCIsXCJlcXZwYXJzbFwiOlwi4qelXCIsXCJlcmFyclwiOlwi4qWxXCIsXCJlckRvdFwiOlwi4omTXCIsXCJlc2NyXCI6XCLihK9cIixcIkVzY3JcIjpcIuKEsFwiLFwiZXNkb3RcIjpcIuKJkFwiLFwiRXNpbVwiOlwi4qmzXCIsXCJlc2ltXCI6XCLiiYJcIixcIkV0YVwiOlwizpdcIixcImV0YVwiOlwizrdcIixcIkVUSFwiOlwiw5BcIixcImV0aFwiOlwiw7BcIixcIkV1bWxcIjpcIsOLXCIsXCJldW1sXCI6XCLDq1wiLFwiZXVyb1wiOlwi4oKsXCIsXCJleGNsXCI6XCIhXCIsXCJleGlzdFwiOlwi4oiDXCIsXCJFeGlzdHNcIjpcIuKIg1wiLFwiZXhwZWN0YXRpb25cIjpcIuKEsFwiLFwiZXhwb25lbnRpYWxlXCI6XCLihYdcIixcIkV4cG9uZW50aWFsRVwiOlwi4oWHXCIsXCJmYWxsaW5nZG90c2VxXCI6XCLiiZJcIixcIkZjeVwiOlwi0KRcIixcImZjeVwiOlwi0YRcIixcImZlbWFsZVwiOlwi4pmAXCIsXCJmZmlsaWdcIjpcIu+sg1wiLFwiZmZsaWdcIjpcIu+sgFwiLFwiZmZsbGlnXCI6XCLvrIRcIixcIkZmclwiOlwi8J2UiVwiLFwiZmZyXCI6XCLwnZSjXCIsXCJmaWxpZ1wiOlwi76yBXCIsXCJGaWxsZWRTbWFsbFNxdWFyZVwiOlwi4pe8XCIsXCJGaWxsZWRWZXJ5U21hbGxTcXVhcmVcIjpcIuKWqlwiLFwiZmpsaWdcIjpcImZqXCIsXCJmbGF0XCI6XCLima1cIixcImZsbGlnXCI6XCLvrIJcIixcImZsdG5zXCI6XCLilrFcIixcImZub2ZcIjpcIsaSXCIsXCJGb3BmXCI6XCLwnZS9XCIsXCJmb3BmXCI6XCLwnZWXXCIsXCJmb3JhbGxcIjpcIuKIgFwiLFwiRm9yQWxsXCI6XCLiiIBcIixcImZvcmtcIjpcIuKLlFwiLFwiZm9ya3ZcIjpcIuKrmVwiLFwiRm91cmllcnRyZlwiOlwi4oSxXCIsXCJmcGFydGludFwiOlwi4qiNXCIsXCJmcmFjMTJcIjpcIsK9XCIsXCJmcmFjMTNcIjpcIuKFk1wiLFwiZnJhYzE0XCI6XCLCvFwiLFwiZnJhYzE1XCI6XCLihZVcIixcImZyYWMxNlwiOlwi4oWZXCIsXCJmcmFjMThcIjpcIuKFm1wiLFwiZnJhYzIzXCI6XCLihZRcIixcImZyYWMyNVwiOlwi4oWWXCIsXCJmcmFjMzRcIjpcIsK+XCIsXCJmcmFjMzVcIjpcIuKFl1wiLFwiZnJhYzM4XCI6XCLihZxcIixcImZyYWM0NVwiOlwi4oWYXCIsXCJmcmFjNTZcIjpcIuKFmlwiLFwiZnJhYzU4XCI6XCLihZ1cIixcImZyYWM3OFwiOlwi4oWeXCIsXCJmcmFzbFwiOlwi4oGEXCIsXCJmcm93blwiOlwi4oyiXCIsXCJmc2NyXCI6XCLwnZK7XCIsXCJGc2NyXCI6XCLihLFcIixcImdhY3V0ZVwiOlwix7VcIixcIkdhbW1hXCI6XCLOk1wiLFwiZ2FtbWFcIjpcIs6zXCIsXCJHYW1tYWRcIjpcIs+cXCIsXCJnYW1tYWRcIjpcIs+dXCIsXCJnYXBcIjpcIuKqhlwiLFwiR2JyZXZlXCI6XCLEnlwiLFwiZ2JyZXZlXCI6XCLEn1wiLFwiR2NlZGlsXCI6XCLEolwiLFwiR2NpcmNcIjpcIsScXCIsXCJnY2lyY1wiOlwixJ1cIixcIkdjeVwiOlwi0JNcIixcImdjeVwiOlwi0LNcIixcIkdkb3RcIjpcIsSgXCIsXCJnZG90XCI6XCLEoVwiLFwiZ2VcIjpcIuKJpVwiLFwiZ0VcIjpcIuKJp1wiLFwiZ0VsXCI6XCLiqoxcIixcImdlbFwiOlwi4oubXCIsXCJnZXFcIjpcIuKJpVwiLFwiZ2VxcVwiOlwi4omnXCIsXCJnZXFzbGFudFwiOlwi4qm+XCIsXCJnZXNjY1wiOlwi4qqpXCIsXCJnZXNcIjpcIuKpvlwiLFwiZ2VzZG90XCI6XCLiqoBcIixcImdlc2RvdG9cIjpcIuKqglwiLFwiZ2VzZG90b2xcIjpcIuKqhFwiLFwiZ2VzbFwiOlwi4oub77iAXCIsXCJnZXNsZXNcIjpcIuKqlFwiLFwiR2ZyXCI6XCLwnZSKXCIsXCJnZnJcIjpcIvCdlKRcIixcImdnXCI6XCLiiatcIixcIkdnXCI6XCLii5lcIixcImdnZ1wiOlwi4ouZXCIsXCJnaW1lbFwiOlwi4oS3XCIsXCJHSmN5XCI6XCLQg1wiLFwiZ2pjeVwiOlwi0ZNcIixcImdsYVwiOlwi4qqlXCIsXCJnbFwiOlwi4om3XCIsXCJnbEVcIjpcIuKqklwiLFwiZ2xqXCI6XCLiqqRcIixcImduYXBcIjpcIuKqilwiLFwiZ25hcHByb3hcIjpcIuKqilwiLFwiZ25lXCI6XCLiqohcIixcImduRVwiOlwi4ompXCIsXCJnbmVxXCI6XCLiqohcIixcImduZXFxXCI6XCLiialcIixcImduc2ltXCI6XCLii6dcIixcIkdvcGZcIjpcIvCdlL5cIixcImdvcGZcIjpcIvCdlZhcIixcImdyYXZlXCI6XCJgXCIsXCJHcmVhdGVyRXF1YWxcIjpcIuKJpVwiLFwiR3JlYXRlckVxdWFsTGVzc1wiOlwi4oubXCIsXCJHcmVhdGVyRnVsbEVxdWFsXCI6XCLiiadcIixcIkdyZWF0ZXJHcmVhdGVyXCI6XCLiqqJcIixcIkdyZWF0ZXJMZXNzXCI6XCLiibdcIixcIkdyZWF0ZXJTbGFudEVxdWFsXCI6XCLiqb5cIixcIkdyZWF0ZXJUaWxkZVwiOlwi4omzXCIsXCJHc2NyXCI6XCLwnZKiXCIsXCJnc2NyXCI6XCLihIpcIixcImdzaW1cIjpcIuKJs1wiLFwiZ3NpbWVcIjpcIuKqjlwiLFwiZ3NpbWxcIjpcIuKqkFwiLFwiZ3RjY1wiOlwi4qqnXCIsXCJndGNpclwiOlwi4qm6XCIsXCJndFwiOlwiPlwiLFwiR1RcIjpcIj5cIixcIkd0XCI6XCLiiatcIixcImd0ZG90XCI6XCLii5dcIixcImd0bFBhclwiOlwi4qaVXCIsXCJndHF1ZXN0XCI6XCLiqbxcIixcImd0cmFwcHJveFwiOlwi4qqGXCIsXCJndHJhcnJcIjpcIuKluFwiLFwiZ3RyZG90XCI6XCLii5dcIixcImd0cmVxbGVzc1wiOlwi4oubXCIsXCJndHJlcXFsZXNzXCI6XCLiqoxcIixcImd0cmxlc3NcIjpcIuKJt1wiLFwiZ3Ryc2ltXCI6XCLiibNcIixcImd2ZXJ0bmVxcVwiOlwi4omp77iAXCIsXCJndm5FXCI6XCLiianvuIBcIixcIkhhY2VrXCI6XCLLh1wiLFwiaGFpcnNwXCI6XCLigIpcIixcImhhbGZcIjpcIsK9XCIsXCJoYW1pbHRcIjpcIuKEi1wiLFwiSEFSRGN5XCI6XCLQqlwiLFwiaGFyZGN5XCI6XCLRilwiLFwiaGFycmNpclwiOlwi4qWIXCIsXCJoYXJyXCI6XCLihpRcIixcImhBcnJcIjpcIuKHlFwiLFwiaGFycndcIjpcIuKGrVwiLFwiSGF0XCI6XCJeXCIsXCJoYmFyXCI6XCLihI9cIixcIkhjaXJjXCI6XCLEpFwiLFwiaGNpcmNcIjpcIsSlXCIsXCJoZWFydHNcIjpcIuKZpVwiLFwiaGVhcnRzdWl0XCI6XCLimaVcIixcImhlbGxpcFwiOlwi4oCmXCIsXCJoZXJjb25cIjpcIuKKuVwiLFwiaGZyXCI6XCLwnZSlXCIsXCJIZnJcIjpcIuKEjFwiLFwiSGlsYmVydFNwYWNlXCI6XCLihItcIixcImhrc2Vhcm93XCI6XCLipKVcIixcImhrc3dhcm93XCI6XCLipKZcIixcImhvYXJyXCI6XCLih79cIixcImhvbXRodFwiOlwi4oi7XCIsXCJob29rbGVmdGFycm93XCI6XCLihqlcIixcImhvb2tyaWdodGFycm93XCI6XCLihqpcIixcImhvcGZcIjpcIvCdlZlcIixcIkhvcGZcIjpcIuKEjVwiLFwiaG9yYmFyXCI6XCLigJVcIixcIkhvcml6b250YWxMaW5lXCI6XCLilIBcIixcImhzY3JcIjpcIvCdkr1cIixcIkhzY3JcIjpcIuKEi1wiLFwiaHNsYXNoXCI6XCLihI9cIixcIkhzdHJva1wiOlwixKZcIixcImhzdHJva1wiOlwixKdcIixcIkh1bXBEb3duSHVtcFwiOlwi4omOXCIsXCJIdW1wRXF1YWxcIjpcIuKJj1wiLFwiaHlidWxsXCI6XCLigYNcIixcImh5cGhlblwiOlwi4oCQXCIsXCJJYWN1dGVcIjpcIsONXCIsXCJpYWN1dGVcIjpcIsOtXCIsXCJpY1wiOlwi4oGjXCIsXCJJY2lyY1wiOlwiw45cIixcImljaXJjXCI6XCLDrlwiLFwiSWN5XCI6XCLQmFwiLFwiaWN5XCI6XCLQuFwiLFwiSWRvdFwiOlwixLBcIixcIklFY3lcIjpcItCVXCIsXCJpZWN5XCI6XCLQtVwiLFwiaWV4Y2xcIjpcIsKhXCIsXCJpZmZcIjpcIuKHlFwiLFwiaWZyXCI6XCLwnZSmXCIsXCJJZnJcIjpcIuKEkVwiLFwiSWdyYXZlXCI6XCLDjFwiLFwiaWdyYXZlXCI6XCLDrFwiLFwiaWlcIjpcIuKFiFwiLFwiaWlpaW50XCI6XCLiqIxcIixcImlpaW50XCI6XCLiiK1cIixcImlpbmZpblwiOlwi4qecXCIsXCJpaW90YVwiOlwi4oSpXCIsXCJJSmxpZ1wiOlwixLJcIixcImlqbGlnXCI6XCLEs1wiLFwiSW1hY3JcIjpcIsSqXCIsXCJpbWFjclwiOlwixKtcIixcImltYWdlXCI6XCLihJFcIixcIkltYWdpbmFyeUlcIjpcIuKFiFwiLFwiaW1hZ2xpbmVcIjpcIuKEkFwiLFwiaW1hZ3BhcnRcIjpcIuKEkVwiLFwiaW1hdGhcIjpcIsSxXCIsXCJJbVwiOlwi4oSRXCIsXCJpbW9mXCI6XCLiirdcIixcImltcGVkXCI6XCLGtVwiLFwiSW1wbGllc1wiOlwi4oeSXCIsXCJpbmNhcmVcIjpcIuKEhVwiLFwiaW5cIjpcIuKIiFwiLFwiaW5maW5cIjpcIuKInlwiLFwiaW5maW50aWVcIjpcIuKnnVwiLFwiaW5vZG90XCI6XCLEsVwiLFwiaW50Y2FsXCI6XCLiirpcIixcImludFwiOlwi4oirXCIsXCJJbnRcIjpcIuKIrFwiLFwiaW50ZWdlcnNcIjpcIuKEpFwiLFwiSW50ZWdyYWxcIjpcIuKIq1wiLFwiaW50ZXJjYWxcIjpcIuKKulwiLFwiSW50ZXJzZWN0aW9uXCI6XCLii4JcIixcImludGxhcmhrXCI6XCLiqJdcIixcImludHByb2RcIjpcIuKovFwiLFwiSW52aXNpYmxlQ29tbWFcIjpcIuKBo1wiLFwiSW52aXNpYmxlVGltZXNcIjpcIuKBolwiLFwiSU9jeVwiOlwi0IFcIixcImlvY3lcIjpcItGRXCIsXCJJb2dvblwiOlwixK5cIixcImlvZ29uXCI6XCLEr1wiLFwiSW9wZlwiOlwi8J2VgFwiLFwiaW9wZlwiOlwi8J2VmlwiLFwiSW90YVwiOlwizplcIixcImlvdGFcIjpcIs65XCIsXCJpcHJvZFwiOlwi4qi8XCIsXCJpcXVlc3RcIjpcIsK/XCIsXCJpc2NyXCI6XCLwnZK+XCIsXCJJc2NyXCI6XCLihJBcIixcImlzaW5cIjpcIuKIiFwiLFwiaXNpbmRvdFwiOlwi4ou1XCIsXCJpc2luRVwiOlwi4ou5XCIsXCJpc2luc1wiOlwi4ou0XCIsXCJpc2luc3ZcIjpcIuKLs1wiLFwiaXNpbnZcIjpcIuKIiFwiLFwiaXRcIjpcIuKBolwiLFwiSXRpbGRlXCI6XCLEqFwiLFwiaXRpbGRlXCI6XCLEqVwiLFwiSXVrY3lcIjpcItCGXCIsXCJpdWtjeVwiOlwi0ZZcIixcIkl1bWxcIjpcIsOPXCIsXCJpdW1sXCI6XCLDr1wiLFwiSmNpcmNcIjpcIsS0XCIsXCJqY2lyY1wiOlwixLVcIixcIkpjeVwiOlwi0JlcIixcImpjeVwiOlwi0LlcIixcIkpmclwiOlwi8J2UjVwiLFwiamZyXCI6XCLwnZSnXCIsXCJqbWF0aFwiOlwiyLdcIixcIkpvcGZcIjpcIvCdlYFcIixcImpvcGZcIjpcIvCdlZtcIixcIkpzY3JcIjpcIvCdkqVcIixcImpzY3JcIjpcIvCdkr9cIixcIkpzZXJjeVwiOlwi0IhcIixcImpzZXJjeVwiOlwi0ZhcIixcIkp1a2N5XCI6XCLQhFwiLFwianVrY3lcIjpcItGUXCIsXCJLYXBwYVwiOlwizppcIixcImthcHBhXCI6XCLOulwiLFwia2FwcGF2XCI6XCLPsFwiLFwiS2NlZGlsXCI6XCLEtlwiLFwia2NlZGlsXCI6XCLEt1wiLFwiS2N5XCI6XCLQmlwiLFwia2N5XCI6XCLQulwiLFwiS2ZyXCI6XCLwnZSOXCIsXCJrZnJcIjpcIvCdlKhcIixcImtncmVlblwiOlwixLhcIixcIktIY3lcIjpcItClXCIsXCJraGN5XCI6XCLRhVwiLFwiS0pjeVwiOlwi0IxcIixcImtqY3lcIjpcItGcXCIsXCJLb3BmXCI6XCLwnZWCXCIsXCJrb3BmXCI6XCLwnZWcXCIsXCJLc2NyXCI6XCLwnZKmXCIsXCJrc2NyXCI6XCLwnZOAXCIsXCJsQWFyclwiOlwi4oeaXCIsXCJMYWN1dGVcIjpcIsS5XCIsXCJsYWN1dGVcIjpcIsS6XCIsXCJsYWVtcHR5dlwiOlwi4qa0XCIsXCJsYWdyYW5cIjpcIuKEklwiLFwiTGFtYmRhXCI6XCLOm1wiLFwibGFtYmRhXCI6XCLOu1wiLFwibGFuZ1wiOlwi4p+oXCIsXCJMYW5nXCI6XCLin6pcIixcImxhbmdkXCI6XCLippFcIixcImxhbmdsZVwiOlwi4p+oXCIsXCJsYXBcIjpcIuKqhVwiLFwiTGFwbGFjZXRyZlwiOlwi4oSSXCIsXCJsYXF1b1wiOlwiwqtcIixcImxhcnJiXCI6XCLih6RcIixcImxhcnJiZnNcIjpcIuKkn1wiLFwibGFyclwiOlwi4oaQXCIsXCJMYXJyXCI6XCLihp5cIixcImxBcnJcIjpcIuKHkFwiLFwibGFycmZzXCI6XCLipJ1cIixcImxhcnJoa1wiOlwi4oapXCIsXCJsYXJybHBcIjpcIuKGq1wiLFwibGFycnBsXCI6XCLipLlcIixcImxhcnJzaW1cIjpcIuKls1wiLFwibGFycnRsXCI6XCLihqJcIixcImxhdGFpbFwiOlwi4qSZXCIsXCJsQXRhaWxcIjpcIuKkm1wiLFwibGF0XCI6XCLiqqtcIixcImxhdGVcIjpcIuKqrVwiLFwibGF0ZXNcIjpcIuKqre+4gFwiLFwibGJhcnJcIjpcIuKkjFwiLFwibEJhcnJcIjpcIuKkjlwiLFwibGJicmtcIjpcIuKdslwiLFwibGJyYWNlXCI6XCJ7XCIsXCJsYnJhY2tcIjpcIltcIixcImxicmtlXCI6XCLipotcIixcImxicmtzbGRcIjpcIuKmj1wiLFwibGJya3NsdVwiOlwi4qaNXCIsXCJMY2Fyb25cIjpcIsS9XCIsXCJsY2Fyb25cIjpcIsS+XCIsXCJMY2VkaWxcIjpcIsS7XCIsXCJsY2VkaWxcIjpcIsS8XCIsXCJsY2VpbFwiOlwi4oyIXCIsXCJsY3ViXCI6XCJ7XCIsXCJMY3lcIjpcItCbXCIsXCJsY3lcIjpcItC7XCIsXCJsZGNhXCI6XCLipLZcIixcImxkcXVvXCI6XCLigJxcIixcImxkcXVvclwiOlwi4oCeXCIsXCJsZHJkaGFyXCI6XCLipadcIixcImxkcnVzaGFyXCI6XCLipYtcIixcImxkc2hcIjpcIuKGslwiLFwibGVcIjpcIuKJpFwiLFwibEVcIjpcIuKJplwiLFwiTGVmdEFuZ2xlQnJhY2tldFwiOlwi4p+oXCIsXCJMZWZ0QXJyb3dCYXJcIjpcIuKHpFwiLFwibGVmdGFycm93XCI6XCLihpBcIixcIkxlZnRBcnJvd1wiOlwi4oaQXCIsXCJMZWZ0YXJyb3dcIjpcIuKHkFwiLFwiTGVmdEFycm93UmlnaHRBcnJvd1wiOlwi4oeGXCIsXCJsZWZ0YXJyb3d0YWlsXCI6XCLihqJcIixcIkxlZnRDZWlsaW5nXCI6XCLijIhcIixcIkxlZnREb3VibGVCcmFja2V0XCI6XCLin6ZcIixcIkxlZnREb3duVGVlVmVjdG9yXCI6XCLipaFcIixcIkxlZnREb3duVmVjdG9yQmFyXCI6XCLipZlcIixcIkxlZnREb3duVmVjdG9yXCI6XCLih4NcIixcIkxlZnRGbG9vclwiOlwi4oyKXCIsXCJsZWZ0aGFycG9vbmRvd25cIjpcIuKGvVwiLFwibGVmdGhhcnBvb251cFwiOlwi4oa8XCIsXCJsZWZ0bGVmdGFycm93c1wiOlwi4oeHXCIsXCJsZWZ0cmlnaHRhcnJvd1wiOlwi4oaUXCIsXCJMZWZ0UmlnaHRBcnJvd1wiOlwi4oaUXCIsXCJMZWZ0cmlnaHRhcnJvd1wiOlwi4oeUXCIsXCJsZWZ0cmlnaHRhcnJvd3NcIjpcIuKHhlwiLFwibGVmdHJpZ2h0aGFycG9vbnNcIjpcIuKHi1wiLFwibGVmdHJpZ2h0c3F1aWdhcnJvd1wiOlwi4oatXCIsXCJMZWZ0UmlnaHRWZWN0b3JcIjpcIuKljlwiLFwiTGVmdFRlZUFycm93XCI6XCLihqRcIixcIkxlZnRUZWVcIjpcIuKKo1wiLFwiTGVmdFRlZVZlY3RvclwiOlwi4qWaXCIsXCJsZWZ0dGhyZWV0aW1lc1wiOlwi4ouLXCIsXCJMZWZ0VHJpYW5nbGVCYXJcIjpcIuKnj1wiLFwiTGVmdFRyaWFuZ2xlXCI6XCLiirJcIixcIkxlZnRUcmlhbmdsZUVxdWFsXCI6XCLiirRcIixcIkxlZnRVcERvd25WZWN0b3JcIjpcIuKlkVwiLFwiTGVmdFVwVGVlVmVjdG9yXCI6XCLipaBcIixcIkxlZnRVcFZlY3RvckJhclwiOlwi4qWYXCIsXCJMZWZ0VXBWZWN0b3JcIjpcIuKGv1wiLFwiTGVmdFZlY3RvckJhclwiOlwi4qWSXCIsXCJMZWZ0VmVjdG9yXCI6XCLihrxcIixcImxFZ1wiOlwi4qqLXCIsXCJsZWdcIjpcIuKLmlwiLFwibGVxXCI6XCLiiaRcIixcImxlcXFcIjpcIuKJplwiLFwibGVxc2xhbnRcIjpcIuKpvVwiLFwibGVzY2NcIjpcIuKqqFwiLFwibGVzXCI6XCLiqb1cIixcImxlc2RvdFwiOlwi4qm/XCIsXCJsZXNkb3RvXCI6XCLiqoFcIixcImxlc2RvdG9yXCI6XCLiqoNcIixcImxlc2dcIjpcIuKLmu+4gFwiLFwibGVzZ2VzXCI6XCLiqpNcIixcImxlc3NhcHByb3hcIjpcIuKqhVwiLFwibGVzc2RvdFwiOlwi4ouWXCIsXCJsZXNzZXFndHJcIjpcIuKLmlwiLFwibGVzc2VxcWd0clwiOlwi4qqLXCIsXCJMZXNzRXF1YWxHcmVhdGVyXCI6XCLii5pcIixcIkxlc3NGdWxsRXF1YWxcIjpcIuKJplwiLFwiTGVzc0dyZWF0ZXJcIjpcIuKJtlwiLFwibGVzc2d0clwiOlwi4om2XCIsXCJMZXNzTGVzc1wiOlwi4qqhXCIsXCJsZXNzc2ltXCI6XCLiibJcIixcIkxlc3NTbGFudEVxdWFsXCI6XCLiqb1cIixcIkxlc3NUaWxkZVwiOlwi4omyXCIsXCJsZmlzaHRcIjpcIuKlvFwiLFwibGZsb29yXCI6XCLijIpcIixcIkxmclwiOlwi8J2Uj1wiLFwibGZyXCI6XCLwnZSpXCIsXCJsZ1wiOlwi4om2XCIsXCJsZ0VcIjpcIuKqkVwiLFwibEhhclwiOlwi4qWiXCIsXCJsaGFyZFwiOlwi4oa9XCIsXCJsaGFydVwiOlwi4oa8XCIsXCJsaGFydWxcIjpcIuKlqlwiLFwibGhibGtcIjpcIuKWhFwiLFwiTEpjeVwiOlwi0IlcIixcImxqY3lcIjpcItGZXCIsXCJsbGFyclwiOlwi4oeHXCIsXCJsbFwiOlwi4omqXCIsXCJMbFwiOlwi4ouYXCIsXCJsbGNvcm5lclwiOlwi4oyeXCIsXCJMbGVmdGFycm93XCI6XCLih5pcIixcImxsaGFyZFwiOlwi4qWrXCIsXCJsbHRyaVwiOlwi4pe6XCIsXCJMbWlkb3RcIjpcIsS/XCIsXCJsbWlkb3RcIjpcIsWAXCIsXCJsbW91c3RhY2hlXCI6XCLijrBcIixcImxtb3VzdFwiOlwi4o6wXCIsXCJsbmFwXCI6XCLiqolcIixcImxuYXBwcm94XCI6XCLiqolcIixcImxuZVwiOlwi4qqHXCIsXCJsbkVcIjpcIuKJqFwiLFwibG5lcVwiOlwi4qqHXCIsXCJsbmVxcVwiOlwi4omoXCIsXCJsbnNpbVwiOlwi4oumXCIsXCJsb2FuZ1wiOlwi4p+sXCIsXCJsb2FyclwiOlwi4oe9XCIsXCJsb2Jya1wiOlwi4p+mXCIsXCJsb25nbGVmdGFycm93XCI6XCLin7VcIixcIkxvbmdMZWZ0QXJyb3dcIjpcIuKftVwiLFwiTG9uZ2xlZnRhcnJvd1wiOlwi4p+4XCIsXCJsb25nbGVmdHJpZ2h0YXJyb3dcIjpcIuKft1wiLFwiTG9uZ0xlZnRSaWdodEFycm93XCI6XCLin7dcIixcIkxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwi4p+6XCIsXCJsb25nbWFwc3RvXCI6XCLin7xcIixcImxvbmdyaWdodGFycm93XCI6XCLin7ZcIixcIkxvbmdSaWdodEFycm93XCI6XCLin7ZcIixcIkxvbmdyaWdodGFycm93XCI6XCLin7lcIixcImxvb3BhcnJvd2xlZnRcIjpcIuKGq1wiLFwibG9vcGFycm93cmlnaHRcIjpcIuKGrFwiLFwibG9wYXJcIjpcIuKmhVwiLFwiTG9wZlwiOlwi8J2Vg1wiLFwibG9wZlwiOlwi8J2VnVwiLFwibG9wbHVzXCI6XCLiqK1cIixcImxvdGltZXNcIjpcIuKotFwiLFwibG93YXN0XCI6XCLiiJdcIixcImxvd2JhclwiOlwiX1wiLFwiTG93ZXJMZWZ0QXJyb3dcIjpcIuKGmVwiLFwiTG93ZXJSaWdodEFycm93XCI6XCLihphcIixcImxvelwiOlwi4peKXCIsXCJsb3plbmdlXCI6XCLil4pcIixcImxvemZcIjpcIuKnq1wiLFwibHBhclwiOlwiKFwiLFwibHBhcmx0XCI6XCLippNcIixcImxyYXJyXCI6XCLih4ZcIixcImxyY29ybmVyXCI6XCLijJ9cIixcImxyaGFyXCI6XCLih4tcIixcImxyaGFyZFwiOlwi4qWtXCIsXCJscm1cIjpcIuKAjlwiLFwibHJ0cmlcIjpcIuKKv1wiLFwibHNhcXVvXCI6XCLigLlcIixcImxzY3JcIjpcIvCdk4FcIixcIkxzY3JcIjpcIuKEklwiLFwibHNoXCI6XCLihrBcIixcIkxzaFwiOlwi4oawXCIsXCJsc2ltXCI6XCLiibJcIixcImxzaW1lXCI6XCLiqo1cIixcImxzaW1nXCI6XCLiqo9cIixcImxzcWJcIjpcIltcIixcImxzcXVvXCI6XCLigJhcIixcImxzcXVvclwiOlwi4oCaXCIsXCJMc3Ryb2tcIjpcIsWBXCIsXCJsc3Ryb2tcIjpcIsWCXCIsXCJsdGNjXCI6XCLiqqZcIixcImx0Y2lyXCI6XCLiqblcIixcImx0XCI6XCI8XCIsXCJMVFwiOlwiPFwiLFwiTHRcIjpcIuKJqlwiLFwibHRkb3RcIjpcIuKLllwiLFwibHRocmVlXCI6XCLii4tcIixcImx0aW1lc1wiOlwi4ouJXCIsXCJsdGxhcnJcIjpcIuKltlwiLFwibHRxdWVzdFwiOlwi4qm7XCIsXCJsdHJpXCI6XCLil4NcIixcImx0cmllXCI6XCLiirRcIixcImx0cmlmXCI6XCLil4JcIixcImx0clBhclwiOlwi4qaWXCIsXCJsdXJkc2hhclwiOlwi4qWKXCIsXCJsdXJ1aGFyXCI6XCLipaZcIixcImx2ZXJ0bmVxcVwiOlwi4omo77iAXCIsXCJsdm5FXCI6XCLiiajvuIBcIixcIm1hY3JcIjpcIsKvXCIsXCJtYWxlXCI6XCLimYJcIixcIm1hbHRcIjpcIuKcoFwiLFwibWFsdGVzZVwiOlwi4pygXCIsXCJNYXBcIjpcIuKkhVwiLFwibWFwXCI6XCLihqZcIixcIm1hcHN0b1wiOlwi4oamXCIsXCJtYXBzdG9kb3duXCI6XCLihqdcIixcIm1hcHN0b2xlZnRcIjpcIuKGpFwiLFwibWFwc3RvdXBcIjpcIuKGpVwiLFwibWFya2VyXCI6XCLilq5cIixcIm1jb21tYVwiOlwi4qipXCIsXCJNY3lcIjpcItCcXCIsXCJtY3lcIjpcItC8XCIsXCJtZGFzaFwiOlwi4oCUXCIsXCJtRERvdFwiOlwi4oi6XCIsXCJtZWFzdXJlZGFuZ2xlXCI6XCLiiKFcIixcIk1lZGl1bVNwYWNlXCI6XCLigZ9cIixcIk1lbGxpbnRyZlwiOlwi4oSzXCIsXCJNZnJcIjpcIvCdlJBcIixcIm1mclwiOlwi8J2UqlwiLFwibWhvXCI6XCLihKdcIixcIm1pY3JvXCI6XCLCtVwiLFwibWlkYXN0XCI6XCIqXCIsXCJtaWRjaXJcIjpcIuKrsFwiLFwibWlkXCI6XCLiiKNcIixcIm1pZGRvdFwiOlwiwrdcIixcIm1pbnVzYlwiOlwi4oqfXCIsXCJtaW51c1wiOlwi4oiSXCIsXCJtaW51c2RcIjpcIuKIuFwiLFwibWludXNkdVwiOlwi4qiqXCIsXCJNaW51c1BsdXNcIjpcIuKIk1wiLFwibWxjcFwiOlwi4qubXCIsXCJtbGRyXCI6XCLigKZcIixcIm1ucGx1c1wiOlwi4oiTXCIsXCJtb2RlbHNcIjpcIuKKp1wiLFwiTW9wZlwiOlwi8J2VhFwiLFwibW9wZlwiOlwi8J2VnlwiLFwibXBcIjpcIuKIk1wiLFwibXNjclwiOlwi8J2TglwiLFwiTXNjclwiOlwi4oSzXCIsXCJtc3Rwb3NcIjpcIuKIvlwiLFwiTXVcIjpcIs6cXCIsXCJtdVwiOlwizrxcIixcIm11bHRpbWFwXCI6XCLiirhcIixcIm11bWFwXCI6XCLiirhcIixcIm5hYmxhXCI6XCLiiIdcIixcIk5hY3V0ZVwiOlwixYNcIixcIm5hY3V0ZVwiOlwixYRcIixcIm5hbmdcIjpcIuKIoOKDklwiLFwibmFwXCI6XCLiiYlcIixcIm5hcEVcIjpcIuKpsMy4XCIsXCJuYXBpZFwiOlwi4omLzLhcIixcIm5hcG9zXCI6XCLFiVwiLFwibmFwcHJveFwiOlwi4omJXCIsXCJuYXR1cmFsXCI6XCLima5cIixcIm5hdHVyYWxzXCI6XCLihJVcIixcIm5hdHVyXCI6XCLima5cIixcIm5ic3BcIjpcIsKgXCIsXCJuYnVtcFwiOlwi4omOzLhcIixcIm5idW1wZVwiOlwi4omPzLhcIixcIm5jYXBcIjpcIuKpg1wiLFwiTmNhcm9uXCI6XCLFh1wiLFwibmNhcm9uXCI6XCLFiFwiLFwiTmNlZGlsXCI6XCLFhVwiLFwibmNlZGlsXCI6XCLFhlwiLFwibmNvbmdcIjpcIuKJh1wiLFwibmNvbmdkb3RcIjpcIuKprcy4XCIsXCJuY3VwXCI6XCLiqYJcIixcIk5jeVwiOlwi0J1cIixcIm5jeVwiOlwi0L1cIixcIm5kYXNoXCI6XCLigJNcIixcIm5lYXJoa1wiOlwi4qSkXCIsXCJuZWFyclwiOlwi4oaXXCIsXCJuZUFyclwiOlwi4oeXXCIsXCJuZWFycm93XCI6XCLihpdcIixcIm5lXCI6XCLiiaBcIixcIm5lZG90XCI6XCLiiZDMuFwiLFwiTmVnYXRpdmVNZWRpdW1TcGFjZVwiOlwi4oCLXCIsXCJOZWdhdGl2ZVRoaWNrU3BhY2VcIjpcIuKAi1wiLFwiTmVnYXRpdmVUaGluU3BhY2VcIjpcIuKAi1wiLFwiTmVnYXRpdmVWZXJ5VGhpblNwYWNlXCI6XCLigItcIixcIm5lcXVpdlwiOlwi4omiXCIsXCJuZXNlYXJcIjpcIuKkqFwiLFwibmVzaW1cIjpcIuKJgsy4XCIsXCJOZXN0ZWRHcmVhdGVyR3JlYXRlclwiOlwi4omrXCIsXCJOZXN0ZWRMZXNzTGVzc1wiOlwi4omqXCIsXCJOZXdMaW5lXCI6XCJcXG5cIixcIm5leGlzdFwiOlwi4oiEXCIsXCJuZXhpc3RzXCI6XCLiiIRcIixcIk5mclwiOlwi8J2UkVwiLFwibmZyXCI6XCLwnZSrXCIsXCJuZ0VcIjpcIuKJp8y4XCIsXCJuZ2VcIjpcIuKJsVwiLFwibmdlcVwiOlwi4omxXCIsXCJuZ2VxcVwiOlwi4omnzLhcIixcIm5nZXFzbGFudFwiOlwi4qm+zLhcIixcIm5nZXNcIjpcIuKpvsy4XCIsXCJuR2dcIjpcIuKLmcy4XCIsXCJuZ3NpbVwiOlwi4om1XCIsXCJuR3RcIjpcIuKJq+KDklwiLFwibmd0XCI6XCLiia9cIixcIm5ndHJcIjpcIuKJr1wiLFwibkd0dlwiOlwi4omrzLhcIixcIm5oYXJyXCI6XCLihq5cIixcIm5oQXJyXCI6XCLih45cIixcIm5ocGFyXCI6XCLiq7JcIixcIm5pXCI6XCLiiItcIixcIm5pc1wiOlwi4ou8XCIsXCJuaXNkXCI6XCLii7pcIixcIm5pdlwiOlwi4oiLXCIsXCJOSmN5XCI6XCLQilwiLFwibmpjeVwiOlwi0ZpcIixcIm5sYXJyXCI6XCLihppcIixcIm5sQXJyXCI6XCLih41cIixcIm5sZHJcIjpcIuKApVwiLFwibmxFXCI6XCLiiabMuFwiLFwibmxlXCI6XCLiibBcIixcIm5sZWZ0YXJyb3dcIjpcIuKGmlwiLFwibkxlZnRhcnJvd1wiOlwi4oeNXCIsXCJubGVmdHJpZ2h0YXJyb3dcIjpcIuKGrlwiLFwibkxlZnRyaWdodGFycm93XCI6XCLih45cIixcIm5sZXFcIjpcIuKJsFwiLFwibmxlcXFcIjpcIuKJpsy4XCIsXCJubGVxc2xhbnRcIjpcIuKpvcy4XCIsXCJubGVzXCI6XCLiqb3MuFwiLFwibmxlc3NcIjpcIuKJrlwiLFwibkxsXCI6XCLii5jMuFwiLFwibmxzaW1cIjpcIuKJtFwiLFwibkx0XCI6XCLiiarig5JcIixcIm5sdFwiOlwi4omuXCIsXCJubHRyaVwiOlwi4ouqXCIsXCJubHRyaWVcIjpcIuKLrFwiLFwibkx0dlwiOlwi4omqzLhcIixcIm5taWRcIjpcIuKIpFwiLFwiTm9CcmVha1wiOlwi4oGgXCIsXCJOb25CcmVha2luZ1NwYWNlXCI6XCLCoFwiLFwibm9wZlwiOlwi8J2Vn1wiLFwiTm9wZlwiOlwi4oSVXCIsXCJOb3RcIjpcIuKrrFwiLFwibm90XCI6XCLCrFwiLFwiTm90Q29uZ3J1ZW50XCI6XCLiiaJcIixcIk5vdEN1cENhcFwiOlwi4omtXCIsXCJOb3REb3VibGVWZXJ0aWNhbEJhclwiOlwi4oimXCIsXCJOb3RFbGVtZW50XCI6XCLiiIlcIixcIk5vdEVxdWFsXCI6XCLiiaBcIixcIk5vdEVxdWFsVGlsZGVcIjpcIuKJgsy4XCIsXCJOb3RFeGlzdHNcIjpcIuKIhFwiLFwiTm90R3JlYXRlclwiOlwi4omvXCIsXCJOb3RHcmVhdGVyRXF1YWxcIjpcIuKJsVwiLFwiTm90R3JlYXRlckZ1bGxFcXVhbFwiOlwi4omnzLhcIixcIk5vdEdyZWF0ZXJHcmVhdGVyXCI6XCLiiavMuFwiLFwiTm90R3JlYXRlckxlc3NcIjpcIuKJuVwiLFwiTm90R3JlYXRlclNsYW50RXF1YWxcIjpcIuKpvsy4XCIsXCJOb3RHcmVhdGVyVGlsZGVcIjpcIuKJtVwiLFwiTm90SHVtcERvd25IdW1wXCI6XCLiiY7MuFwiLFwiTm90SHVtcEVxdWFsXCI6XCLiiY/MuFwiLFwibm90aW5cIjpcIuKIiVwiLFwibm90aW5kb3RcIjpcIuKLtcy4XCIsXCJub3RpbkVcIjpcIuKLucy4XCIsXCJub3RpbnZhXCI6XCLiiIlcIixcIm5vdGludmJcIjpcIuKLt1wiLFwibm90aW52Y1wiOlwi4ou2XCIsXCJOb3RMZWZ0VHJpYW5nbGVCYXJcIjpcIuKnj8y4XCIsXCJOb3RMZWZ0VHJpYW5nbGVcIjpcIuKLqlwiLFwiTm90TGVmdFRyaWFuZ2xlRXF1YWxcIjpcIuKLrFwiLFwiTm90TGVzc1wiOlwi4omuXCIsXCJOb3RMZXNzRXF1YWxcIjpcIuKJsFwiLFwiTm90TGVzc0dyZWF0ZXJcIjpcIuKJuFwiLFwiTm90TGVzc0xlc3NcIjpcIuKJqsy4XCIsXCJOb3RMZXNzU2xhbnRFcXVhbFwiOlwi4qm9zLhcIixcIk5vdExlc3NUaWxkZVwiOlwi4om0XCIsXCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlclwiOlwi4qqizLhcIixcIk5vdE5lc3RlZExlc3NMZXNzXCI6XCLiqqHMuFwiLFwibm90bmlcIjpcIuKIjFwiLFwibm90bml2YVwiOlwi4oiMXCIsXCJub3RuaXZiXCI6XCLii75cIixcIm5vdG5pdmNcIjpcIuKLvVwiLFwiTm90UHJlY2VkZXNcIjpcIuKKgFwiLFwiTm90UHJlY2VkZXNFcXVhbFwiOlwi4qqvzLhcIixcIk5vdFByZWNlZGVzU2xhbnRFcXVhbFwiOlwi4ougXCIsXCJOb3RSZXZlcnNlRWxlbWVudFwiOlwi4oiMXCIsXCJOb3RSaWdodFRyaWFuZ2xlQmFyXCI6XCLip5DMuFwiLFwiTm90UmlnaHRUcmlhbmdsZVwiOlwi4ourXCIsXCJOb3RSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIuKLrVwiLFwiTm90U3F1YXJlU3Vic2V0XCI6XCLiio/MuFwiLFwiTm90U3F1YXJlU3Vic2V0RXF1YWxcIjpcIuKLolwiLFwiTm90U3F1YXJlU3VwZXJzZXRcIjpcIuKKkMy4XCIsXCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCLii6NcIixcIk5vdFN1YnNldFwiOlwi4oqC4oOSXCIsXCJOb3RTdWJzZXRFcXVhbFwiOlwi4oqIXCIsXCJOb3RTdWNjZWVkc1wiOlwi4oqBXCIsXCJOb3RTdWNjZWVkc0VxdWFsXCI6XCLiqrDMuFwiLFwiTm90U3VjY2VlZHNTbGFudEVxdWFsXCI6XCLii6FcIixcIk5vdFN1Y2NlZWRzVGlsZGVcIjpcIuKJv8y4XCIsXCJOb3RTdXBlcnNldFwiOlwi4oqD4oOSXCIsXCJOb3RTdXBlcnNldEVxdWFsXCI6XCLiiolcIixcIk5vdFRpbGRlXCI6XCLiiYFcIixcIk5vdFRpbGRlRXF1YWxcIjpcIuKJhFwiLFwiTm90VGlsZGVGdWxsRXF1YWxcIjpcIuKJh1wiLFwiTm90VGlsZGVUaWxkZVwiOlwi4omJXCIsXCJOb3RWZXJ0aWNhbEJhclwiOlwi4oikXCIsXCJucGFyYWxsZWxcIjpcIuKIplwiLFwibnBhclwiOlwi4oimXCIsXCJucGFyc2xcIjpcIuKrveKDpVwiLFwibnBhcnRcIjpcIuKIgsy4XCIsXCJucG9saW50XCI6XCLiqJRcIixcIm5wclwiOlwi4oqAXCIsXCJucHJjdWVcIjpcIuKLoFwiLFwibnByZWNcIjpcIuKKgFwiLFwibnByZWNlcVwiOlwi4qqvzLhcIixcIm5wcmVcIjpcIuKqr8y4XCIsXCJucmFycmNcIjpcIuKks8y4XCIsXCJucmFyclwiOlwi4oabXCIsXCJuckFyclwiOlwi4oePXCIsXCJucmFycndcIjpcIuKGncy4XCIsXCJucmlnaHRhcnJvd1wiOlwi4oabXCIsXCJuUmlnaHRhcnJvd1wiOlwi4oePXCIsXCJucnRyaVwiOlwi4ourXCIsXCJucnRyaWVcIjpcIuKLrVwiLFwibnNjXCI6XCLiioFcIixcIm5zY2N1ZVwiOlwi4ouhXCIsXCJuc2NlXCI6XCLiqrDMuFwiLFwiTnNjclwiOlwi8J2SqVwiLFwibnNjclwiOlwi8J2Tg1wiLFwibnNob3J0bWlkXCI6XCLiiKRcIixcIm5zaG9ydHBhcmFsbGVsXCI6XCLiiKZcIixcIm5zaW1cIjpcIuKJgVwiLFwibnNpbWVcIjpcIuKJhFwiLFwibnNpbWVxXCI6XCLiiYRcIixcIm5zbWlkXCI6XCLiiKRcIixcIm5zcGFyXCI6XCLiiKZcIixcIm5zcXN1YmVcIjpcIuKLolwiLFwibnNxc3VwZVwiOlwi4oujXCIsXCJuc3ViXCI6XCLiioRcIixcIm5zdWJFXCI6XCLiq4XMuFwiLFwibnN1YmVcIjpcIuKKiFwiLFwibnN1YnNldFwiOlwi4oqC4oOSXCIsXCJuc3Vic2V0ZXFcIjpcIuKKiFwiLFwibnN1YnNldGVxcVwiOlwi4quFzLhcIixcIm5zdWNjXCI6XCLiioFcIixcIm5zdWNjZXFcIjpcIuKqsMy4XCIsXCJuc3VwXCI6XCLiioVcIixcIm5zdXBFXCI6XCLiq4bMuFwiLFwibnN1cGVcIjpcIuKKiVwiLFwibnN1cHNldFwiOlwi4oqD4oOSXCIsXCJuc3Vwc2V0ZXFcIjpcIuKKiVwiLFwibnN1cHNldGVxcVwiOlwi4quGzLhcIixcIm50Z2xcIjpcIuKJuVwiLFwiTnRpbGRlXCI6XCLDkVwiLFwibnRpbGRlXCI6XCLDsVwiLFwibnRsZ1wiOlwi4om4XCIsXCJudHJpYW5nbGVsZWZ0XCI6XCLii6pcIixcIm50cmlhbmdsZWxlZnRlcVwiOlwi4ousXCIsXCJudHJpYW5nbGVyaWdodFwiOlwi4ourXCIsXCJudHJpYW5nbGVyaWdodGVxXCI6XCLii61cIixcIk51XCI6XCLOnVwiLFwibnVcIjpcIs69XCIsXCJudW1cIjpcIiNcIixcIm51bWVyb1wiOlwi4oSWXCIsXCJudW1zcFwiOlwi4oCHXCIsXCJudmFwXCI6XCLiiY3ig5JcIixcIm52ZGFzaFwiOlwi4oqsXCIsXCJudkRhc2hcIjpcIuKKrVwiLFwiblZkYXNoXCI6XCLiiq5cIixcIm5WRGFzaFwiOlwi4oqvXCIsXCJudmdlXCI6XCLiiaXig5JcIixcIm52Z3RcIjpcIj7ig5JcIixcIm52SGFyclwiOlwi4qSEXCIsXCJudmluZmluXCI6XCLip55cIixcIm52bEFyclwiOlwi4qSCXCIsXCJudmxlXCI6XCLiiaTig5JcIixcIm52bHRcIjpcIjzig5JcIixcIm52bHRyaWVcIjpcIuKKtOKDklwiLFwibnZyQXJyXCI6XCLipINcIixcIm52cnRyaWVcIjpcIuKKteKDklwiLFwibnZzaW1cIjpcIuKIvOKDklwiLFwibndhcmhrXCI6XCLipKNcIixcIm53YXJyXCI6XCLihpZcIixcIm53QXJyXCI6XCLih5ZcIixcIm53YXJyb3dcIjpcIuKGllwiLFwibnduZWFyXCI6XCLipKdcIixcIk9hY3V0ZVwiOlwiw5NcIixcIm9hY3V0ZVwiOlwiw7NcIixcIm9hc3RcIjpcIuKKm1wiLFwiT2NpcmNcIjpcIsOUXCIsXCJvY2lyY1wiOlwiw7RcIixcIm9jaXJcIjpcIuKKmlwiLFwiT2N5XCI6XCLQnlwiLFwib2N5XCI6XCLQvlwiLFwib2Rhc2hcIjpcIuKKnVwiLFwiT2RibGFjXCI6XCLFkFwiLFwib2RibGFjXCI6XCLFkVwiLFwib2RpdlwiOlwi4qi4XCIsXCJvZG90XCI6XCLiiplcIixcIm9kc29sZFwiOlwi4qa8XCIsXCJPRWxpZ1wiOlwixZJcIixcIm9lbGlnXCI6XCLFk1wiLFwib2ZjaXJcIjpcIuKmv1wiLFwiT2ZyXCI6XCLwnZSSXCIsXCJvZnJcIjpcIvCdlKxcIixcIm9nb25cIjpcIsubXCIsXCJPZ3JhdmVcIjpcIsOSXCIsXCJvZ3JhdmVcIjpcIsOyXCIsXCJvZ3RcIjpcIuKngVwiLFwib2hiYXJcIjpcIuKmtVwiLFwib2htXCI6XCLOqVwiLFwib2ludFwiOlwi4oiuXCIsXCJvbGFyclwiOlwi4oa6XCIsXCJvbGNpclwiOlwi4qa+XCIsXCJvbGNyb3NzXCI6XCLiprtcIixcIm9saW5lXCI6XCLigL5cIixcIm9sdFwiOlwi4qeAXCIsXCJPbWFjclwiOlwixYxcIixcIm9tYWNyXCI6XCLFjVwiLFwiT21lZ2FcIjpcIs6pXCIsXCJvbWVnYVwiOlwiz4lcIixcIk9taWNyb25cIjpcIs6fXCIsXCJvbWljcm9uXCI6XCLOv1wiLFwib21pZFwiOlwi4qa2XCIsXCJvbWludXNcIjpcIuKKllwiLFwiT29wZlwiOlwi8J2VhlwiLFwib29wZlwiOlwi8J2VoFwiLFwib3BhclwiOlwi4qa3XCIsXCJPcGVuQ3VybHlEb3VibGVRdW90ZVwiOlwi4oCcXCIsXCJPcGVuQ3VybHlRdW90ZVwiOlwi4oCYXCIsXCJvcGVycFwiOlwi4qa5XCIsXCJvcGx1c1wiOlwi4oqVXCIsXCJvcmFyclwiOlwi4oa7XCIsXCJPclwiOlwi4qmUXCIsXCJvclwiOlwi4oioXCIsXCJvcmRcIjpcIuKpnVwiLFwib3JkZXJcIjpcIuKEtFwiLFwib3JkZXJvZlwiOlwi4oS0XCIsXCJvcmRmXCI6XCLCqlwiLFwib3JkbVwiOlwiwrpcIixcIm9yaWdvZlwiOlwi4oq2XCIsXCJvcm9yXCI6XCLiqZZcIixcIm9yc2xvcGVcIjpcIuKpl1wiLFwib3J2XCI6XCLiqZtcIixcIm9TXCI6XCLik4hcIixcIk9zY3JcIjpcIvCdkqpcIixcIm9zY3JcIjpcIuKEtFwiLFwiT3NsYXNoXCI6XCLDmFwiLFwib3NsYXNoXCI6XCLDuFwiLFwib3NvbFwiOlwi4oqYXCIsXCJPdGlsZGVcIjpcIsOVXCIsXCJvdGlsZGVcIjpcIsO1XCIsXCJvdGltZXNhc1wiOlwi4qi2XCIsXCJPdGltZXNcIjpcIuKot1wiLFwib3RpbWVzXCI6XCLiipdcIixcIk91bWxcIjpcIsOWXCIsXCJvdW1sXCI6XCLDtlwiLFwib3ZiYXJcIjpcIuKMvVwiLFwiT3ZlckJhclwiOlwi4oC+XCIsXCJPdmVyQnJhY2VcIjpcIuKPnlwiLFwiT3ZlckJyYWNrZXRcIjpcIuKOtFwiLFwiT3ZlclBhcmVudGhlc2lzXCI6XCLij5xcIixcInBhcmFcIjpcIsK2XCIsXCJwYXJhbGxlbFwiOlwi4oilXCIsXCJwYXJcIjpcIuKIpVwiLFwicGFyc2ltXCI6XCLiq7NcIixcInBhcnNsXCI6XCLiq71cIixcInBhcnRcIjpcIuKIglwiLFwiUGFydGlhbERcIjpcIuKIglwiLFwiUGN5XCI6XCLQn1wiLFwicGN5XCI6XCLQv1wiLFwicGVyY250XCI6XCIlXCIsXCJwZXJpb2RcIjpcIi5cIixcInBlcm1pbFwiOlwi4oCwXCIsXCJwZXJwXCI6XCLiiqVcIixcInBlcnRlbmtcIjpcIuKAsVwiLFwiUGZyXCI6XCLwnZSTXCIsXCJwZnJcIjpcIvCdlK1cIixcIlBoaVwiOlwizqZcIixcInBoaVwiOlwiz4ZcIixcInBoaXZcIjpcIs+VXCIsXCJwaG1tYXRcIjpcIuKEs1wiLFwicGhvbmVcIjpcIuKYjlwiLFwiUGlcIjpcIs6gXCIsXCJwaVwiOlwiz4BcIixcInBpdGNoZm9ya1wiOlwi4ouUXCIsXCJwaXZcIjpcIs+WXCIsXCJwbGFuY2tcIjpcIuKEj1wiLFwicGxhbmNraFwiOlwi4oSOXCIsXCJwbGFua3ZcIjpcIuKEj1wiLFwicGx1c2FjaXJcIjpcIuKoo1wiLFwicGx1c2JcIjpcIuKKnlwiLFwicGx1c2NpclwiOlwi4qiiXCIsXCJwbHVzXCI6XCIrXCIsXCJwbHVzZG9cIjpcIuKIlFwiLFwicGx1c2R1XCI6XCLiqKVcIixcInBsdXNlXCI6XCLiqbJcIixcIlBsdXNNaW51c1wiOlwiwrFcIixcInBsdXNtblwiOlwiwrFcIixcInBsdXNzaW1cIjpcIuKoplwiLFwicGx1c3R3b1wiOlwi4qinXCIsXCJwbVwiOlwiwrFcIixcIlBvaW5jYXJlcGxhbmVcIjpcIuKEjFwiLFwicG9pbnRpbnRcIjpcIuKolVwiLFwicG9wZlwiOlwi8J2VoVwiLFwiUG9wZlwiOlwi4oSZXCIsXCJwb3VuZFwiOlwiwqNcIixcInByYXBcIjpcIuKqt1wiLFwiUHJcIjpcIuKqu1wiLFwicHJcIjpcIuKJulwiLFwicHJjdWVcIjpcIuKJvFwiLFwicHJlY2FwcHJveFwiOlwi4qq3XCIsXCJwcmVjXCI6XCLiibpcIixcInByZWNjdXJseWVxXCI6XCLiibxcIixcIlByZWNlZGVzXCI6XCLiibpcIixcIlByZWNlZGVzRXF1YWxcIjpcIuKqr1wiLFwiUHJlY2VkZXNTbGFudEVxdWFsXCI6XCLiibxcIixcIlByZWNlZGVzVGlsZGVcIjpcIuKJvlwiLFwicHJlY2VxXCI6XCLiqq9cIixcInByZWNuYXBwcm94XCI6XCLiqrlcIixcInByZWNuZXFxXCI6XCLiqrVcIixcInByZWNuc2ltXCI6XCLii6hcIixcInByZVwiOlwi4qqvXCIsXCJwckVcIjpcIuKqs1wiLFwicHJlY3NpbVwiOlwi4om+XCIsXCJwcmltZVwiOlwi4oCyXCIsXCJQcmltZVwiOlwi4oCzXCIsXCJwcmltZXNcIjpcIuKEmVwiLFwicHJuYXBcIjpcIuKquVwiLFwicHJuRVwiOlwi4qq1XCIsXCJwcm5zaW1cIjpcIuKLqFwiLFwicHJvZFwiOlwi4oiPXCIsXCJQcm9kdWN0XCI6XCLiiI9cIixcInByb2ZhbGFyXCI6XCLijK5cIixcInByb2ZsaW5lXCI6XCLijJJcIixcInByb2ZzdXJmXCI6XCLijJNcIixcInByb3BcIjpcIuKInVwiLFwiUHJvcG9ydGlvbmFsXCI6XCLiiJ1cIixcIlByb3BvcnRpb25cIjpcIuKIt1wiLFwicHJvcHRvXCI6XCLiiJ1cIixcInByc2ltXCI6XCLiib5cIixcInBydXJlbFwiOlwi4oqwXCIsXCJQc2NyXCI6XCLwnZKrXCIsXCJwc2NyXCI6XCLwnZOFXCIsXCJQc2lcIjpcIs6oXCIsXCJwc2lcIjpcIs+IXCIsXCJwdW5jc3BcIjpcIuKAiFwiLFwiUWZyXCI6XCLwnZSUXCIsXCJxZnJcIjpcIvCdlK5cIixcInFpbnRcIjpcIuKojFwiLFwicW9wZlwiOlwi8J2VolwiLFwiUW9wZlwiOlwi4oSaXCIsXCJxcHJpbWVcIjpcIuKBl1wiLFwiUXNjclwiOlwi8J2SrFwiLFwicXNjclwiOlwi8J2ThlwiLFwicXVhdGVybmlvbnNcIjpcIuKEjVwiLFwicXVhdGludFwiOlwi4qiWXCIsXCJxdWVzdFwiOlwiP1wiLFwicXVlc3RlcVwiOlwi4omfXCIsXCJxdW90XCI6XCJcXFwiXCIsXCJRVU9UXCI6XCJcXFwiXCIsXCJyQWFyclwiOlwi4oebXCIsXCJyYWNlXCI6XCLiiL3MsVwiLFwiUmFjdXRlXCI6XCLFlFwiLFwicmFjdXRlXCI6XCLFlVwiLFwicmFkaWNcIjpcIuKImlwiLFwicmFlbXB0eXZcIjpcIuKms1wiLFwicmFuZ1wiOlwi4p+pXCIsXCJSYW5nXCI6XCLin6tcIixcInJhbmdkXCI6XCLippJcIixcInJhbmdlXCI6XCLipqVcIixcInJhbmdsZVwiOlwi4p+pXCIsXCJyYXF1b1wiOlwiwrtcIixcInJhcnJhcFwiOlwi4qW1XCIsXCJyYXJyYlwiOlwi4oelXCIsXCJyYXJyYmZzXCI6XCLipKBcIixcInJhcnJjXCI6XCLipLNcIixcInJhcnJcIjpcIuKGklwiLFwiUmFyclwiOlwi4oagXCIsXCJyQXJyXCI6XCLih5JcIixcInJhcnJmc1wiOlwi4qSeXCIsXCJyYXJyaGtcIjpcIuKGqlwiLFwicmFycmxwXCI6XCLihqxcIixcInJhcnJwbFwiOlwi4qWFXCIsXCJyYXJyc2ltXCI6XCLipbRcIixcIlJhcnJ0bFwiOlwi4qSWXCIsXCJyYXJydGxcIjpcIuKGo1wiLFwicmFycndcIjpcIuKGnVwiLFwicmF0YWlsXCI6XCLipJpcIixcInJBdGFpbFwiOlwi4qScXCIsXCJyYXRpb1wiOlwi4oi2XCIsXCJyYXRpb25hbHNcIjpcIuKEmlwiLFwicmJhcnJcIjpcIuKkjVwiLFwickJhcnJcIjpcIuKkj1wiLFwiUkJhcnJcIjpcIuKkkFwiLFwicmJicmtcIjpcIuKds1wiLFwicmJyYWNlXCI6XCJ9XCIsXCJyYnJhY2tcIjpcIl1cIixcInJicmtlXCI6XCLipoxcIixcInJicmtzbGRcIjpcIuKmjlwiLFwicmJya3NsdVwiOlwi4qaQXCIsXCJSY2Fyb25cIjpcIsWYXCIsXCJyY2Fyb25cIjpcIsWZXCIsXCJSY2VkaWxcIjpcIsWWXCIsXCJyY2VkaWxcIjpcIsWXXCIsXCJyY2VpbFwiOlwi4oyJXCIsXCJyY3ViXCI6XCJ9XCIsXCJSY3lcIjpcItCgXCIsXCJyY3lcIjpcItGAXCIsXCJyZGNhXCI6XCLipLdcIixcInJkbGRoYXJcIjpcIuKlqVwiLFwicmRxdW9cIjpcIuKAnVwiLFwicmRxdW9yXCI6XCLigJ1cIixcInJkc2hcIjpcIuKGs1wiLFwicmVhbFwiOlwi4oScXCIsXCJyZWFsaW5lXCI6XCLihJtcIixcInJlYWxwYXJ0XCI6XCLihJxcIixcInJlYWxzXCI6XCLihJ1cIixcIlJlXCI6XCLihJxcIixcInJlY3RcIjpcIuKWrVwiLFwicmVnXCI6XCLCrlwiLFwiUkVHXCI6XCLCrlwiLFwiUmV2ZXJzZUVsZW1lbnRcIjpcIuKIi1wiLFwiUmV2ZXJzZUVxdWlsaWJyaXVtXCI6XCLih4tcIixcIlJldmVyc2VVcEVxdWlsaWJyaXVtXCI6XCLipa9cIixcInJmaXNodFwiOlwi4qW9XCIsXCJyZmxvb3JcIjpcIuKMi1wiLFwicmZyXCI6XCLwnZSvXCIsXCJSZnJcIjpcIuKEnFwiLFwickhhclwiOlwi4qWkXCIsXCJyaGFyZFwiOlwi4oeBXCIsXCJyaGFydVwiOlwi4oeAXCIsXCJyaGFydWxcIjpcIuKlrFwiLFwiUmhvXCI6XCLOoVwiLFwicmhvXCI6XCLPgVwiLFwicmhvdlwiOlwiz7FcIixcIlJpZ2h0QW5nbGVCcmFja2V0XCI6XCLin6lcIixcIlJpZ2h0QXJyb3dCYXJcIjpcIuKHpVwiLFwicmlnaHRhcnJvd1wiOlwi4oaSXCIsXCJSaWdodEFycm93XCI6XCLihpJcIixcIlJpZ2h0YXJyb3dcIjpcIuKHklwiLFwiUmlnaHRBcnJvd0xlZnRBcnJvd1wiOlwi4oeEXCIsXCJyaWdodGFycm93dGFpbFwiOlwi4oajXCIsXCJSaWdodENlaWxpbmdcIjpcIuKMiVwiLFwiUmlnaHREb3VibGVCcmFja2V0XCI6XCLin6dcIixcIlJpZ2h0RG93blRlZVZlY3RvclwiOlwi4qWdXCIsXCJSaWdodERvd25WZWN0b3JCYXJcIjpcIuKllVwiLFwiUmlnaHREb3duVmVjdG9yXCI6XCLih4JcIixcIlJpZ2h0Rmxvb3JcIjpcIuKMi1wiLFwicmlnaHRoYXJwb29uZG93blwiOlwi4oeBXCIsXCJyaWdodGhhcnBvb251cFwiOlwi4oeAXCIsXCJyaWdodGxlZnRhcnJvd3NcIjpcIuKHhFwiLFwicmlnaHRsZWZ0aGFycG9vbnNcIjpcIuKHjFwiLFwicmlnaHRyaWdodGFycm93c1wiOlwi4oeJXCIsXCJyaWdodHNxdWlnYXJyb3dcIjpcIuKGnVwiLFwiUmlnaHRUZWVBcnJvd1wiOlwi4oamXCIsXCJSaWdodFRlZVwiOlwi4oqiXCIsXCJSaWdodFRlZVZlY3RvclwiOlwi4qWbXCIsXCJyaWdodHRocmVldGltZXNcIjpcIuKLjFwiLFwiUmlnaHRUcmlhbmdsZUJhclwiOlwi4qeQXCIsXCJSaWdodFRyaWFuZ2xlXCI6XCLiirNcIixcIlJpZ2h0VHJpYW5nbGVFcXVhbFwiOlwi4oq1XCIsXCJSaWdodFVwRG93blZlY3RvclwiOlwi4qWPXCIsXCJSaWdodFVwVGVlVmVjdG9yXCI6XCLipZxcIixcIlJpZ2h0VXBWZWN0b3JCYXJcIjpcIuKllFwiLFwiUmlnaHRVcFZlY3RvclwiOlwi4oa+XCIsXCJSaWdodFZlY3RvckJhclwiOlwi4qWTXCIsXCJSaWdodFZlY3RvclwiOlwi4oeAXCIsXCJyaW5nXCI6XCLLmlwiLFwicmlzaW5nZG90c2VxXCI6XCLiiZNcIixcInJsYXJyXCI6XCLih4RcIixcInJsaGFyXCI6XCLih4xcIixcInJsbVwiOlwi4oCPXCIsXCJybW91c3RhY2hlXCI6XCLijrFcIixcInJtb3VzdFwiOlwi4o6xXCIsXCJybm1pZFwiOlwi4quuXCIsXCJyb2FuZ1wiOlwi4p+tXCIsXCJyb2FyclwiOlwi4oe+XCIsXCJyb2Jya1wiOlwi4p+nXCIsXCJyb3BhclwiOlwi4qaGXCIsXCJyb3BmXCI6XCLwnZWjXCIsXCJSb3BmXCI6XCLihJ1cIixcInJvcGx1c1wiOlwi4qiuXCIsXCJyb3RpbWVzXCI6XCLiqLVcIixcIlJvdW5kSW1wbGllc1wiOlwi4qWwXCIsXCJycGFyXCI6XCIpXCIsXCJycGFyZ3RcIjpcIuKmlFwiLFwicnBwb2xpbnRcIjpcIuKoklwiLFwicnJhcnJcIjpcIuKHiVwiLFwiUnJpZ2h0YXJyb3dcIjpcIuKHm1wiLFwicnNhcXVvXCI6XCLigLpcIixcInJzY3JcIjpcIvCdk4dcIixcIlJzY3JcIjpcIuKEm1wiLFwicnNoXCI6XCLihrFcIixcIlJzaFwiOlwi4oaxXCIsXCJyc3FiXCI6XCJdXCIsXCJyc3F1b1wiOlwi4oCZXCIsXCJyc3F1b3JcIjpcIuKAmVwiLFwicnRocmVlXCI6XCLii4xcIixcInJ0aW1lc1wiOlwi4ouKXCIsXCJydHJpXCI6XCLilrlcIixcInJ0cmllXCI6XCLiirVcIixcInJ0cmlmXCI6XCLilrhcIixcInJ0cmlsdHJpXCI6XCLip45cIixcIlJ1bGVEZWxheWVkXCI6XCLip7RcIixcInJ1bHVoYXJcIjpcIuKlqFwiLFwicnhcIjpcIuKEnlwiLFwiU2FjdXRlXCI6XCLFmlwiLFwic2FjdXRlXCI6XCLFm1wiLFwic2JxdW9cIjpcIuKAmlwiLFwic2NhcFwiOlwi4qq4XCIsXCJTY2Fyb25cIjpcIsWgXCIsXCJzY2Fyb25cIjpcIsWhXCIsXCJTY1wiOlwi4qq8XCIsXCJzY1wiOlwi4om7XCIsXCJzY2N1ZVwiOlwi4om9XCIsXCJzY2VcIjpcIuKqsFwiLFwic2NFXCI6XCLiqrRcIixcIlNjZWRpbFwiOlwixZ5cIixcInNjZWRpbFwiOlwixZ9cIixcIlNjaXJjXCI6XCLFnFwiLFwic2NpcmNcIjpcIsWdXCIsXCJzY25hcFwiOlwi4qq6XCIsXCJzY25FXCI6XCLiqrZcIixcInNjbnNpbVwiOlwi4oupXCIsXCJzY3BvbGludFwiOlwi4qiTXCIsXCJzY3NpbVwiOlwi4om/XCIsXCJTY3lcIjpcItChXCIsXCJzY3lcIjpcItGBXCIsXCJzZG90YlwiOlwi4oqhXCIsXCJzZG90XCI6XCLii4VcIixcInNkb3RlXCI6XCLiqaZcIixcInNlYXJoa1wiOlwi4qSlXCIsXCJzZWFyclwiOlwi4oaYXCIsXCJzZUFyclwiOlwi4oeYXCIsXCJzZWFycm93XCI6XCLihphcIixcInNlY3RcIjpcIsKnXCIsXCJzZW1pXCI6XCI7XCIsXCJzZXN3YXJcIjpcIuKkqVwiLFwic2V0bWludXNcIjpcIuKIllwiLFwic2V0bW5cIjpcIuKIllwiLFwic2V4dFwiOlwi4py2XCIsXCJTZnJcIjpcIvCdlJZcIixcInNmclwiOlwi8J2UsFwiLFwic2Zyb3duXCI6XCLijKJcIixcInNoYXJwXCI6XCLima9cIixcIlNIQ0hjeVwiOlwi0KlcIixcInNoY2hjeVwiOlwi0YlcIixcIlNIY3lcIjpcItCoXCIsXCJzaGN5XCI6XCLRiFwiLFwiU2hvcnREb3duQXJyb3dcIjpcIuKGk1wiLFwiU2hvcnRMZWZ0QXJyb3dcIjpcIuKGkFwiLFwic2hvcnRtaWRcIjpcIuKIo1wiLFwic2hvcnRwYXJhbGxlbFwiOlwi4oilXCIsXCJTaG9ydFJpZ2h0QXJyb3dcIjpcIuKGklwiLFwiU2hvcnRVcEFycm93XCI6XCLihpFcIixcInNoeVwiOlwiwq1cIixcIlNpZ21hXCI6XCLOo1wiLFwic2lnbWFcIjpcIs+DXCIsXCJzaWdtYWZcIjpcIs+CXCIsXCJzaWdtYXZcIjpcIs+CXCIsXCJzaW1cIjpcIuKIvFwiLFwic2ltZG90XCI6XCLiqapcIixcInNpbWVcIjpcIuKJg1wiLFwic2ltZXFcIjpcIuKJg1wiLFwic2ltZ1wiOlwi4qqeXCIsXCJzaW1nRVwiOlwi4qqgXCIsXCJzaW1sXCI6XCLiqp1cIixcInNpbWxFXCI6XCLiqp9cIixcInNpbW5lXCI6XCLiiYZcIixcInNpbXBsdXNcIjpcIuKopFwiLFwic2ltcmFyclwiOlwi4qWyXCIsXCJzbGFyclwiOlwi4oaQXCIsXCJTbWFsbENpcmNsZVwiOlwi4oiYXCIsXCJzbWFsbHNldG1pbnVzXCI6XCLiiJZcIixcInNtYXNocFwiOlwi4qizXCIsXCJzbWVwYXJzbFwiOlwi4qekXCIsXCJzbWlkXCI6XCLiiKNcIixcInNtaWxlXCI6XCLijKNcIixcInNtdFwiOlwi4qqqXCIsXCJzbXRlXCI6XCLiqqxcIixcInNtdGVzXCI6XCLiqqzvuIBcIixcIlNPRlRjeVwiOlwi0KxcIixcInNvZnRjeVwiOlwi0YxcIixcInNvbGJhclwiOlwi4oy/XCIsXCJzb2xiXCI6XCLip4RcIixcInNvbFwiOlwiL1wiLFwiU29wZlwiOlwi8J2VilwiLFwic29wZlwiOlwi8J2VpFwiLFwic3BhZGVzXCI6XCLimaBcIixcInNwYWRlc3VpdFwiOlwi4pmgXCIsXCJzcGFyXCI6XCLiiKVcIixcInNxY2FwXCI6XCLiipNcIixcInNxY2Fwc1wiOlwi4oqT77iAXCIsXCJzcWN1cFwiOlwi4oqUXCIsXCJzcWN1cHNcIjpcIuKKlO+4gFwiLFwiU3FydFwiOlwi4oiaXCIsXCJzcXN1YlwiOlwi4oqPXCIsXCJzcXN1YmVcIjpcIuKKkVwiLFwic3FzdWJzZXRcIjpcIuKKj1wiLFwic3FzdWJzZXRlcVwiOlwi4oqRXCIsXCJzcXN1cFwiOlwi4oqQXCIsXCJzcXN1cGVcIjpcIuKKklwiLFwic3FzdXBzZXRcIjpcIuKKkFwiLFwic3FzdXBzZXRlcVwiOlwi4oqSXCIsXCJzcXVhcmVcIjpcIuKWoVwiLFwiU3F1YXJlXCI6XCLilqFcIixcIlNxdWFyZUludGVyc2VjdGlvblwiOlwi4oqTXCIsXCJTcXVhcmVTdWJzZXRcIjpcIuKKj1wiLFwiU3F1YXJlU3Vic2V0RXF1YWxcIjpcIuKKkVwiLFwiU3F1YXJlU3VwZXJzZXRcIjpcIuKKkFwiLFwiU3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwi4oqSXCIsXCJTcXVhcmVVbmlvblwiOlwi4oqUXCIsXCJzcXVhcmZcIjpcIuKWqlwiLFwic3F1XCI6XCLilqFcIixcInNxdWZcIjpcIuKWqlwiLFwic3JhcnJcIjpcIuKGklwiLFwiU3NjclwiOlwi8J2SrlwiLFwic3NjclwiOlwi8J2TiFwiLFwic3NldG1uXCI6XCLiiJZcIixcInNzbWlsZVwiOlwi4oyjXCIsXCJzc3RhcmZcIjpcIuKLhlwiLFwiU3RhclwiOlwi4ouGXCIsXCJzdGFyXCI6XCLimIZcIixcInN0YXJmXCI6XCLimIVcIixcInN0cmFpZ2h0ZXBzaWxvblwiOlwiz7VcIixcInN0cmFpZ2h0cGhpXCI6XCLPlVwiLFwic3RybnNcIjpcIsKvXCIsXCJzdWJcIjpcIuKKglwiLFwiU3ViXCI6XCLii5BcIixcInN1YmRvdFwiOlwi4qq9XCIsXCJzdWJFXCI6XCLiq4VcIixcInN1YmVcIjpcIuKKhlwiLFwic3ViZWRvdFwiOlwi4quDXCIsXCJzdWJtdWx0XCI6XCLiq4FcIixcInN1Ym5FXCI6XCLiq4tcIixcInN1Ym5lXCI6XCLiiopcIixcInN1YnBsdXNcIjpcIuKqv1wiLFwic3VicmFyclwiOlwi4qW5XCIsXCJzdWJzZXRcIjpcIuKKglwiLFwiU3Vic2V0XCI6XCLii5BcIixcInN1YnNldGVxXCI6XCLiioZcIixcInN1YnNldGVxcVwiOlwi4quFXCIsXCJTdWJzZXRFcXVhbFwiOlwi4oqGXCIsXCJzdWJzZXRuZXFcIjpcIuKKilwiLFwic3Vic2V0bmVxcVwiOlwi4quLXCIsXCJzdWJzaW1cIjpcIuKrh1wiLFwic3Vic3ViXCI6XCLiq5VcIixcInN1YnN1cFwiOlwi4quTXCIsXCJzdWNjYXBwcm94XCI6XCLiqrhcIixcInN1Y2NcIjpcIuKJu1wiLFwic3VjY2N1cmx5ZXFcIjpcIuKJvVwiLFwiU3VjY2VlZHNcIjpcIuKJu1wiLFwiU3VjY2VlZHNFcXVhbFwiOlwi4qqwXCIsXCJTdWNjZWVkc1NsYW50RXF1YWxcIjpcIuKJvVwiLFwiU3VjY2VlZHNUaWxkZVwiOlwi4om/XCIsXCJzdWNjZXFcIjpcIuKqsFwiLFwic3VjY25hcHByb3hcIjpcIuKqulwiLFwic3VjY25lcXFcIjpcIuKqtlwiLFwic3VjY25zaW1cIjpcIuKLqVwiLFwic3VjY3NpbVwiOlwi4om/XCIsXCJTdWNoVGhhdFwiOlwi4oiLXCIsXCJzdW1cIjpcIuKIkVwiLFwiU3VtXCI6XCLiiJFcIixcInN1bmdcIjpcIuKZqlwiLFwic3VwMVwiOlwiwrlcIixcInN1cDJcIjpcIsKyXCIsXCJzdXAzXCI6XCLCs1wiLFwic3VwXCI6XCLiioNcIixcIlN1cFwiOlwi4ouRXCIsXCJzdXBkb3RcIjpcIuKqvlwiLFwic3VwZHN1YlwiOlwi4quYXCIsXCJzdXBFXCI6XCLiq4ZcIixcInN1cGVcIjpcIuKKh1wiLFwic3VwZWRvdFwiOlwi4quEXCIsXCJTdXBlcnNldFwiOlwi4oqDXCIsXCJTdXBlcnNldEVxdWFsXCI6XCLiiodcIixcInN1cGhzb2xcIjpcIuKfiVwiLFwic3VwaHN1YlwiOlwi4quXXCIsXCJzdXBsYXJyXCI6XCLipbtcIixcInN1cG11bHRcIjpcIuKrglwiLFwic3VwbkVcIjpcIuKrjFwiLFwic3VwbmVcIjpcIuKKi1wiLFwic3VwcGx1c1wiOlwi4quAXCIsXCJzdXBzZXRcIjpcIuKKg1wiLFwiU3Vwc2V0XCI6XCLii5FcIixcInN1cHNldGVxXCI6XCLiiodcIixcInN1cHNldGVxcVwiOlwi4quGXCIsXCJzdXBzZXRuZXFcIjpcIuKKi1wiLFwic3Vwc2V0bmVxcVwiOlwi4quMXCIsXCJzdXBzaW1cIjpcIuKriFwiLFwic3Vwc3ViXCI6XCLiq5RcIixcInN1cHN1cFwiOlwi4quWXCIsXCJzd2FyaGtcIjpcIuKkplwiLFwic3dhcnJcIjpcIuKGmVwiLFwic3dBcnJcIjpcIuKHmVwiLFwic3dhcnJvd1wiOlwi4oaZXCIsXCJzd253YXJcIjpcIuKkqlwiLFwic3psaWdcIjpcIsOfXCIsXCJUYWJcIjpcIlxcdFwiLFwidGFyZ2V0XCI6XCLijJZcIixcIlRhdVwiOlwizqRcIixcInRhdVwiOlwiz4RcIixcInRicmtcIjpcIuKOtFwiLFwiVGNhcm9uXCI6XCLFpFwiLFwidGNhcm9uXCI6XCLFpVwiLFwiVGNlZGlsXCI6XCLFolwiLFwidGNlZGlsXCI6XCLFo1wiLFwiVGN5XCI6XCLQolwiLFwidGN5XCI6XCLRglwiLFwidGRvdFwiOlwi4oObXCIsXCJ0ZWxyZWNcIjpcIuKMlVwiLFwiVGZyXCI6XCLwnZSXXCIsXCJ0ZnJcIjpcIvCdlLFcIixcInRoZXJlNFwiOlwi4oi0XCIsXCJ0aGVyZWZvcmVcIjpcIuKItFwiLFwiVGhlcmVmb3JlXCI6XCLiiLRcIixcIlRoZXRhXCI6XCLOmFwiLFwidGhldGFcIjpcIs64XCIsXCJ0aGV0YXN5bVwiOlwiz5FcIixcInRoZXRhdlwiOlwiz5FcIixcInRoaWNrYXBwcm94XCI6XCLiiYhcIixcInRoaWNrc2ltXCI6XCLiiLxcIixcIlRoaWNrU3BhY2VcIjpcIuKBn+KAilwiLFwiVGhpblNwYWNlXCI6XCLigIlcIixcInRoaW5zcFwiOlwi4oCJXCIsXCJ0aGthcFwiOlwi4omIXCIsXCJ0aGtzaW1cIjpcIuKIvFwiLFwiVEhPUk5cIjpcIsOeXCIsXCJ0aG9yblwiOlwiw75cIixcInRpbGRlXCI6XCLLnFwiLFwiVGlsZGVcIjpcIuKIvFwiLFwiVGlsZGVFcXVhbFwiOlwi4omDXCIsXCJUaWxkZUZ1bGxFcXVhbFwiOlwi4omFXCIsXCJUaWxkZVRpbGRlXCI6XCLiiYhcIixcInRpbWVzYmFyXCI6XCLiqLFcIixcInRpbWVzYlwiOlwi4oqgXCIsXCJ0aW1lc1wiOlwiw5dcIixcInRpbWVzZFwiOlwi4qiwXCIsXCJ0aW50XCI6XCLiiK1cIixcInRvZWFcIjpcIuKkqFwiLFwidG9wYm90XCI6XCLijLZcIixcInRvcGNpclwiOlwi4quxXCIsXCJ0b3BcIjpcIuKKpFwiLFwiVG9wZlwiOlwi8J2Vi1wiLFwidG9wZlwiOlwi8J2VpVwiLFwidG9wZm9ya1wiOlwi4quaXCIsXCJ0b3NhXCI6XCLipKlcIixcInRwcmltZVwiOlwi4oC0XCIsXCJ0cmFkZVwiOlwi4oSiXCIsXCJUUkFERVwiOlwi4oSiXCIsXCJ0cmlhbmdsZVwiOlwi4pa1XCIsXCJ0cmlhbmdsZWRvd25cIjpcIuKWv1wiLFwidHJpYW5nbGVsZWZ0XCI6XCLil4NcIixcInRyaWFuZ2xlbGVmdGVxXCI6XCLiirRcIixcInRyaWFuZ2xlcVwiOlwi4omcXCIsXCJ0cmlhbmdsZXJpZ2h0XCI6XCLilrlcIixcInRyaWFuZ2xlcmlnaHRlcVwiOlwi4oq1XCIsXCJ0cmlkb3RcIjpcIuKXrFwiLFwidHJpZVwiOlwi4omcXCIsXCJ0cmltaW51c1wiOlwi4qi6XCIsXCJUcmlwbGVEb3RcIjpcIuKDm1wiLFwidHJpcGx1c1wiOlwi4qi5XCIsXCJ0cmlzYlwiOlwi4qeNXCIsXCJ0cml0aW1lXCI6XCLiqLtcIixcInRycGV6aXVtXCI6XCLij6JcIixcIlRzY3JcIjpcIvCdkq9cIixcInRzY3JcIjpcIvCdk4lcIixcIlRTY3lcIjpcItCmXCIsXCJ0c2N5XCI6XCLRhlwiLFwiVFNIY3lcIjpcItCLXCIsXCJ0c2hjeVwiOlwi0ZtcIixcIlRzdHJva1wiOlwixaZcIixcInRzdHJva1wiOlwixadcIixcInR3aXh0XCI6XCLiiaxcIixcInR3b2hlYWRsZWZ0YXJyb3dcIjpcIuKGnlwiLFwidHdvaGVhZHJpZ2h0YXJyb3dcIjpcIuKGoFwiLFwiVWFjdXRlXCI6XCLDmlwiLFwidWFjdXRlXCI6XCLDulwiLFwidWFyclwiOlwi4oaRXCIsXCJVYXJyXCI6XCLihp9cIixcInVBcnJcIjpcIuKHkVwiLFwiVWFycm9jaXJcIjpcIuKliVwiLFwiVWJyY3lcIjpcItCOXCIsXCJ1YnJjeVwiOlwi0Z5cIixcIlVicmV2ZVwiOlwixaxcIixcInVicmV2ZVwiOlwixa1cIixcIlVjaXJjXCI6XCLDm1wiLFwidWNpcmNcIjpcIsO7XCIsXCJVY3lcIjpcItCjXCIsXCJ1Y3lcIjpcItGDXCIsXCJ1ZGFyclwiOlwi4oeFXCIsXCJVZGJsYWNcIjpcIsWwXCIsXCJ1ZGJsYWNcIjpcIsWxXCIsXCJ1ZGhhclwiOlwi4qWuXCIsXCJ1ZmlzaHRcIjpcIuKlvlwiLFwiVWZyXCI6XCLwnZSYXCIsXCJ1ZnJcIjpcIvCdlLJcIixcIlVncmF2ZVwiOlwiw5lcIixcInVncmF2ZVwiOlwiw7lcIixcInVIYXJcIjpcIuKlo1wiLFwidWhhcmxcIjpcIuKGv1wiLFwidWhhcnJcIjpcIuKGvlwiLFwidWhibGtcIjpcIuKWgFwiLFwidWxjb3JuXCI6XCLijJxcIixcInVsY29ybmVyXCI6XCLijJxcIixcInVsY3JvcFwiOlwi4oyPXCIsXCJ1bHRyaVwiOlwi4pe4XCIsXCJVbWFjclwiOlwixapcIixcInVtYWNyXCI6XCLFq1wiLFwidW1sXCI6XCLCqFwiLFwiVW5kZXJCYXJcIjpcIl9cIixcIlVuZGVyQnJhY2VcIjpcIuKPn1wiLFwiVW5kZXJCcmFja2V0XCI6XCLijrVcIixcIlVuZGVyUGFyZW50aGVzaXNcIjpcIuKPnVwiLFwiVW5pb25cIjpcIuKLg1wiLFwiVW5pb25QbHVzXCI6XCLiio5cIixcIlVvZ29uXCI6XCLFslwiLFwidW9nb25cIjpcIsWzXCIsXCJVb3BmXCI6XCLwnZWMXCIsXCJ1b3BmXCI6XCLwnZWmXCIsXCJVcEFycm93QmFyXCI6XCLipJJcIixcInVwYXJyb3dcIjpcIuKGkVwiLFwiVXBBcnJvd1wiOlwi4oaRXCIsXCJVcGFycm93XCI6XCLih5FcIixcIlVwQXJyb3dEb3duQXJyb3dcIjpcIuKHhVwiLFwidXBkb3duYXJyb3dcIjpcIuKGlVwiLFwiVXBEb3duQXJyb3dcIjpcIuKGlVwiLFwiVXBkb3duYXJyb3dcIjpcIuKHlVwiLFwiVXBFcXVpbGlicml1bVwiOlwi4qWuXCIsXCJ1cGhhcnBvb25sZWZ0XCI6XCLihr9cIixcInVwaGFycG9vbnJpZ2h0XCI6XCLihr5cIixcInVwbHVzXCI6XCLiio5cIixcIlVwcGVyTGVmdEFycm93XCI6XCLihpZcIixcIlVwcGVyUmlnaHRBcnJvd1wiOlwi4oaXXCIsXCJ1cHNpXCI6XCLPhVwiLFwiVXBzaVwiOlwiz5JcIixcInVwc2loXCI6XCLPklwiLFwiVXBzaWxvblwiOlwizqVcIixcInVwc2lsb25cIjpcIs+FXCIsXCJVcFRlZUFycm93XCI6XCLihqVcIixcIlVwVGVlXCI6XCLiiqVcIixcInVwdXBhcnJvd3NcIjpcIuKHiFwiLFwidXJjb3JuXCI6XCLijJ1cIixcInVyY29ybmVyXCI6XCLijJ1cIixcInVyY3JvcFwiOlwi4oyOXCIsXCJVcmluZ1wiOlwixa5cIixcInVyaW5nXCI6XCLFr1wiLFwidXJ0cmlcIjpcIuKXuVwiLFwiVXNjclwiOlwi8J2SsFwiLFwidXNjclwiOlwi8J2TilwiLFwidXRkb3RcIjpcIuKLsFwiLFwiVXRpbGRlXCI6XCLFqFwiLFwidXRpbGRlXCI6XCLFqVwiLFwidXRyaVwiOlwi4pa1XCIsXCJ1dHJpZlwiOlwi4pa0XCIsXCJ1dWFyclwiOlwi4oeIXCIsXCJVdW1sXCI6XCLDnFwiLFwidXVtbFwiOlwiw7xcIixcInV3YW5nbGVcIjpcIuKmp1wiLFwidmFuZ3J0XCI6XCLippxcIixcInZhcmVwc2lsb25cIjpcIs+1XCIsXCJ2YXJrYXBwYVwiOlwiz7BcIixcInZhcm5vdGhpbmdcIjpcIuKIhVwiLFwidmFycGhpXCI6XCLPlVwiLFwidmFycGlcIjpcIs+WXCIsXCJ2YXJwcm9wdG9cIjpcIuKInVwiLFwidmFyclwiOlwi4oaVXCIsXCJ2QXJyXCI6XCLih5VcIixcInZhcnJob1wiOlwiz7FcIixcInZhcnNpZ21hXCI6XCLPglwiLFwidmFyc3Vic2V0bmVxXCI6XCLiiorvuIBcIixcInZhcnN1YnNldG5lcXFcIjpcIuKri++4gFwiLFwidmFyc3Vwc2V0bmVxXCI6XCLiiovvuIBcIixcInZhcnN1cHNldG5lcXFcIjpcIuKrjO+4gFwiLFwidmFydGhldGFcIjpcIs+RXCIsXCJ2YXJ0cmlhbmdsZWxlZnRcIjpcIuKKslwiLFwidmFydHJpYW5nbGVyaWdodFwiOlwi4oqzXCIsXCJ2QmFyXCI6XCLiq6hcIixcIlZiYXJcIjpcIuKrq1wiLFwidkJhcnZcIjpcIuKrqVwiLFwiVmN5XCI6XCLQklwiLFwidmN5XCI6XCLQslwiLFwidmRhc2hcIjpcIuKKolwiLFwidkRhc2hcIjpcIuKKqFwiLFwiVmRhc2hcIjpcIuKKqVwiLFwiVkRhc2hcIjpcIuKKq1wiLFwiVmRhc2hsXCI6XCLiq6ZcIixcInZlZWJhclwiOlwi4oq7XCIsXCJ2ZWVcIjpcIuKIqFwiLFwiVmVlXCI6XCLii4FcIixcInZlZWVxXCI6XCLiiZpcIixcInZlbGxpcFwiOlwi4ouuXCIsXCJ2ZXJiYXJcIjpcInxcIixcIlZlcmJhclwiOlwi4oCWXCIsXCJ2ZXJ0XCI6XCJ8XCIsXCJWZXJ0XCI6XCLigJZcIixcIlZlcnRpY2FsQmFyXCI6XCLiiKNcIixcIlZlcnRpY2FsTGluZVwiOlwifFwiLFwiVmVydGljYWxTZXBhcmF0b3JcIjpcIuKdmFwiLFwiVmVydGljYWxUaWxkZVwiOlwi4omAXCIsXCJWZXJ5VGhpblNwYWNlXCI6XCLigIpcIixcIlZmclwiOlwi8J2UmVwiLFwidmZyXCI6XCLwnZSzXCIsXCJ2bHRyaVwiOlwi4oqyXCIsXCJ2bnN1YlwiOlwi4oqC4oOSXCIsXCJ2bnN1cFwiOlwi4oqD4oOSXCIsXCJWb3BmXCI6XCLwnZWNXCIsXCJ2b3BmXCI6XCLwnZWnXCIsXCJ2cHJvcFwiOlwi4oidXCIsXCJ2cnRyaVwiOlwi4oqzXCIsXCJWc2NyXCI6XCLwnZKxXCIsXCJ2c2NyXCI6XCLwnZOLXCIsXCJ2c3VibkVcIjpcIuKri++4gFwiLFwidnN1Ym5lXCI6XCLiiorvuIBcIixcInZzdXBuRVwiOlwi4quM77iAXCIsXCJ2c3VwbmVcIjpcIuKKi++4gFwiLFwiVnZkYXNoXCI6XCLiiqpcIixcInZ6aWd6YWdcIjpcIuKmmlwiLFwiV2NpcmNcIjpcIsW0XCIsXCJ3Y2lyY1wiOlwixbVcIixcIndlZGJhclwiOlwi4qmfXCIsXCJ3ZWRnZVwiOlwi4oinXCIsXCJXZWRnZVwiOlwi4ouAXCIsXCJ3ZWRnZXFcIjpcIuKJmVwiLFwid2VpZXJwXCI6XCLihJhcIixcIldmclwiOlwi8J2UmlwiLFwid2ZyXCI6XCLwnZS0XCIsXCJXb3BmXCI6XCLwnZWOXCIsXCJ3b3BmXCI6XCLwnZWoXCIsXCJ3cFwiOlwi4oSYXCIsXCJ3clwiOlwi4omAXCIsXCJ3cmVhdGhcIjpcIuKJgFwiLFwiV3NjclwiOlwi8J2SslwiLFwid3NjclwiOlwi8J2TjFwiLFwieGNhcFwiOlwi4ouCXCIsXCJ4Y2lyY1wiOlwi4pevXCIsXCJ4Y3VwXCI6XCLii4NcIixcInhkdHJpXCI6XCLilr1cIixcIlhmclwiOlwi8J2Um1wiLFwieGZyXCI6XCLwnZS1XCIsXCJ4aGFyclwiOlwi4p+3XCIsXCJ4aEFyclwiOlwi4p+6XCIsXCJYaVwiOlwizp5cIixcInhpXCI6XCLOvlwiLFwieGxhcnJcIjpcIuKftVwiLFwieGxBcnJcIjpcIuKfuFwiLFwieG1hcFwiOlwi4p+8XCIsXCJ4bmlzXCI6XCLii7tcIixcInhvZG90XCI6XCLiqIBcIixcIlhvcGZcIjpcIvCdlY9cIixcInhvcGZcIjpcIvCdlalcIixcInhvcGx1c1wiOlwi4qiBXCIsXCJ4b3RpbWVcIjpcIuKoglwiLFwieHJhcnJcIjpcIuKftlwiLFwieHJBcnJcIjpcIuKfuVwiLFwiWHNjclwiOlwi8J2Ss1wiLFwieHNjclwiOlwi8J2TjVwiLFwieHNxY3VwXCI6XCLiqIZcIixcInh1cGx1c1wiOlwi4qiEXCIsXCJ4dXRyaVwiOlwi4pazXCIsXCJ4dmVlXCI6XCLii4FcIixcInh3ZWRnZVwiOlwi4ouAXCIsXCJZYWN1dGVcIjpcIsOdXCIsXCJ5YWN1dGVcIjpcIsO9XCIsXCJZQWN5XCI6XCLQr1wiLFwieWFjeVwiOlwi0Y9cIixcIlljaXJjXCI6XCLFtlwiLFwieWNpcmNcIjpcIsW3XCIsXCJZY3lcIjpcItCrXCIsXCJ5Y3lcIjpcItGLXCIsXCJ5ZW5cIjpcIsKlXCIsXCJZZnJcIjpcIvCdlJxcIixcInlmclwiOlwi8J2UtlwiLFwiWUljeVwiOlwi0IdcIixcInlpY3lcIjpcItGXXCIsXCJZb3BmXCI6XCLwnZWQXCIsXCJ5b3BmXCI6XCLwnZWqXCIsXCJZc2NyXCI6XCLwnZK0XCIsXCJ5c2NyXCI6XCLwnZOOXCIsXCJZVWN5XCI6XCLQrlwiLFwieXVjeVwiOlwi0Y5cIixcInl1bWxcIjpcIsO/XCIsXCJZdW1sXCI6XCLFuFwiLFwiWmFjdXRlXCI6XCLFuVwiLFwiemFjdXRlXCI6XCLFulwiLFwiWmNhcm9uXCI6XCLFvVwiLFwiemNhcm9uXCI6XCLFvlwiLFwiWmN5XCI6XCLQl1wiLFwiemN5XCI6XCLQt1wiLFwiWmRvdFwiOlwixbtcIixcInpkb3RcIjpcIsW8XCIsXCJ6ZWV0cmZcIjpcIuKEqFwiLFwiWmVyb1dpZHRoU3BhY2VcIjpcIuKAi1wiLFwiWmV0YVwiOlwizpZcIixcInpldGFcIjpcIs62XCIsXCJ6ZnJcIjpcIvCdlLdcIixcIlpmclwiOlwi4oSoXCIsXCJaSGN5XCI6XCLQllwiLFwiemhjeVwiOlwi0LZcIixcInppZ3JhcnJcIjpcIuKHnVwiLFwiem9wZlwiOlwi8J2Vq1wiLFwiWm9wZlwiOlwi4oSkXCIsXCJac2NyXCI6XCLwnZK1XCIsXCJ6c2NyXCI6XCLwnZOPXCIsXCJ6d2pcIjpcIuKAjVwiLFwiendualwiOlwi4oCMXCJ9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gUmVuZGVyZXIoKSB7fVxuXG4vKipcbiAqICBXYWxrcyB0aGUgQVNUIGFuZCBjYWxscyBtZW1iZXIgbWV0aG9kcyBmb3IgZWFjaCBOb2RlIHR5cGUuXG4gKlxuICogIEBwYXJhbSBhc3Qge05vZGV9IFRoZSByb290IG9mIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyKGFzdCkge1xuICB2YXIgd2Fsa2VyID0gYXN0LndhbGtlcigpXG4gICAgLCBldmVudFxuICAgICwgdHlwZTtcblxuICB0aGlzLmJ1ZmZlciA9ICcnO1xuICB0aGlzLmxhc3RPdXQgPSAnXFxuJztcblxuICB3aGlsZSgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgIHR5cGUgPSBldmVudC5ub2RlLnR5cGU7XG4gICAgaWYgKHRoaXNbdHlwZV0pIHtcbiAgICAgIHRoaXNbdHlwZV0oZXZlbnQubm9kZSwgZXZlbnQuZW50ZXJpbmcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5idWZmZXI7XG59XG5cbi8qKlxuICogIENvbmNhdGVuYXRlIGEgbGl0ZXJhbCBzdHJpbmcgdG8gdGhlIGJ1ZmZlci5cbiAqXG4gKiAgQHBhcmFtIHN0ciB7U3RyaW5nfSBUaGUgc3RyaW5nIHRvIGNvbmNhdGVuYXRlLlxuICovXG5mdW5jdGlvbiBsaXQoc3RyKSB7XG4gIHRoaXMuYnVmZmVyICs9IHN0cjtcbiAgdGhpcy5sYXN0T3V0ID0gc3RyO1xufVxuXG4vKipcbiAqICBPdXRwdXQgYSBuZXdsaW5lIHRvIHRoZSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNyKCkge1xuICBpZiAodGhpcy5sYXN0T3V0ICE9PSAnXFxuJykge1xuICAgIHRoaXMubGl0KCdcXG4nKTtcbiAgfVxufVxuXG4vKipcbiAqICBDb25jYXRlbmF0ZSBhIHN0cmluZyB0byB0aGUgYnVmZmVyIHBvc3NpYmx5IGVzY2FwaW5nIHRoZSBjb250ZW50LlxuICpcbiAqICBDb25jcmV0ZSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuICpcbiAqICBAcGFyYW0gc3RyIHtTdHJpbmd9IFRoZSBzdHJpbmcgdG8gY29uY2F0ZW5hdGUuXG4gKi9cbmZ1bmN0aW9uIG91dChzdHIpIHtcbiAgdGhpcy5saXQoc3RyKTtcbn1cblxuLyoqXG4gKiAgRXNjYXBlIGEgc3RyaW5nIGZvciB0aGUgdGFyZ2V0IHJlbmRlcmVyLlxuICpcbiAqICBBYnN0cmFjdCBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBjb25jcmV0ZSBcbiAqICByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogIEBwYXJhbSBzdHIge1N0cmluZ30gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKi9cbmZ1bmN0aW9uIGVzYyhzdHIpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IHJlbmRlcjtcblJlbmRlcmVyLnByb3RvdHlwZS5vdXQgPSBvdXQ7XG5SZW5kZXJlci5wcm90b3R5cGUubGl0ID0gbGl0O1xuUmVuZGVyZXIucHJvdG90eXBlLmNyICA9IGNyO1xuUmVuZGVyZXIucHJvdG90eXBlLmVzYyAgPSBlc2M7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb21tb25tYXJrL2xpYi9yZW5kZXIvcmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IGxhbWwgPSByZXF1aXJlKCcuL2xhbWwuanMnKTtcbmNvbnN0IHt0ZXgyamF4fSA9IHJlcXVpcmUoJy4vdGV4MmpheC5qcycpO1xuY29uc3QgY29tbW9ubWFyayA9IHJlcXVpcmUoJ2NvbW1vbm1hcmsnKTtcblxuY29uc3QgaHRtbEhlYWQgPSByZXF1aXJlKCcuL2h0bWwtaGVhZCcpO1xuY29uc3QgcGFyYWdyYXBocyA9IHJlcXVpcmUoJy4vcGFyYWdhcGhzLmpzJyk7XG5cbmNvbnN0IHdvcmtlciA9IGZ1bmN0aW9uKHdpbmRvdykge1xuICBjb25zdCBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgaHRtbEhlYWQoZG9jdW1lbnQpO1xuICBwYXJhZ3JhcGhzKGRvY3VtZW50KTtcblxuICB3aW5kb3cudGV4MmpheCA9IHRleDJqYXg7XG4gIHdpbmRvdy50ZXgyamF4LmNvbmZpZy5kb2MgPSBkb2N1bWVudDtcbiAgd2luZG93LnRleDJqYXguY29uZmlnLmlubGluZU1hdGgucHVzaChbJyQnLCAnJCddKTtcbiAgd2luZG93LnRleDJqYXguY29uZmlnLnByb2Nlc3NFc2NhcGVzID0gdHJ1ZTtcbiAgd2luZG93LnRleDJqYXguUHJlUHJvY2VzcygpO1xuXG5cbiAgY29uc3QgcmVhZGVyID0gbmV3IGNvbW1vbm1hcmsuUGFyc2VyKCk7XG4gIGNvbnN0IHdyaXRlciA9IG5ldyBjb21tb25tYXJrLkh0bWxSZW5kZXJlcigpO1xuICBjb25zdCBwYXJzZWQgPSByZWFkZXIucGFyc2UoZG9jdW1lbnQuYm9keS5pbm5lckhUTUwpO1xuICBkb2N1bWVudC5ib2R5LmlubmVySFRNTCA9IHdyaXRlci5yZW5kZXIocGFyc2VkKTtcblxuICBsYW1sKGRvY3VtZW50KTtcbn07XG5cbmlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2VzcyA6IDApID09PSAnW29iamVjdCBwcm9jZXNzXScpe1xuICAgIG1vZHVsZS5leHBvcnRzLndvcmtlciA9IHdvcmtlcjtcbn1cbmVsc2Uge1xuICB3b3JrZXIod2luZG93KTtcbiAgd2luZG93Lk1hdGhKYXggPSB7XG4gICAgJ2Zhc3QtcHJldmlldyc6IHtcbiAgICAgIGRpc2FibGVkOiB0cnVlXG4gICAgfVxuICB9O1xuICBjb25zdCBtaiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBtai5zcmMgPVxuICAgICdodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9tYXRoamF4LzIuNy4zL01hdGhKYXguanM/Y29uZmlnPVRlWC1BTVNfQ0hUTUwtZnVsbCc7XG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobWopO1xuXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy93b3JrZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IHsgcmVuYW1lVGFnIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMuanMnKTtcbmNvbnN0IHlhbWxkYXRhID0gcmVxdWlyZSgnLi95YW1sZGF0YS5qcycpXG5jb25zdCBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vbWV0YWRhdGEuanMnKTtcbmNvbnN0IHByZWFtYmxlID0gcmVxdWlyZSgnLi9wcmVhbWJsZS5qcycpO1xuY29uc3QgYWJzdHJhY3QgPSByZXF1aXJlKCcuL2Fic3RyYWN0LmpzJyk7XG5jb25zdCBzZWN0aW9uaW5nID0gcmVxdWlyZSgnLi9zZWN0aW9uaW5nLmpzJyk7XG5jb25zdCBzdGF0ZW1lbnRzID0gcmVxdWlyZSgnLi9zdGF0ZW1lbnRzLmpzJyk7XG5jb25zdCBmaWd1cmVzID0gcmVxdWlyZSgnLi9maWd1cmVzLmpzJyk7XG5jb25zdCBuYW1lcyA9IHJlcXVpcmUoJy4vbmFtZXMuanMnKTtcbmNvbnN0IGJsYW1lcyA9IHJlcXVpcmUoJy4vYmxhbWVzLmpzJyk7XG5jb25zdCByZWZzID0gcmVxdWlyZSgnLi9yZWZzLmpzJyk7XG5jb25zdCBjaXRlcyA9IHJlcXVpcmUoJy4vY2l0ZXMuanMnKTtcbmNvbnN0IG5vdGVzID0gcmVxdWlyZSgnLi9ub3Rlcy5qcycpO1xuY29uc3QgYmlibGlvZ3JhcGh5ID0gcmVxdWlyZSgnLi9iaWJsaW9ncmFwaHkuanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvY3VtZW50KSB7XG4gIHlhbWxkYXRhKGRvY3VtZW50KTtcbiAgY29uc3QgZGF0YSA9IG1ldGFkYXRhKGRvY3VtZW50KTtcbiAgcHJlYW1ibGUoZG9jdW1lbnQpO1xuICBhYnN0cmFjdChkb2N1bWVudCk7XG4gIHNlY3Rpb25pbmcoZG9jdW1lbnQpO1xuICBzdGF0ZW1lbnRzKGRvY3VtZW50LCBkYXRhLmxhbWwuc3RhdGVtZW50cyk7XG4gIGZpZ3VyZXMoZG9jdW1lbnQsIGZhbHNlKTtcbiAgbmFtZXMoZG9jdW1lbnQpO1xuICAvLyBUT0RPIHNob3VsZCBkZXBlbmQgb24gY20uY3NzP1xuICBibGFtZXMoZG9jdW1lbnQpO1xuICByZWZzKGRvY3VtZW50KTtcbiAgY2l0ZXMoZG9jdW1lbnQpO1xuICBub3Rlcyhkb2N1bWVudCk7XG4gIGJpYmxpb2dyYXBoeShkb2N1bWVudCk7XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYW1sLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCB5YW1sID0gcmVxdWlyZSgnanMteWFtbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvY3VtZW50KSB7XG4gIC8vIGNvbnZlcnQgeWFtbCB0byBqc29uIG1ldGFkYXRhXG4gIC8vIFRPRE8gdGhpbmsgYWJvdXQgc2NoZW1hLm9yZyBtYXJrdXBcbiAgY29uc3QgeWFtbGRhdGEgPSB5YW1sLnNhZmVMb2FkKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFt0eXBlPVwiYXBwbGljYXRpb24veWFtbFwiXScpLnRleHQpO1xuICBpZiAoIXlhbWxkYXRhKSByZXR1cm4gO1xuICBjb25zdCBtZXRhZGF0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBtZXRhZGF0YS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICBtZXRhZGF0YS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGFtbCcsICdtZXRhZGF0YScpO1xuICBtZXRhZGF0YS50ZXh0ID0gSlNPTi5zdHJpbmdpZnkoeWFtbGRhdGEpO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG1ldGFkYXRhKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy95YW1sZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB5YW1sID0gcmVxdWlyZSgnLi9saWIvanMteWFtbC5qcycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0geWFtbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgbG9hZGVyID0gcmVxdWlyZSgnLi9qcy15YW1sL2xvYWRlcicpO1xudmFyIGR1bXBlciA9IHJlcXVpcmUoJy4vanMteWFtbC9kdW1wZXInKTtcblxuXG5mdW5jdGlvbiBkZXByZWNhdGVkKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uICcgKyBuYW1lICsgJyBpcyBkZXByZWNhdGVkIGFuZCBjYW5ub3QgYmUgdXNlZC4nKTtcbiAgfTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5UeXBlICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3R5cGUnKTtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hJyk7XG5tb2R1bGUuZXhwb3J0cy5GQUlMU0FGRV9TQ0hFTUEgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuSlNPTl9TQ0hFTUEgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvanNvbicpO1xubW9kdWxlLmV4cG9ydHMuQ09SRV9TQ0hFTUEgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvY29yZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQUZFX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcbm1vZHVsZS5leHBvcnRzLmxvYWQgICAgICAgICAgICAgICAgPSBsb2FkZXIubG9hZDtcbm1vZHVsZS5leHBvcnRzLmxvYWRBbGwgICAgICAgICAgICAgPSBsb2FkZXIubG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgICAgICAgICAgPSBsb2FkZXIuc2FmZUxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZEFsbCAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMuZHVtcCAgICAgICAgICAgICAgICA9IGR1bXBlci5kdW1wO1xubW9kdWxlLmV4cG9ydHMuc2FmZUR1bXAgICAgICAgICAgICA9IGR1bXBlci5zYWZlRHVtcDtcbm1vZHVsZS5leHBvcnRzLllBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvZXhjZXB0aW9uJyk7XG5cbi8vIERlcHJlY2F0ZWQgc2NoZW1hIG5hbWVzIGZyb20gSlMtWUFNTCAyLjAueFxubW9kdWxlLmV4cG9ydHMuTUlOSU1BTF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2ZhaWxzYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5TQUZFX1NDSEVNQSAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5cbi8vIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGZyb20gSlMtWUFNTCAxLngueFxubW9kdWxlLmV4cG9ydHMuc2NhbiAgICAgICAgICAgPSBkZXByZWNhdGVkKCdzY2FuJyk7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSAgICAgICAgICA9IGRlcHJlY2F0ZWQoJ3BhcnNlJyk7XG5tb2R1bGUuZXhwb3J0cy5jb21wb3NlICAgICAgICA9IGRlcHJlY2F0ZWQoJ2NvbXBvc2UnKTtcbm1vZHVsZS5leHBvcnRzLmFkZENvbnN0cnVjdG9yID0gZGVwcmVjYXRlZCgnYWRkQ29uc3RydWN0b3InKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuLG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIE1hcmsgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL21hcmsnKTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG52YXIgREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cbnZhciBDT05URVhUX0ZMT1dfSU4gICA9IDE7XG52YXIgQ09OVEVYVF9GTE9XX09VVCAgPSAyO1xudmFyIENPTlRFWFRfQkxPQ0tfSU4gID0gMztcbnZhciBDT05URVhUX0JMT0NLX09VVCA9IDQ7XG5cblxudmFyIENIT01QSU5HX0NMSVAgID0gMTtcbnZhciBDSE9NUElOR19TVFJJUCA9IDI7XG52YXIgQ0hPTVBJTkdfS0VFUCAgPSAzO1xuXG5cbnZhciBQQVRURVJOX05PTl9QUklOVEFCTEUgICAgICAgICA9IC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZcXHg3Ri1cXHg4NFxceDg2LVxceDlGXFx1RkZGRVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLztcbnZhciBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUyA9IC9bXFx4ODVcXHUyMDI4XFx1MjAyOV0vO1xudmFyIFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTICAgICAgID0gL1ssXFxbXFxdXFx7XFx9XS87XG52YXIgUEFUVEVSTl9UQUdfSEFORExFICAgICAgICAgICAgPSAvXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pO1xudmFyIFBBVFRFUk5fVEFHX1VSSSAgICAgICAgICAgICAgID0gL14oPzohfFteLFxcW1xcXVxce1xcfV0pKD86JVswLTlhLWZdezJ9fFswLTlhLXpcXC0jO1xcL1xcPzpAJj1cXCtcXCQsX1xcLiF+XFwqJ1xcKFxcKVxcW1xcXV0pKiQvaTtcblxuXG5mdW5jdGlvbiBpc19FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MEEvKiBMRiAqLykgfHwgKGMgPT09IDB4MEQvKiBDUiAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX1dISVRFX1NQQUNFKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fCAoYyA9PT0gMHgyMC8qIFNwYWNlICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV1NfT1JfRU9MKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBBLyogTEYgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfRkxPV19JTkRJQ0FUT1IoYykge1xuICByZXR1cm4gYyA9PT0gMHgyQy8qICwgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUIvKiBbICovIHx8XG4gICAgICAgICBjID09PSAweDVELyogXSAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3Qi8qIHsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4N0QvKiB9ICovO1xufVxuXG5mdW5jdGlvbiBmcm9tSGV4Q29kZShjKSB7XG4gIHZhciBsYztcblxuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG4gIGxjID0gYyB8IDB4MjA7XG5cbiAgaWYgKCgweDYxLyogYSAqLyA8PSBsYykgJiYgKGxjIDw9IDB4NjYvKiBmICovKSkge1xuICAgIHJldHVybiBsYyAtIDB4NjEgKyAxMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZEhleExlbihjKSB7XG4gIGlmIChjID09PSAweDc4LyogeCAqLykgeyByZXR1cm4gMjsgfVxuICBpZiAoYyA9PT0gMHg3NS8qIHUgKi8pIHsgcmV0dXJuIDQ7IH1cbiAgaWYgKGMgPT09IDB4NTUvKiBVICovKSB7IHJldHVybiA4OyB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmcm9tRGVjaW1hbENvZGUoYykge1xuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRXNjYXBlU2VxdWVuY2UoYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbiAgcmV0dXJuIChjID09PSAweDMwLyogMCAqLykgPyAnXFx4MDAnIDpcbiAgICAgICAgKGMgPT09IDB4NjEvKiBhICovKSA/ICdcXHgwNycgOlxuICAgICAgICAoYyA9PT0gMHg2Mi8qIGIgKi8pID8gJ1xceDA4JyA6XG4gICAgICAgIChjID09PSAweDc0LyogdCAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4MDkvKiBUYWIgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDZFLyogbiAqLykgPyAnXFx4MEEnIDpcbiAgICAgICAgKGMgPT09IDB4NzYvKiB2ICovKSA/ICdcXHgwQicgOlxuICAgICAgICAoYyA9PT0gMHg2Ni8qIGYgKi8pID8gJ1xceDBDJyA6XG4gICAgICAgIChjID09PSAweDcyLyogciAqLykgPyAnXFx4MEQnIDpcbiAgICAgICAgKGMgPT09IDB4NjUvKiBlICovKSA/ICdcXHgxQicgOlxuICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSA/ICcgJyA6XG4gICAgICAgIChjID09PSAweDIyLyogXCIgKi8pID8gJ1xceDIyJyA6XG4gICAgICAgIChjID09PSAweDJGLyogLyAqLykgPyAnLycgOlxuICAgICAgICAoYyA9PT0gMHg1Qy8qIFxcICovKSA/ICdcXHg1QycgOlxuICAgICAgICAoYyA9PT0gMHg0RS8qIE4gKi8pID8gJ1xceDg1JyA6XG4gICAgICAgIChjID09PSAweDVGLyogXyAqLykgPyAnXFx4QTAnIDpcbiAgICAgICAgKGMgPT09IDB4NEMvKiBMICovKSA/ICdcXHUyMDI4JyA6XG4gICAgICAgIChjID09PSAweDUwLyogUCAqLykgPyAnXFx1MjAyOScgOiAnJztcbn1cblxuZnVuY3Rpb24gY2hhckZyb21Db2RlcG9pbnQoYykge1xuICBpZiAoYyA8PSAweEZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgfVxuICAvLyBFbmNvZGUgVVRGLTE2IHN1cnJvZ2F0ZSBwYWlyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi0xNiNDb2RlX3BvaW50c19VLjJCMDEwMDAwX3RvX1UuMkIxMEZGRkZcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgKChjIC0gMHgwMTAwMDApID4+IDEwKSArIDB4RDgwMCxcbiAgICAoKGMgLSAweDAxMDAwMCkgJiAweDAzRkYpICsgMHhEQzAwXG4gICk7XG59XG5cbnZhciBzaW1wbGVFc2NhcGVDaGVjayA9IG5ldyBBcnJheSgyNTYpOyAvLyBpbnRlZ2VyLCBmb3IgZmFzdCBhY2Nlc3NcbnZhciBzaW1wbGVFc2NhcGVNYXAgPSBuZXcgQXJyYXkoMjU2KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgc2ltcGxlRXNjYXBlQ2hlY2tbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKSA/IDEgOiAwO1xuICBzaW1wbGVFc2NhcGVNYXBbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKTtcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgdGhpcy5maWxlbmFtZSAgPSBvcHRpb25zWydmaWxlbmFtZSddICB8fCBudWxsO1xuICB0aGlzLnNjaGVtYSAgICA9IG9wdGlvbnNbJ3NjaGVtYSddICAgIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMub25XYXJuaW5nID0gb3B0aW9uc1snb25XYXJuaW5nJ10gfHwgbnVsbDtcbiAgdGhpcy5sZWdhY3kgICAgPSBvcHRpb25zWydsZWdhY3knXSAgICB8fCBmYWxzZTtcbiAgdGhpcy5qc29uICAgICAgPSBvcHRpb25zWydqc29uJ10gICAgICB8fCBmYWxzZTtcbiAgdGhpcy5saXN0ZW5lciAgPSBvcHRpb25zWydsaXN0ZW5lciddICB8fCBudWxsO1xuXG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMudHlwZU1hcCAgICAgICA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkVHlwZU1hcDtcblxuICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gIHRoaXMucG9zaXRpb24gICA9IDA7XG4gIHRoaXMubGluZSAgICAgICA9IDA7XG4gIHRoaXMubGluZVN0YXJ0ICA9IDA7XG4gIHRoaXMubGluZUluZGVudCA9IDA7XG5cbiAgdGhpcy5kb2N1bWVudHMgPSBbXTtcblxuICAvKlxuICB0aGlzLnZlcnNpb247XG4gIHRoaXMuY2hlY2tMaW5lQnJlYWtzO1xuICB0aGlzLnRhZ01hcDtcbiAgdGhpcy5hbmNob3JNYXA7XG4gIHRoaXMudGFnO1xuICB0aGlzLmFuY2hvcjtcbiAgdGhpcy5raW5kO1xuICB0aGlzLnJlc3VsdDsqL1xuXG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICByZXR1cm4gbmV3IFlBTUxFeGNlcHRpb24oXG4gICAgbWVzc2FnZSxcbiAgICBuZXcgTWFyayhzdGF0ZS5maWxlbmFtZSwgc3RhdGUuaW5wdXQsIHN0YXRlLnBvc2l0aW9uLCBzdGF0ZS5saW5lLCAoc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQpKSk7XG59XG5cbmZ1bmN0aW9uIHRocm93RXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdGhyb3cgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHRocm93V2FybmluZyhzdGF0ZSwgbWVzc2FnZSkge1xuICBpZiAoc3RhdGUub25XYXJuaW5nKSB7XG4gICAgc3RhdGUub25XYXJuaW5nLmNhbGwobnVsbCwgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkpO1xuICB9XG59XG5cblxudmFyIGRpcmVjdGl2ZUhhbmRsZXJzID0ge1xuXG4gIFlBTUw6IGZ1bmN0aW9uIGhhbmRsZVlhbWxEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgIHZhciBtYXRjaCwgbWFqb3IsIG1pbm9yO1xuXG4gICAgaWYgKHN0YXRlLnZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgbWF0Y2ggPSAvXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKGFyZ3NbMF0pO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCBhcmd1bWVudCBvZiB0aGUgWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBtYWpvciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgbWlub3IgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuXG4gICAgaWYgKG1ham9yICE9PSAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS52ZXJzaW9uID0gYXJnc1swXTtcbiAgICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSAobWlub3IgPCAyKTtcblxuICAgIGlmIChtaW5vciAhPT0gMSAmJiBtaW5vciAhPT0gMikge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cbiAgfSxcblxuICBUQUc6IGZ1bmN0aW9uIGhhbmRsZVRhZ0RpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnVEFHIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgdHdvIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIGhhbmRsZSA9IGFyZ3NbMF07XG4gICAgcHJlZml4ID0gYXJnc1sxXTtcblxuICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIGhhbmRsZSAoZmlyc3QgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZXJlIGlzIGEgcHJldmlvdXNseSBkZWNsYXJlZCBzdWZmaXggZm9yIFwiJyArIGhhbmRsZSArICdcIiB0YWcgaGFuZGxlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgcHJlZml4IChzZWNvbmQgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gY2FwdHVyZVNlZ21lbnQoc3RhdGUsIHN0YXJ0LCBlbmQsIGNoZWNrSnNvbikge1xuICB2YXIgX3Bvc2l0aW9uLCBfbGVuZ3RoLCBfY2hhcmFjdGVyLCBfcmVzdWx0O1xuXG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIF9yZXN1bHQgPSBzdGF0ZS5pbnB1dC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChjaGVja0pzb24pIHtcbiAgICAgIGZvciAoX3Bvc2l0aW9uID0gMCwgX2xlbmd0aCA9IF9yZXN1bHQubGVuZ3RoOyBfcG9zaXRpb24gPCBfbGVuZ3RoOyBfcG9zaXRpb24gKz0gMSkge1xuICAgICAgICBfY2hhcmFjdGVyID0gX3Jlc3VsdC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG4gICAgICAgIGlmICghKF9jaGFyYWN0ZXIgPT09IDB4MDkgfHxcbiAgICAgICAgICAgICAgKDB4MjAgPD0gX2NoYXJhY3RlciAmJiBfY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUEFUVEVSTl9OT05fUFJJTlRBQkxFLnRlc3QoX3Jlc3VsdCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGUgc3RyZWFtIGNvbnRhaW5zIG5vbi1wcmludGFibGUgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJyaWRhYmxlS2V5cykge1xuICB2YXIgc291cmNlS2V5cywga2V5LCBpbmRleCwgcXVhbnRpdHk7XG5cbiAgaWYgKCFjb21tb24uaXNPYmplY3Qoc291cmNlKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgbWVyZ2UgbWFwcGluZ3M7IHRoZSBwcm92aWRlZCBzb3VyY2Ugb2JqZWN0IGlzIHVuYWNjZXB0YWJsZScpO1xuICB9XG5cbiAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcblxuICAgIGlmICghX2hhc093blByb3BlcnR5LmNhbGwoZGVzdGluYXRpb24sIGtleSkpIHtcbiAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIG92ZXJyaWRhYmxlS2V5c1trZXldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgc3RhcnRMaW5lLCBzdGFydFBvcykge1xuICB2YXIgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGtleU5vZGUgPSBTdHJpbmcoa2V5Tm9kZSk7XG5cbiAgaWYgKF9yZXN1bHQgPT09IG51bGwpIHtcbiAgICBfcmVzdWx0ID0ge307XG4gIH1cblxuICBpZiAoa2V5VGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVOb2RlKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gdmFsdWVOb2RlLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGVbaW5kZXhdLCBvdmVycmlkYWJsZUtleXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGUsIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghc3RhdGUuanNvbiAmJlxuICAgICAgICAhX2hhc093blByb3BlcnR5LmNhbGwob3ZlcnJpZGFibGVLZXlzLCBrZXlOb2RlKSAmJlxuICAgICAgICBfaGFzT3duUHJvcGVydHkuY2FsbChfcmVzdWx0LCBrZXlOb2RlKSkge1xuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSB8fCBzdGF0ZS5saW5lO1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGFydFBvcyB8fCBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGVkIG1hcHBpbmcga2V5Jyk7XG4gICAgfVxuICAgIF9yZXN1bHRba2V5Tm9kZV0gPSB2YWx1ZU5vZGU7XG4gICAgZGVsZXRlIG92ZXJyaWRhYmxlS2V5c1trZXlOb2RlXTtcbiAgfVxuXG4gIHJldHVybiBfcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkTGluZUJyZWFrKHN0YXRlKSB7XG4gIHZhciBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgwRC8qIENSICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MEEvKiBMRiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2EgbGluZSBicmVhayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgc3RhdGUubGluZSArPSAxO1xuICBzdGF0ZS5saW5lU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcbiAgdmFyIGxpbmVCcmVha3MgPSAwLFxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93Q29tbWVudHMgJiYgY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH0gd2hpbGUgKGNoICE9PSAweDBBLyogTEYgKi8gJiYgY2ggIT09IDB4MEQvKiBDUiAqLyAmJiBjaCAhPT0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgbGluZUJyZWFrcysrO1xuICAgICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tJbmRlbnQgIT09IC0xICYmIGxpbmVCcmVha3MgIT09IDAgJiYgc3RhdGUubGluZUluZGVudCA8IGNoZWNrSW5kZW50KSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbGluZUJyZWFrcztcbn1cblxuZnVuY3Rpb24gdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gIC8vIENvbmRpdGlvbiBzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0IGlzIHRlc3RlZFxuICAvLyBpbiBwYXJlbnQgb24gZWFjaCBjYWxsLCBmb3IgZWZmaWNpZW5jeS4gTm8gbmVlZHMgdG8gdGVzdCBoZXJlIGFnYWluLlxuICBpZiAoKGNoID09PSAweDJELyogLSAqLyB8fCBjaCA9PT0gMHgyRS8qIC4gKi8pICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAxKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMikpIHtcblxuICAgIF9wb3NpdGlvbiArPSAzO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDAgfHwgaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBjb3VudCkge1xuICBpZiAoY291bnQgPT09IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICB9IGVsc2UgaWYgKGNvdW50ID4gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBjb3VudCAtIDEpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVhZFBsYWluU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50LCB3aXRoaW5GbG93Q29sbGVjdGlvbikge1xuICB2YXIgcHJlY2VkaW5nLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50LFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX2xpbmVJbmRlbnQsXG4gICAgICBfa2luZCA9IHN0YXRlLmtpbmQsXG4gICAgICBfcmVzdWx0ID0gc3RhdGUucmVzdWx0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoaXNfV1NfT1JfRU9MKGNoKSAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgfHxcbiAgICAgIGNoID09PSAweDIzLyogIyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjYvKiAmICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyQS8qICogKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIxLyogISAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4N0MvKiB8ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgzRS8qID4gKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI3LyogJyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjIvKiBcIiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjUvKiAlICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg0MC8qIEAgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDYwLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNy8qICcgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjIvKiBcIiAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDIyLyogXCIgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7XG5cbiAgICAgICAgLy8gVE9ETzogcmV3b3JrIHRvIGlubGluZSBmbiB3aXRoIG5vIHR5cGUgY2FzdD9cbiAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBzaW1wbGVFc2NhcGVNYXBbY2hdO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBlc2NhcGVkSGV4TGVuKGNoKSkgPiAwKSB7XG4gICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgaGV4UmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IgKDsgaGV4TGVuZ3RoID4gMDsgaGV4TGVuZ3RoLS0pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoKHRtcCA9IGZyb21IZXhDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgICAgICAgaGV4UmVzdWx0ID0gKGhleFJlc3VsdCA8PCA0KSArIHRtcDtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgcmVhZE5leHQgPSB0cnVlLFxuICAgICAgX2xpbmUsXG4gICAgICBfdGFnICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9yZXN1bHQsXG4gICAgICBfYW5jaG9yICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIHRlcm1pbmF0b3IsXG4gICAgICBpc1BhaXIsXG4gICAgICBpc0V4cGxpY2l0UGFpcixcbiAgICAgIGlzTWFwcGluZyxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IHt9LFxuICAgICAga2V5Tm9kZSxcbiAgICAgIGtleVRhZyxcbiAgICAgIHZhbHVlTm9kZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDVCLyogWyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDVEOy8qIF0gKi9cbiAgICBpc01hcHBpbmcgPSBmYWxzZTtcbiAgICBfcmVzdWx0ID0gW107XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4N0IvKiB7ICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4N0Q7LyogfSAqL1xuICAgIGlzTWFwcGluZyA9IHRydWU7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSB0ZXJtaW5hdG9yKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICBzdGF0ZS5raW5kID0gaXNNYXBwaW5nID8gJ21hcHBpbmcnIDogJ3NlcXVlbmNlJztcbiAgICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFyZWFkTmV4dCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ21pc3NlZCBjb21tYSBiZXR3ZWVuIGZsb3cgY29sbGVjdGlvbiBlbnRyaWVzJyk7XG4gICAgfVxuXG4gICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSBmYWxzZTtcblxuICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKGlzRXhwbGljaXRQYWlyIHx8IHN0YXRlLmxpbmUgPT09IF9saW5lKSAmJiBjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGlzUGFpciA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXBwaW5nKSB7XG4gICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xuICAgIH1cblxuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgICAgICAgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGlkUmVhZENvbnRlbnQgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJCLyogKyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9IChjaCA9PT0gMHgyQi8qICsgKi8pID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0NMSVApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cbiAgICBpZiAoZm9sZGluZykge1xuXG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMgKG1vcmUtaW5kZW50ZWQgbGluZXMpIGFyZSBub3QgZm9sZGVkLlxuICAgICAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAoY2YuIEV4YW1wbGUgOC4xKVxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuXG4gICAgICAvLyBFbmQgb2YgbW9yZS1pbmRlbnRlZCBibG9jay5cbiAgICAgIH0gZWxzZSBpZiAoYXRNb3JlSW5kZW50ZWQpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gSnVzdCBvbmUgbGluZSBicmVhayAtIHBlcmNlaXZlIGFzIHRoZSBzYW1lIGxpbmUuXG4gICAgICB9IGVsc2UgaWYgKGVtcHR5TGluZXMgPT09IDApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH1cblxuICAgIC8vIExpdGVyYWwgc3R5bGU6IGp1c3QgYWRkIGV4YWN0IG51bWJlciBvZiBsaW5lIGJyZWFrcyBiZXR3ZWVuIGNvbnRlbnQgbGluZXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgYWxsIGxpbmUgYnJlYWtzIGV4Y2VwdCB0aGUgaGVhZGVyIGxpbmUgYnJlYWsuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRpZFJlYWRDb250ZW50ID0gdHJ1ZTtcbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIF9saW5lLFxuICAgICAgX3RhZyAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgID0gW10sXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBkZXRlY3RlZCAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuXG4gICAgaWYgKGNoICE9PSAweDJELyogLSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKCFpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA8PSBub2RlSW5kZW50KSB7XG4gICAgICAgIF9yZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ3NlcXVlbmNlJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfcG9zLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICAgICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgICAgID0ge30sXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSB7fSxcbiAgICAgIGtleVRhZyAgICAgICAgPSBudWxsLFxuICAgICAga2V5Tm9kZSAgICAgICA9IG51bGwsXG4gICAgICB2YWx1ZU5vZGUgICAgID0gbnVsbCxcbiAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkICAgICAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cbiAgICBfcG9zID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cbiAgICBpZiAoKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgzQS8qIDogKi8pICYmIGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2UgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgLy8gaS5lLiAweDNBLyogOiAqLyA9PT0gY2hhcmFjdGVyIGFmdGVyIHRoZSBleHBsaWNpdCBrZXkuXG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2luY29tcGxldGUgZXhwbGljaXQgbWFwcGluZyBwYWlyOyBhIGtleSBub2RlIGlzIG1pc3NlZDsgb3IgZm9sbG93ZWQgYnkgYSBub24tdGFidWxhdGVkIGVtcHR5IGxpbmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nO1xuXG4gICAgLy9cbiAgICAvLyBJbXBsaWNpdCBub3RhdGlvbiBjYXNlLiBGbG93LXN0eWxlIG5vZGUgYXMgdGhlIGtleSBmaXJzdCwgdGhlbiBcIjpcIiwgYW5kIHRoZSB2YWx1ZS5cbiAgICAvL1xuICAgIH0gZWxzZSBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xuXG4gICAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICghaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Egd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgZXhwZWN0ZWQgYWZ0ZXIgdGhlIGtleS12YWx1ZSBzZXBhcmF0b3Igd2l0aGluIGEgYmxvY2sgbWFwcGluZycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IGZhbHNlO1xuICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGEgYmxvY2sgbWFwcGluZyBlbnRyeTsgYSBtdWx0aWxpbmUga2V5IG1heSBub3QgYmUgYW4gaW1wbGljaXQga2V5Jyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhazsgLy8gUmVhZGluZyBpcyBkb25lLiBHbyB0byB0aGUgZXBpbG9ndWUuXG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBDb21tb24gcmVhZGluZyBjb2RlIGZvciBib3RoIGV4cGxpY2l0IGFuZCBpbXBsaWNpdCBub3RhdGlvbnMuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpIHtcbiAgICAgIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9wb3MpO1xuICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQgJiYgKGNoICE9PSAwKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIG1hcHBpbmcgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBFcGlsb2d1ZS5cbiAgLy9cblxuICAvLyBTcGVjaWFsIGNhc2U6IGxhc3QgbWFwcGluZydzIG5vZGUgY29udGFpbnMgb25seSB0aGUga2V5IGluIGV4cGxpY2l0IG5vdGF0aW9uLlxuICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ21hcHBpbmcnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgaXNWZXJiYXRpbSA9IGZhbHNlLFxuICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxuICAgICAgdGFnSGFuZGxlLFxuICAgICAgdGFnTmFtZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIxLyogISAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4M0MvKiA8ICovKSB7XG4gICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgaXNOYW1lZCA9IHRydWU7XG4gICAgdGFnSGFuZGxlID0gJyEhJztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGNoICE9PSAwICYmIGNoICE9PSAweDNFLyogPiAqLyk7XG5cbiAgICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgdmVyYmF0aW0gdGFnJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgIHRhZ0hhbmRsZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiAtIDEsIHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoUEFUVEVSTl9GTE9XX0lORElDQVRPUlMudGVzdCh0YWdOYW1lKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdOYW1lICYmICFQQVRURVJOX1RBR19VUkkudGVzdCh0YWdOYW1lKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgc3RhdGUudGFnID0gdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgdGFnSGFuZGxlKSkge1xuICAgIHN0YXRlLnRhZyA9IHN0YXRlLnRhZ01hcFt0YWdIYW5kbGVdICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEnKSB7XG4gICAgc3RhdGUudGFnID0gJyEnICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEhJykge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmRlY2xhcmVkIHRhZyBoYW5kbGUgXCInICsgdGFnSGFuZGxlICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNi8qICYgKi8pIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MkEvKiAqICovKSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIXN0YXRlLmFuY2hvck1hcC5oYXNPd25Qcm9wZXJ0eShhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgaW5kZW50U3RhdHVzID0gMSwgLy8gMTogdGhpcz5wYXJlbnQsIDA6IHRoaXM9cGFyZW50LCAtMTogdGhpczxwYXJlbnRcbiAgICAgIGF0TmV3TGluZSAgPSBmYWxzZSxcbiAgICAgIGhhc0NvbnRlbnQgPSBmYWxzZSxcbiAgICAgIHR5cGVJbmRleCxcbiAgICAgIHR5cGVRdWFudGl0eSxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICchJykge1xuICAgIGlmIChzdGF0ZS50YWcgPT09ICc/Jykge1xuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5OyB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1t0eXBlSW5kZXhdO1xuXG4gICAgICAgIC8vIEltcGxpY2l0IHJlc29sdmluZyBpcyBub3QgYWxsb3dlZCBmb3Igbm9uLXNjYWxhciB0eXBlcywgYW5kICc/J1xuICAgICAgICAvLyBub24tc3BlY2lmaWMgdGFnIGlzIG9ubHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy4gU28sIGl0IGlzbid0XG4gICAgICAgIC8vIG5lZWRlZCB0byBjaGVjayBmb3IgJ2tpbmQnIGNvbmZvcm1pdHkuXG5cbiAgICAgICAgaWYgKHR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ10sIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ11bc3RhdGUudGFnXTtcblxuICAgICAgaWYgKHN0YXRlLnJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlLmtpbmQgIT09IHN0YXRlLmtpbmQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8JyArIHN0YXRlLnRhZyArICc+IGV4cGxpY2l0IHRhZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIHRhZyAhPCcgKyBzdGF0ZS50YWcgKyAnPicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5saXN0ZW5lciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmxpc3RlbmVyKCdjbG9zZScsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gc3RhdGUudGFnICE9PSBudWxsIHx8ICBzdGF0ZS5hbmNob3IgIT09IG51bGwgfHwgaGFzQ29udGVudDtcbn1cblxuZnVuY3Rpb24gcmVhZERvY3VtZW50KHN0YXRlKSB7XG4gIHZhciBkb2N1bWVudFN0YXJ0ID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBfcG9zaXRpb24sXG4gICAgICBkaXJlY3RpdmVOYW1lLFxuICAgICAgZGlyZWN0aXZlQXJncyxcbiAgICAgIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIHN0YXRlLnZlcnNpb24gPSBudWxsO1xuICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSBzdGF0ZS5sZWdhY3k7XG4gIHN0YXRlLnRhZ01hcCA9IHt9O1xuICBzdGF0ZS5hbmNob3JNYXAgPSB7fTtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gMCB8fCBjaCAhPT0gMHgyNS8qICUgKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGRpcmVjdGl2ZU5hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICBkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX0VPTChjaCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzX0VPTChjaCkpIGJyZWFrO1xuXG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDApIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpcmVjdGl2ZUhhbmRsZXJzLCBkaXJlY3RpdmVOYW1lKSkge1xuICAgICAgZGlyZWN0aXZlSGFuZGxlcnNbZGlyZWN0aXZlTmFtZV0oc3RhdGUsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bmtub3duIGRvY3VtZW50IGRpcmVjdGl2ZSBcIicgKyBkaXJlY3RpdmVOYW1lICsgJ1wiJyk7XG4gICAgfVxuICB9XG5cbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSAwICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSAgICAgPT09IDB4MkQvKiAtICovICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSkgPT09IDB4MkQvKiAtICovICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMikgPT09IDB4MkQvKiAtICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgfSBlbHNlIGlmIChoYXNEaXJlY3RpdmVzKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZXMgZW5kIG1hcmsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGNvbXBvc2VOb2RlKHN0YXRlLCBzdGF0ZS5saW5lSW5kZW50IC0gMSwgQ09OVEVYVF9CTE9DS19PVVQsIGZhbHNlLCB0cnVlKTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5jaGVja0xpbmVCcmVha3MgJiZcbiAgICAgIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTLnRlc3Qoc3RhdGUuaW5wdXQuc2xpY2UoZG9jdW1lbnRTdGFydCwgc3RhdGUucG9zaXRpb24pKSkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ25vbi1BU0NJSSBsaW5lIGJyZWFrcyBhcmUgaW50ZXJwcmV0ZWQgYXMgY29udGVudCcpO1xuICB9XG5cbiAgc3RhdGUuZG9jdW1lbnRzLnB1c2goc3RhdGUucmVzdWx0KTtcblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG5cbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MkUvKiAuICovKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSB7XG4gIGlucHV0ID0gU3RyaW5nKGlucHV0KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCAhPT0gMCkge1xuXG4gICAgLy8gQWRkIHRhaWxpbmcgYFxcbmAgaWYgbm90IGV4aXN0c1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBBLyogTEYgKi8gJiZcbiAgICAgICAgaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSAhPT0gMHgwRC8qIENSICovKSB7XG4gICAgICBpbnB1dCArPSAnXFxuJztcbiAgICB9XG5cbiAgICAvLyBTdHJpcCBCT01cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgLy8gVXNlIDAgYXMgc3RyaW5nIHRlcm1pbmF0b3IuIFRoYXQgc2lnbmlmaWNhbnRseSBzaW1wbGlmaWVzIGJvdW5kcyBjaGVjay5cbiAgc3RhdGUuaW5wdXQgKz0gJ1xcMCc7XG5cbiAgd2hpbGUgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICBzdGF0ZS5saW5lSW5kZW50ICs9IDE7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHJlYWREb2N1bWVudChzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuZG9jdW1lbnRzO1xufVxuXG5cbmZ1bmN0aW9uIGxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSwgaW5kZXgsIGxlbmd0aDtcblxuICBpZiAodHlwZW9mIGl0ZXJhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50cztcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkb2N1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGl0ZXJhdG9yKGRvY3VtZW50c1tpbmRleF0pO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZChpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50c1swXTtcbiAgfVxuICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignZXhwZWN0ZWQgYSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbSwgYnV0IGZvdW5kIG1vcmUnKTtcbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZEFsbChpbnB1dCwgb3V0cHV0LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbG9hZEFsbChpbnB1dCwgb3V0cHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9hZEFsbChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbG9hZChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgPSBsb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgPSBsb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgPSBzYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgID0gc2FmZUxvYWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2xvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmZ1bmN0aW9uIE1hcmsobmFtZSwgYnVmZmVyLCBwb3NpdGlvbiwgbGluZSwgY29sdW1uKSB7XG4gIHRoaXMubmFtZSAgICAgPSBuYW1lO1xuICB0aGlzLmJ1ZmZlciAgID0gYnVmZmVyO1xuICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIHRoaXMubGluZSAgICAgPSBsaW5lO1xuICB0aGlzLmNvbHVtbiAgID0gY29sdW1uO1xufVxuXG5cbk1hcmsucHJvdG90eXBlLmdldFNuaXBwZXQgPSBmdW5jdGlvbiBnZXRTbmlwcGV0KGluZGVudCwgbWF4TGVuZ3RoKSB7XG4gIHZhciBoZWFkLCBzdGFydCwgdGFpbCwgZW5kLCBzbmlwcGV0O1xuXG4gIGlmICghdGhpcy5idWZmZXIpIHJldHVybiBudWxsO1xuXG4gIGluZGVudCA9IGluZGVudCB8fCA0O1xuICBtYXhMZW5ndGggPSBtYXhMZW5ndGggfHwgNzU7XG5cbiAgaGVhZCA9ICcnO1xuICBzdGFydCA9IHRoaXMucG9zaXRpb247XG5cbiAgd2hpbGUgKHN0YXJ0ID4gMCAmJiAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChzdGFydCAtIDEpKSA9PT0gLTEpIHtcbiAgICBzdGFydCAtPSAxO1xuICAgIGlmICh0aGlzLnBvc2l0aW9uIC0gc3RhcnQgPiAobWF4TGVuZ3RoIC8gMiAtIDEpKSB7XG4gICAgICBoZWFkID0gJyAuLi4gJztcbiAgICAgIHN0YXJ0ICs9IDU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0YWlsID0gJyc7XG4gIGVuZCA9IHRoaXMucG9zaXRpb247XG5cbiAgd2hpbGUgKGVuZCA8IHRoaXMuYnVmZmVyLmxlbmd0aCAmJiAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChlbmQpKSA9PT0gLTEpIHtcbiAgICBlbmQgKz0gMTtcbiAgICBpZiAoZW5kIC0gdGhpcy5wb3NpdGlvbiA+IChtYXhMZW5ndGggLyAyIC0gMSkpIHtcbiAgICAgIHRhaWwgPSAnIC4uLiAnO1xuICAgICAgZW5kIC09IDU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzbmlwcGV0ID0gdGhpcy5idWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgcmV0dXJuIGNvbW1vbi5yZXBlYXQoJyAnLCBpbmRlbnQpICsgaGVhZCArIHNuaXBwZXQgKyB0YWlsICsgJ1xcbicgK1xuICAgICAgICAgY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCArIHRoaXMucG9zaXRpb24gLSBzdGFydCArIGhlYWQubGVuZ3RoKSArICdeJztcbn07XG5cblxuTWFyay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHZhciBzbmlwcGV0LCB3aGVyZSA9ICcnO1xuXG4gIGlmICh0aGlzLm5hbWUpIHtcbiAgICB3aGVyZSArPSAnaW4gXCInICsgdGhpcy5uYW1lICsgJ1wiICc7XG4gIH1cblxuICB3aGVyZSArPSAnYXQgbGluZSAnICsgKHRoaXMubGluZSArIDEpICsgJywgY29sdW1uICcgKyAodGhpcy5jb2x1bW4gKyAxKTtcblxuICBpZiAoIWNvbXBhY3QpIHtcbiAgICBzbmlwcGV0ID0gdGhpcy5nZXRTbmlwcGV0KCk7XG5cbiAgICBpZiAoc25pcHBldCkge1xuICAgICAgd2hlcmUgKz0gJzpcXG4nICsgc25pcHBldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2hlcmU7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFyaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbWFyay5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiAnJzsgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc3RyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107IH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3NlcS5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDoge307IH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21hcC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxOdWxsKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gMSAmJiBkYXRhID09PSAnficpIHx8XG4gICAgICAgICAobWF4ID09PSA0ICYmIChkYXRhID09PSAnbnVsbCcgfHwgZGF0YSA9PT0gJ051bGwnIHx8IGRhdGEgPT09ICdOVUxMJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PT0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTnVsbCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sTnVsbCxcbiAgcHJlZGljYXRlOiBpc051bGwsXG4gIHJlcHJlc2VudDoge1xuICAgIGNhbm9uaWNhbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ34nOyAgICB9LFxuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ251bGwnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05VTEwnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ051bGwnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL251bGwuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQm9vbGVhbihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSA0ICYmIChkYXRhID09PSAndHJ1ZScgfHwgZGF0YSA9PT0gJ1RydWUnIHx8IGRhdGEgPT09ICdUUlVFJykpIHx8XG4gICAgICAgICAobWF4ID09PSA1ICYmIChkYXRhID09PSAnZmFsc2UnIHx8IGRhdGEgPT09ICdGYWxzZScgfHwgZGF0YSA9PT0gJ0ZBTFNFJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQm9vbGVhbihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAndHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUcnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RSVUUnO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCb29sZWFuLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCb29sZWFuLFxuICBwcmVkaWNhdGU6IGlzQm9vbGVhbixcbiAgcmVwcmVzZW50OiB7XG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAndHJ1ZScgOiAnZmFsc2UnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RSVUUnIDogJ0ZBTFNFJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUcnVlJyA6ICdGYWxzZSc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvYm9vbC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgVHlwZSAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiBpc0hleENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHx8XG4gICAgICAgICAoKDB4NDEvKiBBICovIDw9IGMpICYmIChjIDw9IDB4NDYvKiBGICovKSkgfHxcbiAgICAgICAgICgoMHg2MS8qIGEgKi8gPD0gYykgJiYgKGMgPD0gMHg2Ni8qIGYgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNPY3RDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzNy8qIDcgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNEZWNDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGgsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBoYXNEaWdpdHMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmICghbWF4KSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBkYXRhW2luZGV4XTtcblxuICAvLyBzaWduXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHJldHVybiB0cnVlO1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcblxuICAgIC8vIGJhc2UgMiwgYmFzZSA4LCBiYXNlIDE2XG5cbiAgICBpZiAoY2ggPT09ICdiJykge1xuICAgICAgLy8gYmFzZSAyXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFpc0hleENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cbiAgICAvLyBiYXNlIDhcbiAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICBpZiAoIWlzT2N0Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICB9XG5cbiAgLy8gYmFzZSAxMCAoZXhjZXB0IDApIG9yIGJhc2UgNjBcblxuICAvLyB2YWx1ZSBzaG91bGQgbm90IHN0YXJ0IHdpdGggYF9gO1xuICBpZiAoY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgIGlmIChjaCA9PT0gJzonKSBicmVhaztcbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICB9XG5cbiAgLy8gU2hvdWxkIGhhdmUgZGlnaXRzIGFuZCBzaG91bGQgbm90IGVuZCB3aXRoIGBfYFxuICBpZiAoIWhhc0RpZ2l0cyB8fCBjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gaWYgIWJhc2U2MCAtIGRvbmU7XG4gIGlmIChjaCAhPT0gJzonKSByZXR1cm4gdHJ1ZTtcblxuICAvLyBiYXNlNjAgYWxtb3N0IG5vdCB1c2VkLCBubyBuZWVkcyB0byBvcHRpbWl6ZVxuICByZXR1cm4gL14oOlswLTVdP1swLTldKSskLy50ZXN0KGRhdGEuc2xpY2UoaW5kZXgpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEludGVnZXIoZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLCBzaWduID0gMSwgY2gsIGJhc2UsIGRpZ2l0cyA9IFtdO1xuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCdfJykgIT09IC0xKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9fL2csICcnKTtcbiAgfVxuXG4gIGNoID0gdmFsdWVbMF07XG5cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGlmIChjaCA9PT0gJy0nKSBzaWduID0gLTE7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICBjaCA9IHZhbHVlWzBdO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnMCcpIHJldHVybiAwO1xuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgaWYgKHZhbHVlWzFdID09PSAnYicpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDIpO1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ3gnKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgOCk7XG4gIH1cblxuICBpZiAodmFsdWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIHZhbHVlLnNwbGl0KCc6JykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VJbnQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMDtcbiAgICBiYXNlID0gMTtcblxuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSAoZCAqIGJhc2UpO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiZcbiAgICAgICAgIChvYmplY3QgJSAxID09PSAwICYmICFjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMGInICsgb2JqZWN0LnRvU3RyaW5nKDIpOyB9LFxuICAgIG9jdGFsOiAgICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMCcgICsgb2JqZWN0LnRvU3RyaW5nKDgpOyB9LFxuICAgIGRlY2ltYWw6ICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAgICAgICAgb2JqZWN0LnRvU3RyaW5nKDEwKTsgfSxcbiAgICBoZXhhZGVjaW1hbDogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gJzB4JyArIG9iamVjdC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBZQU1MX0ZMT0FUX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFxuICAvLyAyLjVlNCwgMi41IGFuZCBpbnRlZ2Vyc1xuICAnXig/OlstK10/KD86MHxbMS05XVswLTlfXSopKD86XFxcXC5bMC05X10qKT8oPzpbZUVdWy0rXT9bMC05XSspPycgK1xuICAvLyAuMmU0LCAuMlxuICAvLyBzcGVjaWFsIGNhc2UsIHNlZW1zIG5vdCBmcm9tIHNwZWNcbiAgJ3xcXFxcLlswLTlfXSsoPzpbZUVdWy0rXT9bMC05XSspPycgK1xuICAvLyAyMDo1OVxuICAnfFstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKStcXFxcLlswLTlfXSonICtcbiAgLy8gLmluZlxuICAnfFstK10/XFxcXC4oPzppbmZ8SW5mfElORiknICtcbiAgLy8gLm5hblxuICAnfFxcXFwuKD86bmFufE5hTnxOQU4pKSQnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxGbG9hdChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKCFZQU1MX0ZMT0FUX1BBVFRFUk4udGVzdChkYXRhKSB8fFxuICAgICAgLy8gUXVpY2sgaGFjayB0byBub3QgYWxsb3cgaW50ZWdlcnMgZW5kIHdpdGggYF9gXG4gICAgICAvLyBQcm9iYWJseSBzaG91bGQgdXBkYXRlIHJlZ2V4cCAmIGNoZWNrIHNwZWVkXG4gICAgICBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09ICdfJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sRmxvYXQoZGF0YSkge1xuICB2YXIgdmFsdWUsIHNpZ24sIGJhc2UsIGRpZ2l0cztcblxuICB2YWx1ZSAgPSBkYXRhLnJlcGxhY2UoL18vZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIHNpZ24gICA9IHZhbHVlWzBdID09PSAnLScgPyAtMSA6IDE7XG4gIGRpZ2l0cyA9IFtdO1xuXG4gIGlmICgnKy0nLmluZGV4T2YodmFsdWVbMF0pID49IDApIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnLmluZicpIHtcbiAgICByZXR1cm4gKHNpZ24gPT09IDEpID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICcubmFuJykge1xuICAgIHJldHVybiBOYU47XG5cbiAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKCc6JykgPj0gMCkge1xuICAgIHZhbHVlLnNwbGl0KCc6JykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VGbG9hdCh2LCAxMCkpO1xuICAgIH0pO1xuXG4gICAgdmFsdWUgPSAwLjA7XG4gICAgYmFzZSA9IDE7XG5cbiAgICBkaWdpdHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgdmFsdWUgKz0gZCAqIGJhc2U7XG4gICAgICBiYXNlICo9IDYwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcblxuICB9XG4gIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xufVxuXG5cbnZhciBTQ0lFTlRJRklDX1dJVEhPVVRfRE9UID0gL15bLStdP1swLTldK2UvO1xuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sRmxvYXQob2JqZWN0LCBzdHlsZSkge1xuICB2YXIgcmVzO1xuXG4gIGlmIChpc05hTihvYmplY3QpKSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcubmFuJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLk5BTic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5OYU4nO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy0uaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLS5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICctLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKSB7XG4gICAgcmV0dXJuICctMC4wJztcbiAgfVxuXG4gIHJlcyA9IG9iamVjdC50b1N0cmluZygxMCk7XG5cbiAgLy8gSlMgc3RyaW5naWZpZXIgY2FuIGJ1aWxkIHNjaWVudGlmaWMgZm9ybWF0IHdpdGhvdXQgZG90czogNWUtMTAwLFxuICAvLyB3aGlsZSBZQU1MIHJlcXVyZXMgZG90OiA1LmUtMTAwLiBGaXggaXQgd2l0aCBzaW1wbGUgaGFja1xuXG4gIHJldHVybiBTQ0lFTlRJRklDX1dJVEhPVVRfRE9ULnRlc3QocmVzKSA/IHJlcy5yZXBsYWNlKCdlJywgJy5lJykgOiByZXM7XG59XG5cbmZ1bmN0aW9uIGlzRmxvYXQob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE51bWJlcl0nKSAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgIT09IDAgfHwgY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sRmxvYXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEZsb2F0LFxuICBwcmVkaWNhdGU6IGlzRmxvYXQsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEZsb2F0LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9mbG9hdC5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfREFURV9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldKSQnKTsgICAgICAgICAgICAgICAgICAgLy8gWzNdIGRheVxuXG52YXIgWUFNTF9USU1FU1RBTVBfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFszXSBkYXlcbiAgJyg/OltUdF18WyBcXFxcdF0rKScgICAgICAgICAgICAgICAgICsgLy8gLi4uXG4gICcoWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNF0gaG91clxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzVdIG1pbnV0ZVxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzZdIHNlY29uZFxuICAnKD86XFxcXC4oWzAtOV0qKSk/JyAgICAgICAgICAgICAgICAgKyAvLyBbN10gZnJhY3Rpb25cbiAgJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuICAnKD86OihbMC05XVswLTldKSk/KSk/JCcpOyAgICAgICAgICAgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24gPSAwLFxuICAgICAgZGVsdGEgPSBudWxsLCB0el9ob3VyLCB0el9taW51dGUsIGRhdGU7XG5cbiAgbWF0Y2ggPSBZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgbWF0Y2ggPSBZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKTtcblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignRGF0ZSByZXNvbHZlIGVycm9yJyk7XG5cbiAgLy8gbWF0Y2g6IFsxXSB5ZWFyIFsyXSBtb250aCBbM10gZGF5XG5cbiAgeWVhciA9ICsobWF0Y2hbMV0pO1xuICBtb250aCA9ICsobWF0Y2hbMl0pIC0gMTsgLy8gSlMgbW9udGggc3RhcnRzIHdpdGggMFxuICBkYXkgPSArKG1hdGNoWzNdKTtcblxuICBpZiAoIW1hdGNoWzRdKSB7IC8vIG5vIGhvdXJcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs0XSBob3VyIFs1XSBtaW51dGUgWzZdIHNlY29uZCBbN10gZnJhY3Rpb25cblxuICBob3VyID0gKyhtYXRjaFs0XSk7XG4gIG1pbnV0ZSA9ICsobWF0Y2hbNV0pO1xuICBzZWNvbmQgPSArKG1hdGNoWzZdKTtcblxuICBpZiAobWF0Y2hbN10pIHtcbiAgICBmcmFjdGlvbiA9IG1hdGNoWzddLnNsaWNlKDAsIDMpO1xuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCAzKSB7IC8vIG1pbGxpLXNlY29uZHNcbiAgICAgIGZyYWN0aW9uICs9ICcwJztcbiAgICB9XG4gICAgZnJhY3Rpb24gPSArZnJhY3Rpb247XG4gIH1cblxuICAvLyBtYXRjaDogWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91ciBbMTFdIHR6X21pbnV0ZVxuXG4gIGlmIChtYXRjaFs5XSkge1xuICAgIHR6X2hvdXIgPSArKG1hdGNoWzEwXSk7XG4gICAgdHpfbWludXRlID0gKyhtYXRjaFsxMV0gfHwgMCk7XG4gICAgZGVsdGEgPSAodHpfaG91ciAqIDYwICsgdHpfbWludXRlKSAqIDYwMDAwOyAvLyBkZWx0YSBpbiBtaWxpLXNlY29uZHNcbiAgICBpZiAobWF0Y2hbOV0gPT09ICctJykgZGVsdGEgPSAtZGVsdGE7XG4gIH1cblxuICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uKSk7XG5cbiAgaWYgKGRlbHRhKSBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSBkZWx0YSk7XG5cbiAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxUaW1lc3RhbXAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxUaW1lc3RhbXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFRpbWVzdGFtcCxcbiAgaW5zdGFuY2VPZjogRGF0ZSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sVGltZXN0YW1wXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS90aW1lc3RhbXAuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTWVyZ2UoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJzw8JyB8fCBkYXRhID09PSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTWVyZ2Vcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21lcmdlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG5cbnZhciBOb2RlQnVmZmVyO1xuXG50cnkge1xuICAvLyBBIHRyaWNrIGZvciBicm93c2VyaWZpZWQgdmVyc2lvbiwgdG8gbm90IGluY2x1ZGUgYEJ1ZmZlcmAgc2hpbVxuICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlO1xuICBOb2RlQnVmZmVyID0gX3JlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbn0gY2F0Y2ggKF9fKSB7fVxuXG52YXIgVHlwZSAgICAgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuXG4vLyBbIDY0LCA2NSwgNjYgXSAtPiBbIHBhZGRpbmcsIENSLCBMRiBdXG52YXIgQkFTRTY0X01BUCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVxcblxccic7XG5cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCaW5hcnkoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBjb2RlLCBpZHgsIGJpdGxlbiA9IDAsIG1heCA9IGRhdGEubGVuZ3RoLCBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgb25lIGJ5IG9uZS5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgY29kZSA9IG1hcC5pbmRleE9mKGRhdGEuY2hhckF0KGlkeCkpO1xuXG4gICAgLy8gU2tpcCBDUi9MRlxuICAgIGlmIChjb2RlID4gNjQpIGNvbnRpbnVlO1xuXG4gICAgLy8gRmFpbCBvbiBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDApIHJldHVybiBmYWxzZTtcblxuICAgIGJpdGxlbiArPSA2O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBiaXRzIGxlZnQsIHNvdXJjZSB3YXMgY29ycnVwdGVkXG4gIHJldHVybiAoYml0bGVuICUgOCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCaW5hcnkoZGF0YSkge1xuICB2YXIgaWR4LCB0YWlsYml0cyxcbiAgICAgIGlucHV0ID0gZGF0YS5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLCAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgICAgIG1heCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVAsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSA0ID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgNikgfCBtYXAuaW5kZXhPZihpbnB1dC5jaGFyQXQoaWR4KSk7XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsYml0cyA9IChtYXggJSA0KSAqIDY7XG5cbiAgaWYgKHRhaWxiaXRzID09PSAwKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDE4KSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTApICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMikgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTIpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA0KSAmIDB4RkYpO1xuICB9XG5cbiAgLy8gV3JhcCBpbnRvIEJ1ZmZlciBmb3IgTm9kZUpTIGFuZCBsZWF2ZSBBcnJheSBmb3IgYnJvd3NlclxuICBpZiAoTm9kZUJ1ZmZlcikge1xuICAgIC8vIFN1cHBvcnQgbm9kZSA2LisgQnVmZmVyIEFQSSB3aGVuIGF2YWlsYWJsZVxuICAgIHJldHVybiBOb2RlQnVmZmVyLmZyb20gPyBOb2RlQnVmZmVyLmZyb20ocmVzdWx0KSA6IG5ldyBOb2RlQnVmZmVyKHJlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sQmluYXJ5KG9iamVjdCAvKiwgc3R5bGUqLykge1xuICB2YXIgcmVzdWx0ID0gJycsIGJpdHMgPSAwLCBpZHgsIHRhaWwsXG4gICAgICBtYXggPSBvYmplY3QubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IGV2ZXJ5IHRocmVlIGJ5dGVzIHRvIDQgQVNDSUkgY2hhcmFjdGVycy5cblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBpZiAoKGlkeCAlIDMgPT09IDApICYmIGlkeCkge1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxOCkgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwW2JpdHMgJiAweDNGXTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgOCkgKyBvYmplY3RbaWR4XTtcbiAgfVxuXG4gIC8vIER1bXAgdGFpbFxuXG4gIHRhaWwgPSBtYXggJSAzO1xuXG4gIGlmICh0YWlsID09PSAwKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxOCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgJiAweDNGXTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAyKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA8PCAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDEpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA8PCA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNCaW5hcnkob2JqZWN0KSB7XG4gIHJldHVybiBOb2RlQnVmZmVyICYmIE5vZGVCdWZmZXIuaXNCdWZmZXIob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCaW5hcnksXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJpbmFyeSxcbiAgcHJlZGljYXRlOiBpc0JpbmFyeSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sQmluYXJ5XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9iaW5hcnkuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycigobGVuICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxPbWFwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBvYmplY3RLZXlzID0gW10sIGluZGV4LCBsZW5ndGgsIHBhaXIsIHBhaXJLZXksIHBhaXJIYXNLZXksXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHBhaXJIYXNLZXkgPSBmYWxzZTtcblxuICAgIGlmIChfdG9TdHJpbmcuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSBwYWlySGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob2JqZWN0S2V5cy5pbmRleE9mKHBhaXJLZXkpID09PSAtMSkgb2JqZWN0S2V5cy5wdXNoKHBhaXJLZXkpO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxPbWFwKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sT21hcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sT21hcFxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvb21hcC5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKF90b1N0cmluZy5jYWxsKHBhaXIpICE9PSAnW29iamVjdCBPYmplY3RdJykgcmV0dXJuIGZhbHNlO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxQYWlycyxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sUGFpcnNcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3BhaXJzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxTZXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGtleSwgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBpZiAob2JqZWN0W2tleV0gIT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFNldChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxTZXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFNldFxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy91bmRlZmluZWQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBwcmVkaWNhdGU6IGlzVW5kZWZpbmVkLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWRcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2pzL3VuZGVmaW5lZC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgICA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJztcblxuICAvLyBpZiByZWdleHAgc3RhcnRzIHdpdGggJy8nIGl0IGNhbiBoYXZlIG1vZGlmaWVycyBhbmQgbXVzdCBiZSBwcm9wZXJseSBjbG9zZWRcbiAgLy8gYC9mb28vZ2ltYCAtIG1vZGlmaWVycyB0YWlsIGNhbiBiZSBtYXhpbXVtIDMgY2hhcnNcbiAgaWYgKHJlZ2V4cFswXSA9PT0gJy8nKSB7XG4gICAgaWYgKHRhaWwpIG1vZGlmaWVycyA9IHRhaWxbMV07XG5cbiAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA+IDMpIHJldHVybiBmYWxzZTtcbiAgICAvLyBpZiBleHByZXNzaW9uIHN0YXJ0cyB3aXRoIC8sIGlzIHNob3VsZCBiZSBwcm9wZXJseSB0ZXJtaW5hdGVkXG4gICAgaWYgKHJlZ2V4cFtyZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDFdICE9PSAnLycpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgdmFyIHJlZ2V4cCA9IGRhdGEsXG4gICAgICB0YWlsICAgPSAvXFwvKFtnaW1dKikkLy5leGVjKGRhdGEpLFxuICAgICAgbW9kaWZpZXJzID0gJyc7XG5cbiAgLy8gYC9mb28vZ2ltYCAtIHRhaWwgY2FuIGJlIG1heGltdW0gNCBjaGFyc1xuICBpZiAocmVnZXhwWzBdID09PSAnLycpIHtcbiAgICBpZiAodGFpbCkgbW9kaWZpZXJzID0gdGFpbFsxXTtcbiAgICByZWdleHAgPSByZWdleHAuc2xpY2UoMSwgcmVnZXhwLmxlbmd0aCAtIG1vZGlmaWVycy5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cCwgbW9kaWZpZXJzKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcvJyArIG9iamVjdC5zb3VyY2UgKyAnLyc7XG5cbiAgaWYgKG9iamVjdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmIChvYmplY3QubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAob2JqZWN0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAsXG4gIHByZWRpY2F0ZTogaXNSZWdFeHAsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cFxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvcmVnZXhwLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBlc3ByaW1hO1xuXG4vLyBCcm93c2VyaWZpZWQgdmVyc2lvbiBkb2VzIG5vdCBoYXZlIGVzcHJpbWFcbi8vXG4vLyAxLiBGb3Igbm9kZS5qcyBqdXN0IHJlcXVpcmUgbW9kdWxlIGFzIGRlcHNcbi8vIDIuIEZvciBicm93c2VyIHRyeSB0byByZXF1aXJlIG11ZHVsZSB2aWEgZXh0ZXJuYWwgQU1EIHN5c3RlbS5cbi8vICAgIElmIG5vdCBmb3VuZCAtIHRyeSB0byBmYWxsYmFjayB0byB3aW5kb3cuZXNwcmltYS4gSWYgbm90XG4vLyAgICBmb3VuZCB0b28gLSB0aGVuIGZhaWwgdG8gcGFyc2UuXG4vL1xudHJ5IHtcbiAgLy8gd29ya2Fyb3VuZCB0byBleGNsdWRlIHBhY2thZ2UgZnJvbSBicm93c2VyaWZ5IGxpc3QuXG4gIHZhciBfcmVxdWlyZSA9IHJlcXVpcmU7XG4gIGVzcHJpbWEgPSBfcmVxdWlyZSgnZXNwcmltYScpO1xufSBjYXRjaCAoXykge1xuICAvKmdsb2JhbCB3aW5kb3cgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBlc3ByaW1hID0gd2luZG93LmVzcHJpbWE7XG59XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBzb3VyY2UgPSAnKCcgKyBkYXRhICsgJyknLFxuICAgICAgICBhc3QgICAgPSBlc3ByaW1hLnBhcnNlKHNvdXJjZSwgeyByYW5nZTogdHJ1ZSB9KTtcblxuICAgIGlmIChhc3QudHlwZSAgICAgICAgICAgICAgICAgICAgIT09ICdQcm9ncmFtJyAgICAgICAgICAgICB8fFxuICAgICAgICBhc3QuYm9keS5sZW5ndGggICAgICAgICAgICAgIT09IDEgICAgICAgICAgICAgICAgICAgICB8fFxuICAgICAgICBhc3QuYm9keVswXS50eXBlICAgICAgICAgICAgIT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyB8fFxuICAgICAgICBhc3QuYm9keVswXS5leHByZXNzaW9uLnR5cGUgIT09ICdGdW5jdGlvbkV4cHJlc3Npb24nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICAvKmpzbGludCBldmlsOnRydWUqL1xuXG4gIHZhciBzb3VyY2UgPSAnKCcgKyBkYXRhICsgJyknLFxuICAgICAgYXN0ICAgID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHsgcmFuZ2U6IHRydWUgfSksXG4gICAgICBwYXJhbXMgPSBbXSxcbiAgICAgIGJvZHk7XG5cbiAgaWYgKGFzdC50eXBlICAgICAgICAgICAgICAgICAgICAhPT0gJ1Byb2dyYW0nICAgICAgICAgICAgIHx8XG4gICAgICBhc3QuYm9keS5sZW5ndGggICAgICAgICAgICAgIT09IDEgICAgICAgICAgICAgICAgICAgICB8fFxuICAgICAgYXN0LmJvZHlbMF0udHlwZSAgICAgICAgICAgICE9PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgfHxcbiAgICAgIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSAhPT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBhc3QuYm9keVswXS5leHByZXNzaW9uLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHBhcmFtcy5wdXNoKHBhcmFtLm5hbWUpO1xuICB9KTtcblxuICBib2R5ID0gYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5ib2R5LnJhbmdlO1xuXG4gIC8vIEVzcHJpbWEncyByYW5nZXMgaW5jbHVkZSB0aGUgZmlyc3QgJ3snIGFuZCB0aGUgbGFzdCAnfScgY2hhcmFjdGVycyBvblxuICAvLyBmdW5jdGlvbiBleHByZXNzaW9ucy4gU28gY3V0IHRoZW0gb3V0LlxuICAvKmVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jKi9cbiAgcmV0dXJuIG5ldyBGdW5jdGlvbihwYXJhbXMsIHNvdXJjZS5zbGljZShib2R5WzBdICsgMSwgYm9keVsxXSAtIDEpKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6anMvZnVuY3Rpb24nLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdEZ1bmN0aW9uLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRGdW5jdGlvbixcbiAgcHJlZGljYXRlOiBpc0Z1bmN0aW9uLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRGdW5jdGlvblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvZnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZXNwcmltYVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJlc3ByaW1hXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0LypcclxuXHQgIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMsIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cclxuXHJcblx0ICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcclxuXHQgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG5cclxuXHQgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxyXG5cdCAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuXHQgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxyXG5cdCAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcclxuXHQgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG5cclxuXHQgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXHJcblx0ICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXHJcblx0ICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxyXG5cdCAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxyXG5cdCAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcclxuXHQgIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcclxuXHQgIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxyXG5cdCAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcclxuXHQgIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxyXG5cdCAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuXHQqL1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgY29tbWVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cdHZhciBqc3hfcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cdHZhciBwYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcblx0dmFyIHRva2VuaXplcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcblx0ZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIGNvbW1lbnRIYW5kbGVyID0gbnVsbDtcclxuXHQgICAgdmFyIHByb3h5RGVsZWdhdGUgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgIGRlbGVnYXRlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjb21tZW50SGFuZGxlcikge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRIYW5kbGVyLnZpc2l0KG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgdmFyIHBhcnNlckRlbGVnYXRlID0gKHR5cGVvZiBkZWxlZ2F0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm94eURlbGVnYXRlIDogbnVsbDtcclxuXHQgICAgdmFyIGNvbGxlY3RDb21tZW50ID0gZmFsc2U7XHJcblx0ICAgIGlmIChvcHRpb25zKSB7XHJcblx0ICAgICAgICBjb2xsZWN0Q29tbWVudCA9ICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KTtcclxuXHQgICAgICAgIHZhciBhdHRhY2hDb21tZW50ID0gKHR5cGVvZiBvcHRpb25zLmF0dGFjaENvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmF0dGFjaENvbW1lbnQpO1xyXG5cdCAgICAgICAgaWYgKGNvbGxlY3RDb21tZW50IHx8IGF0dGFjaENvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50SGFuZGxlciA9IG5ldyBjb21tZW50X2hhbmRsZXJfMS5Db21tZW50SGFuZGxlcigpO1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRIYW5kbGVyLmF0dGFjaCA9IGF0dGFjaENvbW1lbnQ7XHJcblx0ICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBwYXJzZXJEZWxlZ2F0ZSA9IHByb3h5RGVsZWdhdGU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIGlzTW9kdWxlID0gZmFsc2U7XHJcblx0ICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnNvdXJjZVR5cGUgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICBpc01vZHVsZSA9IChvcHRpb25zLnNvdXJjZVR5cGUgPT09ICdtb2R1bGUnKTtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgcGFyc2VyO1xyXG5cdCAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5qc3ggPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmpzeCkge1xyXG5cdCAgICAgICAgcGFyc2VyID0gbmV3IGpzeF9wYXJzZXJfMS5KU1hQYXJzZXIoY29kZSwgb3B0aW9ucywgcGFyc2VyRGVsZWdhdGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIGVsc2Uge1xyXG5cdCAgICAgICAgcGFyc2VyID0gbmV3IHBhcnNlcl8xLlBhcnNlcihjb2RlLCBvcHRpb25zLCBwYXJzZXJEZWxlZ2F0ZSk7XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIHByb2dyYW0gPSBpc01vZHVsZSA/IHBhcnNlci5wYXJzZU1vZHVsZSgpIDogcGFyc2VyLnBhcnNlU2NyaXB0KCk7XHJcblx0ICAgIHZhciBhc3QgPSBwcm9ncmFtO1xyXG5cdCAgICBpZiAoY29sbGVjdENvbW1lbnQgJiYgY29tbWVudEhhbmRsZXIpIHtcclxuXHQgICAgICAgIGFzdC5jb21tZW50cyA9IGNvbW1lbnRIYW5kbGVyLmNvbW1lbnRzO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmIChwYXJzZXIuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgYXN0LnRva2VucyA9IHBhcnNlci50b2tlbnM7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHBhcnNlci5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgIGFzdC5lcnJvcnMgPSBwYXJzZXIuZXJyb3JIYW5kbGVyLmVycm9ycztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gYXN0O1xyXG5cdH1cclxuXHRleHBvcnRzLnBhcnNlID0gcGFyc2U7XHJcblx0ZnVuY3Rpb24gcGFyc2VNb2R1bGUoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIHBhcnNpbmdPcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQgICAgcGFyc2luZ09wdGlvbnMuc291cmNlVHlwZSA9ICdtb2R1bGUnO1xyXG5cdCAgICByZXR1cm4gcGFyc2UoY29kZSwgcGFyc2luZ09wdGlvbnMsIGRlbGVnYXRlKTtcclxuXHR9XHJcblx0ZXhwb3J0cy5wYXJzZU1vZHVsZSA9IHBhcnNlTW9kdWxlO1xyXG5cdGZ1bmN0aW9uIHBhcnNlU2NyaXB0KGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciBwYXJzaW5nT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0ICAgIHBhcnNpbmdPcHRpb25zLnNvdXJjZVR5cGUgPSAnc2NyaXB0JztcclxuXHQgICAgcmV0dXJuIHBhcnNlKGNvZGUsIHBhcnNpbmdPcHRpb25zLCBkZWxlZ2F0ZSk7XHJcblx0fVxyXG5cdGV4cG9ydHMucGFyc2VTY3JpcHQgPSBwYXJzZVNjcmlwdDtcclxuXHRmdW5jdGlvbiB0b2tlbml6ZShjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgdG9rZW5pemVyID0gbmV3IHRva2VuaXplcl8xLlRva2VuaXplcihjb2RlLCBvcHRpb25zKTtcclxuXHQgICAgdmFyIHRva2VucztcclxuXHQgICAgdG9rZW5zID0gW107XHJcblx0ICAgIHRyeSB7XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2VuaXplci5nZXROZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRva2VuKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBkZWxlZ2F0ZSh0b2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICBjYXRjaCAoZSkge1xyXG5cdCAgICAgICAgdG9rZW5pemVyLmVycm9ySGFuZGxlci50b2xlcmF0ZShlKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodG9rZW5pemVyLmVycm9ySGFuZGxlci50b2xlcmFudCkge1xyXG5cdCAgICAgICAgdG9rZW5zLmVycm9ycyA9IHRva2VuaXplci5lcnJvcnMoKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gdG9rZW5zO1xyXG5cdH1cclxuXHRleHBvcnRzLnRva2VuaXplID0gdG9rZW5pemU7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHRleHBvcnRzLlN5bnRheCA9IHN5bnRheF8xLlN5bnRheDtcclxuXHQvLyBTeW5jIHdpdGggKi5qc29uIG1hbmlmZXN0cy5cclxuXHRleHBvcnRzLnZlcnNpb24gPSAnNC4wLjAnO1xyXG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdHZhciBDb21tZW50SGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbW1lbnRIYW5kbGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy5hdHRhY2ggPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcclxuXHQgICAgICAgIHRoaXMubGVhZGluZyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy50cmFpbGluZyA9IFtdO1xyXG5cdCAgICB9XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS5pbnNlcnRJbm5lckNvbW1lbnRzID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICAvLyAgaW5ubmVyQ29tbWVudHMgZm9yIHByb3BlcnRpZXMgZW1wdHkgYmxvY2tcclxuXHQgICAgICAgIC8vICBgZnVuY3Rpb24gYSgpIHsvKiogY29tbWVudHMgKipcXC99YFxyXG5cdCAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkJsb2NrU3RhdGVtZW50ICYmIG5vZGUuYm9keS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICB2YXIgaW5uZXJDb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlYWRpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5sZWFkaW5nW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEuZW5kLm9mZnNldCA+PSBlbnRyeS5zdGFydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5uZXJDb21tZW50cy51bnNoaWZ0KGVudHJ5LmNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhaWxpbmcuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChpbm5lckNvbW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICBub2RlLmlubmVyQ29tbWVudHMgPSBpbm5lckNvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLmZpbmRUcmFpbGluZ0NvbW1lbnRzID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICB2YXIgdHJhaWxpbmdDb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhaWxpbmcubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyYWlsaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeV8xID0gdGhpcy50cmFpbGluZ1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGVudHJ5XzEuc3RhcnQgPj0gbWV0YWRhdGEuZW5kLm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cy51bnNoaWZ0KGVudHJ5XzEuY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy50cmFpbGluZy5sZW5ndGggPSAwO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50cykge1xyXG5cdCAgICAgICAgICAgIHZhciBmaXJzdENvbW1lbnQgPSBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHNbMF07XHJcblx0ICAgICAgICAgICAgaWYgKGZpcnN0Q29tbWVudCAmJiBmaXJzdENvbW1lbnQucmFuZ2VbMF0gPj0gbWV0YWRhdGEuZW5kLm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzID0gZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUuZmluZExlYWRpbmdDb21tZW50cyA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgdmFyIGxlYWRpbmdDb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHRhcmdldDtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5LnN0YXJ0ID49IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbnRyeS5ub2RlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRhcmdldCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjb3VudCA9IHRhcmdldC5sZWFkaW5nQ29tbWVudHMgPyB0YXJnZXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA6IDA7XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IGNvdW50IC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5yYW5nZVsxXSA8PSBtZXRhZGF0YS5zdGFydC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cy51bnNoaWZ0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHRhcmdldC5sZWFkaW5nQ29tbWVudHMgJiYgdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldC5sZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHJldHVybiBsZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZWFkaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5sZWFkaW5nW2ldO1xyXG5cdCAgICAgICAgICAgIGlmIChlbnRyeS5zdGFydCA8PSBtZXRhZGF0YS5zdGFydC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLnVuc2hpZnQoZW50cnkuY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGVhZGluZy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGxlYWRpbmdDb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLnZpc2l0Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlByb2dyYW0gJiYgbm9kZS5ib2R5Lmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmluc2VydElubmVyQ29tbWVudHMobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgdmFyIHRyYWlsaW5nQ29tbWVudHMgPSB0aGlzLmZpbmRUcmFpbGluZ0NvbW1lbnRzKG1ldGFkYXRhKTtcclxuXHQgICAgICAgIHZhciBsZWFkaW5nQ29tbWVudHMgPSB0aGlzLmZpbmRMZWFkaW5nQ29tbWVudHMobWV0YWRhdGEpO1xyXG5cdCAgICAgICAgaWYgKGxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBsZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodHJhaWxpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gdHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XHJcblx0ICAgICAgICAgICAgbm9kZTogbm9kZSxcclxuXHQgICAgICAgICAgICBzdGFydDogbWV0YWRhdGEuc3RhcnQub2Zmc2V0XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgdmFyIHR5cGUgPSAobm9kZS50eXBlWzBdID09PSAnTCcpID8gJ0xpbmUnIDogJ0Jsb2NrJztcclxuXHQgICAgICAgIHZhciBjb21tZW50ID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcblx0ICAgICAgICAgICAgdmFsdWU6IG5vZGUudmFsdWVcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAobm9kZS5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnQucmFuZ2UgPSBub2RlLnJhbmdlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG5vZGUubG9jKSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudC5sb2MgPSBub2RlLmxvYztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29tbWVudHMucHVzaChjb21tZW50KTtcclxuXHQgICAgICAgIGlmICh0aGlzLmF0dGFjaCkge1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgY29tbWVudDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlLnZhbHVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFttZXRhZGF0YS5zdGFydC5vZmZzZXQsIG1ldGFkYXRhLmVuZC5vZmZzZXRdXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBtZXRhZGF0YS5zdGFydC5vZmZzZXRcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGlmIChub2RlLmxvYykge1xyXG5cdCAgICAgICAgICAgICAgICBlbnRyeS5jb21tZW50LmxvYyA9IG5vZGUubG9jO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBub2RlLnR5cGUgPSB0eXBlO1xyXG5cdCAgICAgICAgICAgIHRoaXMubGVhZGluZy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICB0aGlzLnRyYWlsaW5nLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdMaW5lQ29tbWVudCcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZpc2l0Q29tbWVudChub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdCbG9ja0NvbW1lbnQnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52aXNpdENvbW1lbnQobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5hdHRhY2gpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZpc2l0Tm9kZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBDb21tZW50SGFuZGxlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29tbWVudEhhbmRsZXIgPSBDb21tZW50SGFuZGxlcjtcclxuXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5TeW50YXggPSB7XHJcblx0ICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxyXG5cdCAgICBBc3NpZ25tZW50UGF0dGVybjogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcclxuXHQgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcclxuXHQgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcclxuXHQgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXHJcblx0ICAgIEF3YWl0RXhwcmVzc2lvbjogJ0F3YWl0RXhwcmVzc2lvbicsXHJcblx0ICAgIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLFxyXG5cdCAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXHJcblx0ICAgIEJyZWFrU3RhdGVtZW50OiAnQnJlYWtTdGF0ZW1lbnQnLFxyXG5cdCAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcclxuXHQgICAgQ2F0Y2hDbGF1c2U6ICdDYXRjaENsYXVzZScsXHJcblx0ICAgIENsYXNzQm9keTogJ0NsYXNzQm9keScsXHJcblx0ICAgIENsYXNzRGVjbGFyYXRpb246ICdDbGFzc0RlY2xhcmF0aW9uJyxcclxuXHQgICAgQ2xhc3NFeHByZXNzaW9uOiAnQ2xhc3NFeHByZXNzaW9uJyxcclxuXHQgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcclxuXHQgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXHJcblx0ICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcclxuXHQgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXHJcblx0ICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxyXG5cdCAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogJ0V4cG9ydEFsbERlY2xhcmF0aW9uJyxcclxuXHQgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyxcclxuXHQgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogJ0V4cG9ydE5hbWVkRGVjbGFyYXRpb24nLFxyXG5cdCAgICBFeHBvcnRTcGVjaWZpZXI6ICdFeHBvcnRTcGVjaWZpZXInLFxyXG5cdCAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXHJcblx0ICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXHJcblx0ICAgIEZvck9mU3RhdGVtZW50OiAnRm9yT2ZTdGF0ZW1lbnQnLFxyXG5cdCAgICBGb3JJblN0YXRlbWVudDogJ0ZvckluU3RhdGVtZW50JyxcclxuXHQgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxyXG5cdCAgICBGdW5jdGlvbkV4cHJlc3Npb246ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxyXG5cdCAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXHJcblx0ICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxyXG5cdCAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcclxuXHQgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxyXG5cdCAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxyXG5cdCAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxyXG5cdCAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXHJcblx0ICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcclxuXHQgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXHJcblx0ICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcclxuXHQgICAgTWV0YVByb3BlcnR5OiAnTWV0YVByb3BlcnR5JyxcclxuXHQgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxyXG5cdCAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXHJcblx0ICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcclxuXHQgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxyXG5cdCAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXHJcblx0ICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxyXG5cdCAgICBSZXN0RWxlbWVudDogJ1Jlc3RFbGVtZW50JyxcclxuXHQgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcclxuXHQgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcclxuXHQgICAgU3ByZWFkRWxlbWVudDogJ1NwcmVhZEVsZW1lbnQnLFxyXG5cdCAgICBTdXBlcjogJ1N1cGVyJyxcclxuXHQgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxyXG5cdCAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxyXG5cdCAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxyXG5cdCAgICBUZW1wbGF0ZUVsZW1lbnQ6ICdUZW1wbGF0ZUVsZW1lbnQnLFxyXG5cdCAgICBUZW1wbGF0ZUxpdGVyYWw6ICdUZW1wbGF0ZUxpdGVyYWwnLFxyXG5cdCAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcclxuXHQgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXHJcblx0ICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXHJcblx0ICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXHJcblx0ICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcclxuXHQgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxyXG5cdCAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxyXG5cdCAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcclxuXHQgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnLFxyXG5cdCAgICBZaWVsZEV4cHJlc3Npb246ICdZaWVsZEV4cHJlc3Npb24nXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG5cdCAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG5cdCAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG5cdCAgICB9O1xyXG5cdH0pKCk7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBjaGFyYWN0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblx0dmFyIEpTWE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cdHZhciBqc3hfc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdHZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHR2YXIgcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cdHZhciB0b2tlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0dmFyIHhodG1sX2VudGl0aWVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuXHR0b2tlbl8xLlRva2VuTmFtZVsxMDAgLyogSWRlbnRpZmllciAqL10gPSAnSlNYSWRlbnRpZmllcic7XHJcblx0dG9rZW5fMS5Ub2tlbk5hbWVbMTAxIC8qIFRleHQgKi9dID0gJ0pTWFRleHQnO1xyXG5cdC8vIEZ1bGx5IHF1YWxpZmllZCBlbGVtZW50IG5hbWUsIGUuZy4gPHN2ZzpwYXRoPiByZXR1cm5zIFwic3ZnOnBhdGhcIlxyXG5cdGZ1bmN0aW9uIGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGVsZW1lbnROYW1lKSB7XHJcblx0ICAgIHZhciBxdWFsaWZpZWROYW1lO1xyXG5cdCAgICBzd2l0Y2ggKGVsZW1lbnROYW1lLnR5cGUpIHtcclxuXHQgICAgICAgIGNhc2UganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hJZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHF1YWxpZmllZE5hbWUgPSBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgY2FzZSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE5hbWVzcGFjZWROYW1lOlxyXG5cdCAgICAgICAgICAgIHZhciBucyA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHF1YWxpZmllZE5hbWUgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShucy5uYW1lc3BhY2UpICsgJzonICtcclxuXHQgICAgICAgICAgICAgICAgZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUobnMubmFtZSk7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICBjYXNlIGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTWVtYmVyRXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICB2YXIgZXhwciA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHF1YWxpZmllZE5hbWUgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShleHByLm9iamVjdCkgKyAnLicgK1xyXG5cdCAgICAgICAgICAgICAgICBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShleHByLnByb3BlcnR5KTtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBxdWFsaWZpZWROYW1lO1xyXG5cdH1cclxuXHR2YXIgSlNYUGFyc2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuXHQgICAgX19leHRlbmRzKEpTWFBhcnNlciwgX3N1cGVyKTtcclxuXHQgICAgZnVuY3Rpb24gSlNYUGFyc2VyKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHx8IHRoaXM7XHJcblx0ICAgIH1cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByaW1hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goJzwnKSA/IHRoaXMucGFyc2VKU1hSb290KCkgOiBfc3VwZXIucHJvdG90eXBlLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24uY2FsbCh0aGlzKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5zdGFydEpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIFVud2luZCB0aGUgc2Nhbm5lciBiZWZvcmUgdGhlIGxvb2thaGVhZCB0b2tlbi5cclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5pbmRleCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIubGluZU51bWJlciA9IHRoaXMuc3RhcnRNYXJrZXIubGluZTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQgPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4IC0gdGhpcy5zdGFydE1hcmtlci5jb2x1bW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuZmluaXNoSlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gUHJpbWUgdGhlIG5leHQgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5yZWVudGVySlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5zdGFydEpTWCgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ30nKTtcclxuXHQgICAgICAgIC8vIFBvcCB0aGUgY2xvc2luZyAnfScgYWRkZWQgZnJvbSB0aGUgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmNyZWF0ZUpTWE5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVKU1hDaGlsZE5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnNjYW5YSFRNTEVudGl0eSA9IGZ1bmN0aW9uIChxdW90ZSkge1xyXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9ICcmJztcclxuXHQgICAgICAgIHZhciB2YWxpZCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgdGVybWluYXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG51bWVyaWMgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBoZXggPSBmYWxzZTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpICYmIHZhbGlkICYmICF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSAoY2ggPT09ICc7Jyk7XHJcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IGNoO1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmICghdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlc3VsdC5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuICcmIzEyMzsnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYyA9IChjaCA9PT0gJyMnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtZXJpYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuICcmI3g0MTsnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IChjaCA9PT0gJ3gnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBoZXggfHwgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljID0gbnVtZXJpYyAmJiAhaGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB2YWxpZCAmJiAhKG51bWVyaWMgJiYgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB2YWxpZCAmJiAhKGhleCAmJiAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQoY2guY2hhckNvZGVBdCgwKSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHZhbGlkICYmIHRlcm1pbmF0ZWQgJiYgcmVzdWx0Lmxlbmd0aCA+IDIpIHtcclxuXHQgICAgICAgICAgICAvLyBlLmcuICcmI3g0MTsnIGJlY29tZXMganVzdCAnI3g0MSdcclxuXHQgICAgICAgICAgICB2YXIgc3RyID0gcmVzdWx0LnN1YnN0cigxLCByZXN1bHQubGVuZ3RoIC0gMik7XHJcblx0ICAgICAgICAgICAgaWYgKG51bWVyaWMgJiYgc3RyLmxlbmd0aCA+IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxMCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChoZXggJiYgc3RyLmxlbmd0aCA+IDIpIHtcclxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCgnMCcgKyBzdHIuc3Vic3RyKDEpLCAxNikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICghbnVtZXJpYyAmJiAhaGV4ICYmIHhodG1sX2VudGl0aWVzXzEuWEhUTUxFbnRpdGllc1tzdHJdKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IHhodG1sX2VudGl0aWVzXzEuWEhUTUxFbnRpdGllc1tzdHJdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFNjYW4gdGhlIG5leHQgSlNYIHRva2VuLiBUaGlzIHJlcGxhY2VzIFNjYW5uZXIjbGV4IHdoZW4gaW4gSlNYIG1vZGUuXHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubGV4SlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCk7XHJcblx0ICAgICAgICAvLyA8ID4gLyA6ID0geyB9XHJcblx0ICAgICAgICBpZiAoY3AgPT09IDYwIHx8IGNwID09PSA2MiB8fCBjcCA9PT0gNDcgfHwgY3AgPT09IDU4IHx8IGNwID09PSA2MSB8fCBjcCA9PT0gMTIzIHx8IGNwID09PSAxMjUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiA3IC8qIFB1bmN0dWF0b3IgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc2Nhbm5lci5pbmRleCAtIDEsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFwiICdcclxuXHQgICAgICAgIGlmIChjcCA9PT0gMzQgfHwgY3AgPT09IDM5KSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHZhciBxdW90ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHZhciBzdHIgPSAnJztcclxuXHQgICAgICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcmJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMuc2NhblhIVE1MRW50aXR5KHF1b3RlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiA4IC8qIFN0cmluZ0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiBzdHIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gLi4uIG9yIC5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gNDYpIHtcclxuXHQgICAgICAgICAgICB2YXIgbjEgPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4ICsgMSk7XHJcblx0ICAgICAgICAgICAgdmFyIG4yID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCArIDIpO1xyXG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IChuMSA9PT0gNDYgJiYgbjIgPT09IDQ2KSA/ICcuLi4nIDogJy4nO1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIuaW5kZXggKz0gdmFsdWUubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogUHVuY3R1YXRvciAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIGBcclxuXHQgICAgICAgIGlmIChjcCA9PT0gOTYpIHtcclxuXHQgICAgICAgICAgICAvLyBPbmx5IHBsYWNlaG9sZGVyLCBzaW5jZSBpdCB3aWxsIGJlIHJlc2Nhbm5lZCBhcyBhIHJlYWwgYXNzaWdubWVudCBleHByZXNzaW9uLlxyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDEwIC8qIFRlbXBsYXRlICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIElkZW50aWZlciBjYW4gbm90IGNvbnRhaW4gYmFja3NsYXNoIChjaGFyIGNvZGUgOTIpLlxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjcCkgJiYgKGNwICE9PSA5MikpIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaCkgJiYgKGNoICE9PSA5MikpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSA0NSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSHlwaGVuIChjaGFyIGNvZGUgNDUpIGNhbiBiZSBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2Uoc3RhcnQsIHRoaXMuc2Nhbm5lci5pbmRleCk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogMTAwIC8qIElkZW50aWZpZXIgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiBpZCxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLm5leHRKU1hUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxleEpTWCgpO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4odG9rZW4pKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5uZXh0SlNYVGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHZhciB0ZXh0ID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICd7JyB8fCBjaCA9PT0gJzwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB0ZXh0ICs9IGNoO1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDEwMSAvKiBUZXh0ICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAoKHRleHQubGVuZ3RoID4gMCkgJiYgdGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbih0b2tlbikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBlZWtKU1hUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Nhbm5lci5zYXZlU3RhdGUoKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5sZXhKU1goKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5yZXN0b3JlU3RhdGUoc3RhdGUpO1xyXG5cdCAgICAgICAgcmV0dXJuIG5leHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCBKU1ggdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5leHBlY3RKU1ggPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gNyAvKiBQdW5jdHVhdG9yICovIHx8IHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCBKU1ggdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubWF0Y2hKU1ggPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5wZWVrSlNYVG9rZW4oKTtcclxuXHQgICAgICAgIHJldHVybiBuZXh0LnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiBuZXh0LnZhbHVlID09PSB2YWx1ZTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAxMDAgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRWxlbWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnROYW1lID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCc6JykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJzonKTtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZV8xID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBlbGVtZW50TmFtZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYTmFtZXNwYWNlZE5hbWUobmFtZXNwYWNlLCBuYW1lXzEpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hKU1goJy4nKSkge1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoSlNYKCcuJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50TmFtZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlTmFtZTtcclxuXHQgICAgICAgIHZhciBpZGVudGlmaWVyID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCc6JykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gaWRlbnRpZmllcjtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lXzIgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZV8yKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gaWRlbnRpZmllcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYU3RyaW5nTGl0ZXJhbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFeHByZXNzaW9uQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd7Jyk7XHJcblx0ICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcignSlNYIGF0dHJpYnV0ZXMgbXVzdCBvbmx5IGJlIGFzc2lnbmVkIGEgbm9uLWVtcHR5IGV4cHJlc3Npb24nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLnJlZW50ZXJKU1goKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5tYXRjaEpTWCgneycpID8gdGhpcy5wYXJzZUpTWEV4cHJlc3Npb25BdHRyaWJ1dGUoKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaEpTWCgnPCcpID8gdGhpcy5wYXJzZUpTWEVsZW1lbnQoKSA6IHRoaXMucGFyc2VKU1hTdHJpbmdMaXRlcmFsQXR0cmlidXRlKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hOYW1lVmFsdWVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlTmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPScpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZVZhbHVlKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWFNwcmVhZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgneycpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJy4uLicpO1xyXG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5yZWVudGVySlNYKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hTcHJlYWRBdHRyaWJ1dGUoYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoSlNYKCcvJykgJiYgIXRoaXMubWF0Y2hKU1goJz4nKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLm1hdGNoSlNYKCd7JykgPyB0aGlzLnBhcnNlSlNYU3ByZWFkQXR0cmlidXRlKCkgOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSlNYTmFtZVZhbHVlQXR0cmlidXRlKCk7XHJcblx0ICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWE9wZW5pbmdFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc8Jyk7XHJcblx0ICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VKU1hFbGVtZW50TmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlcygpO1xyXG5cdCAgICAgICAgdmFyIHNlbGZDbG9zaW5nID0gdGhpcy5tYXRjaEpTWCgnLycpO1xyXG5cdCAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy8nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc+Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hPcGVuaW5nRWxlbWVudChuYW1lLCBzZWxmQ2xvc2luZywgYXR0cmlidXRlcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQm91bmRhcnlFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc8Jyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnLycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy8nKTtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZV8zID0gdGhpcy5wYXJzZUpTWEVsZW1lbnROYW1lKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJz4nKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hDbG9zaW5nRWxlbWVudChuYW1lXzMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUpTWEVsZW1lbnROYW1lKCk7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVzKCk7XHJcblx0ICAgICAgICB2YXIgc2VsZkNsb3NpbmcgPSB0aGlzLm1hdGNoSlNYKCcvJyk7XHJcblx0ICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLycpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJz4nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE9wZW5pbmdFbGVtZW50KG5hbWUsIHNlbGZDbG9zaW5nLCBhdHRyaWJ1dGVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFbXB0eUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYQ2hpbGROb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRW1wdHlFeHByZXNzaW9uKCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgneycpO1xyXG5cdCAgICAgICAgdmFyIGV4cHJlc3Npb247XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VKU1hFbXB0eUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnfScpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5yZWVudGVySlNYKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFeHByZXNzaW9uQ29udGFpbmVyKGV4cHJlc3Npb24pKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hDaGlsZE5vZGUoKTtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUZXh0KCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnN0YXJ0IDwgdG9rZW4uZW5kKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hUZXh0KHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5wYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIoKTtcclxuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjb250YWluZXIpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29tcGxleEpTWEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcclxuXHQgICAgICAgIHZhciBzdGFjayA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBlbC5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmNvbmNhdCh0aGlzLnBhcnNlSlNYQ2hpbGRyZW4oKSk7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWENoaWxkTm9kZSgpO1xyXG5cdCAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUpTWEJvdW5kYXJ5RWxlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYT3BlbmluZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9wZW5pbmcgPSBlbGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAob3BlbmluZy5zZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFbGVtZW50KG9wZW5pbmcsIFtdLCBudWxsKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwgPSB7IG5vZGU6IG5vZGUsIG9wZW5pbmc6IG9wZW5pbmcsIGNsb3Npbmc6IG51bGwsIGNoaWxkcmVuOiBbXSB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYQ2xvc2luZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgZWwuY2xvc2luZyA9IGVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvcGVuXzEgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShlbC5vcGVuaW5nLm5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2xvc2VfMSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGVsLmNsb3NpbmcubmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChvcGVuXzEgIT09IGNsb3NlXzEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcignRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yICUwJywgb3Blbl8xKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5maW5hbGl6ZShlbC5ub2RlLCBuZXcgSlNYTm9kZS5KU1hFbGVtZW50KGVsLm9wZW5pbmcsIGVsLmNoaWxkcmVuLCBlbC5jbG9zaW5nKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGVsO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgb3BlbmluZyA9IHRoaXMucGFyc2VKU1hPcGVuaW5nRWxlbWVudCgpO1xyXG5cdCAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcblx0ICAgICAgICB2YXIgY2xvc2luZyA9IG51bGw7XHJcblx0ICAgICAgICBpZiAoIW9wZW5pbmcuc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLnBhcnNlQ29tcGxleEpTWEVsZW1lbnQoeyBub2RlOiBub2RlLCBvcGVuaW5nOiBvcGVuaW5nLCBjbG9zaW5nOiBjbG9zaW5nLCBjaGlsZHJlbjogY2hpbGRyZW4gfSk7XHJcblx0ICAgICAgICAgICAgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcclxuXHQgICAgICAgICAgICBjbG9zaW5nID0gZWwuY2xvc2luZztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEVsZW1lbnQob3BlbmluZywgY2hpbGRyZW4sIGNsb3NpbmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWFJvb3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBQb3AgdGhlIG9wZW5pbmcgJzwnIGFkZGVkIGZyb20gdGhlIGxvb2thaGVhZC5cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuc3RhcnRKU1goKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUpTWEVsZW1lbnQoKTtcclxuXHQgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5pc1N0YXJ0T2ZFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaXNTdGFydE9mRXhwcmVzc2lvbi5jYWxsKHRoaXMpIHx8IHRoaXMubWF0Y2goJzwnKTtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIEpTWFBhcnNlcjtcclxuXHR9KHBhcnNlcl8xLlBhcnNlcikpO1xyXG5cdGV4cG9ydHMuSlNYUGFyc2VyID0gSlNYUGFyc2VyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHQvLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LmpzLlxyXG5cdHZhciBSZWdleCA9IHtcclxuXHQgICAgLy8gVW5pY29kZSB2OC4wLjAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6XHJcblx0ICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiAvW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUItXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MFxcdURGOTMtXFx1REY5Rl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS8sXHJcblx0ICAgIC8vIFVuaWNvZGUgdjguMC4wIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6XHJcblx0ICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IC9bXFx4QUFcXHhCNVxceEI3XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4Ni1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCNFxcdTA4RTMtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBBRjlcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4LVxcdTBDNUFcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzY5LVxcdTEzNzFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEQVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5LVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVEREZEXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REVFMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3QVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0EwLVxcdURDQTlcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDAtXFx1REM0NlxcdURDNjYtXFx1REM2RlxcdURDN0YtXFx1RENCQVxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQzRlxcdURENTAtXFx1REQ3M1xcdURENzZcXHVERDgwLVxcdUREQzRcXHVERENBLVxcdUREQ0NcXHVEREQwLVxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTM3XFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFNjAtXFx1REU2OVxcdURFRDAtXFx1REVFRFxcdURFRjAtXFx1REVGNFxcdURGMDAtXFx1REYzNlxcdURGNDAtXFx1REY0M1xcdURGNTAtXFx1REY1OVxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwLVxcdURGN0VcXHVERjhGLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JcXHVERkNFLVxcdURGRkZdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1RENEMC1cXHVEQ0Q2XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1REI0MFtcXHVERDAwLVxcdURERUZdL1xyXG5cdH07XHJcblx0ZXhwb3J0cy5DaGFyYWN0ZXIgPSB7XHJcblx0ICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2UgKi9cclxuXHQgICAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwIDwgMHgxMDAwMCkgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKSA6XHJcblx0ICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgKyAoKGNwIC0gMHgxMDAwMCkgPj4gMTApKSArXHJcblx0ICAgICAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEQzAwICsgKChjcCAtIDB4MTAwMDApICYgMTAyMykpO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13aGl0ZS1zcGFjZVxyXG5cdCAgICBpc1doaXRlU3BhY2U6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgyMCkgfHwgKGNwID09PSAweDA5KSB8fCAoY3AgPT09IDB4MEIpIHx8IChjcCA9PT0gMHgwQykgfHwgKGNwID09PSAweEEwKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjcCkgPj0gMCk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpbmUtdGVybWluYXRvcnNcclxuXHQgICAgaXNMaW5lVGVybWluYXRvcjogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDBBKSB8fCAoY3AgPT09IDB4MEQpIHx8IChjcCA9PT0gMHgyMDI4KSB8fCAoY3AgPT09IDB4MjAyOSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW5hbWVzLWFuZC1rZXl3b3Jkc1xyXG5cdCAgICBpc0lkZW50aWZpZXJTdGFydDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDI0KSB8fCAoY3AgPT09IDB4NUYpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg1QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg2MSAmJiBjcCA8PSAweDdBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA9PT0gMHg1QykgfHxcclxuXHQgICAgICAgICAgICAoKGNwID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoZXhwb3J0cy5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCkpKTtcclxuXHQgICAgfSxcclxuXHQgICAgaXNJZGVudGlmaWVyUGFydDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDI0KSB8fCAoY3AgPT09IDB4NUYpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg1QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg2MSAmJiBjcCA8PSAweDdBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID09PSAweDVDKSB8fFxyXG5cdCAgICAgICAgICAgICgoY3AgPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KGV4cG9ydHMuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApKSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLW51bWVyaWMtbGl0ZXJhbHNcclxuXHQgICAgaXNEZWNpbWFsRGlnaXQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpOyAvLyAwLi45XHJcblx0ICAgIH0sXHJcblx0ICAgIGlzSGV4RGlnaXQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg0NikgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg2MSAmJiBjcCA8PSAweDY2KTsgLy8gYS4uZlxyXG5cdCAgICB9LFxyXG5cdCAgICBpc09jdGFsRGlnaXQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzcpOyAvLyAwLi43XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIganN4X3N5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHQvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5cdHZhciBKU1hDbG9zaW5nRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWENsb3NpbmdFbGVtZW50KG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYQ2xvc2luZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hDbG9zaW5nRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYQ2xvc2luZ0VsZW1lbnQgPSBKU1hDbG9zaW5nRWxlbWVudDtcclxuXHR2YXIgSlNYRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEVsZW1lbnQob3BlbmluZ0VsZW1lbnQsIGNoaWxkcmVuLCBjbG9zaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5vcGVuaW5nRWxlbWVudCA9IG9wZW5pbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG5cdCAgICAgICAgdGhpcy5jbG9zaW5nRWxlbWVudCA9IGNsb3NpbmdFbGVtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hFbGVtZW50ID0gSlNYRWxlbWVudDtcclxuXHR2YXIgSlNYRW1wdHlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYRW1wdHlFeHByZXNzaW9uKCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hFbXB0eUV4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEVtcHR5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYRW1wdHlFeHByZXNzaW9uID0gSlNYRW1wdHlFeHByZXNzaW9uO1xyXG5cdHZhciBKU1hFeHByZXNzaW9uQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEV4cHJlc3Npb25Db250YWluZXI7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hFeHByZXNzaW9uQ29udGFpbmVyID0gSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcclxuXHR2YXIgSlNYSWRlbnRpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWElkZW50aWZpZXIobmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hJZGVudGlmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYSWRlbnRpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYSWRlbnRpZmllciA9IEpTWElkZW50aWZpZXI7XHJcblx0dmFyIEpTWE1lbWJlckV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTWVtYmVyRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hNZW1iZXJFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hNZW1iZXJFeHByZXNzaW9uID0gSlNYTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR2YXIgSlNYQXR0cmlidXRlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYQXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEF0dHJpYnV0ZTtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEF0dHJpYnV0ZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYQXR0cmlidXRlID0gSlNYQXR0cmlidXRlO1xyXG5cdHZhciBKU1hOYW1lc3BhY2VkTmFtZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hOYW1lc3BhY2VkTmFtZTtcclxuXHQgICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYTmFtZXNwYWNlZE5hbWU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWE5hbWVzcGFjZWROYW1lID0gSlNYTmFtZXNwYWNlZE5hbWU7XHJcblx0dmFyIEpTWE9wZW5pbmdFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYT3BlbmluZ0VsZW1lbnQobmFtZSwgc2VsZkNsb3NpbmcsIGF0dHJpYnV0ZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYT3BlbmluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICAgICAgdGhpcy5zZWxmQ2xvc2luZyA9IHNlbGZDbG9zaW5nO1xyXG5cdCAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYT3BlbmluZ0VsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWE9wZW5pbmdFbGVtZW50ID0gSlNYT3BlbmluZ0VsZW1lbnQ7XHJcblx0dmFyIEpTWFNwcmVhZEF0dHJpYnV0ZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWFNwcmVhZEF0dHJpYnV0ZShhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hTcHJlYWRBdHRyaWJ1dGU7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWFNwcmVhZEF0dHJpYnV0ZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYU3ByZWFkQXR0cmlidXRlID0gSlNYU3ByZWFkQXR0cmlidXRlO1xyXG5cdHZhciBKU1hUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYVGV4dCh2YWx1ZSwgcmF3KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWFRleHQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnJhdyA9IHJhdztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYVGV4dDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYVGV4dCA9IEpTWFRleHQ7XHJcblxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuSlNYU3ludGF4ID0ge1xyXG5cdCAgICBKU1hBdHRyaWJ1dGU6ICdKU1hBdHRyaWJ1dGUnLFxyXG5cdCAgICBKU1hDbG9zaW5nRWxlbWVudDogJ0pTWENsb3NpbmdFbGVtZW50JyxcclxuXHQgICAgSlNYRWxlbWVudDogJ0pTWEVsZW1lbnQnLFxyXG5cdCAgICBKU1hFbXB0eUV4cHJlc3Npb246ICdKU1hFbXB0eUV4cHJlc3Npb24nLFxyXG5cdCAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyOiAnSlNYRXhwcmVzc2lvbkNvbnRhaW5lcicsXHJcblx0ICAgIEpTWElkZW50aWZpZXI6ICdKU1hJZGVudGlmaWVyJyxcclxuXHQgICAgSlNYTWVtYmVyRXhwcmVzc2lvbjogJ0pTWE1lbWJlckV4cHJlc3Npb24nLFxyXG5cdCAgICBKU1hOYW1lc3BhY2VkTmFtZTogJ0pTWE5hbWVzcGFjZWROYW1lJyxcclxuXHQgICAgSlNYT3BlbmluZ0VsZW1lbnQ6ICdKU1hPcGVuaW5nRWxlbWVudCcsXHJcblx0ICAgIEpTWFNwcmVhZEF0dHJpYnV0ZTogJ0pTWFNwcmVhZEF0dHJpYnV0ZScsXHJcblx0ICAgIEpTWFRleHQ6ICdKU1hUZXh0J1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0LyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuXHR2YXIgQXJyYXlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyYXlFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBcnJheUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFycmF5RXhwcmVzc2lvbiA9IEFycmF5RXhwcmVzc2lvbjtcclxuXHR2YXIgQXJyYXlQYXR0ZXJuID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXJyYXlQYXR0ZXJuKGVsZW1lbnRzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuO1xyXG5cdCAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBcnJheVBhdHRlcm47XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFycmF5UGF0dGVybiA9IEFycmF5UGF0dGVybjtcclxuXHR2YXIgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBBc3NpZ25tZW50RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzc2lnbm1lbnRFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXNzaWdubWVudEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzc2lnbm1lbnRFeHByZXNzaW9uID0gQXNzaWdubWVudEV4cHJlc3Npb247XHJcblx0dmFyIEFzc2lnbm1lbnRQYXR0ZXJuID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXNzaWdubWVudFBhdHRlcm4obGVmdCwgcmlnaHQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3NpZ25tZW50UGF0dGVybiA9IEFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdHZhciBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbiA9IEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR2YXIgQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3luY0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBBd2FpdEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBd2FpdEV4cHJlc3Npb24oYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bd2FpdEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEF3YWl0RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gQXdhaXRFeHByZXNzaW9uO1xyXG5cdHZhciBCaW5hcnlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcclxuXHQgICAgICAgIHZhciBsb2dpY2FsID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKTtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGxvZ2ljYWwgPyBzeW50YXhfMS5TeW50YXguTG9naWNhbEV4cHJlc3Npb24gOiBzeW50YXhfMS5TeW50YXguQmluYXJ5RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEJpbmFyeUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkJpbmFyeUV4cHJlc3Npb24gPSBCaW5hcnlFeHByZXNzaW9uO1xyXG5cdHZhciBCbG9ja1N0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEJsb2NrU3RhdGVtZW50KGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5CbG9ja1N0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEJsb2NrU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5CbG9ja1N0YXRlbWVudCA9IEJsb2NrU3RhdGVtZW50O1xyXG5cdHZhciBCcmVha1N0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEJyZWFrU3RhdGVtZW50KGxhYmVsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQnJlYWtTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEJyZWFrU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5CcmVha1N0YXRlbWVudCA9IEJyZWFrU3RhdGVtZW50O1xyXG5cdHZhciBDYWxsRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENhbGxFeHByZXNzaW9uKGNhbGxlZSwgYXJncykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNhbGxFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENhbGxFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DYWxsRXhwcmVzc2lvbiA9IENhbGxFeHByZXNzaW9uO1xyXG5cdHZhciBDYXRjaENsYXVzZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENhdGNoQ2xhdXNlKHBhcmFtLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2F0Y2hDbGF1c2U7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtID0gcGFyYW07XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDYXRjaENsYXVzZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2F0Y2hDbGF1c2UgPSBDYXRjaENsYXVzZTtcclxuXHR2YXIgQ2xhc3NCb2R5ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2xhc3NCb2R5KGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DbGFzc0JvZHk7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDbGFzc0JvZHk7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNsYXNzQm9keSA9IENsYXNzQm9keTtcclxuXHR2YXIgQ2xhc3NEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENsYXNzRGVjbGFyYXRpb24oaWQsIHN1cGVyQ2xhc3MsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DbGFzc0RlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENsYXNzRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNsYXNzRGVjbGFyYXRpb24gPSBDbGFzc0RlY2xhcmF0aW9uO1xyXG5cdHZhciBDbGFzc0V4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDbGFzc0V4cHJlc3Npb24oaWQsIHN1cGVyQ2xhc3MsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DbGFzc0V4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2xhc3NFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DbGFzc0V4cHJlc3Npb24gPSBDbGFzc0V4cHJlc3Npb247XHJcblx0dmFyIENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uID0gQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uO1xyXG5cdHZhciBDb25kaXRpb25hbEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb25kaXRpb25hbEV4cHJlc3Npb24odGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XHJcblx0ICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db25kaXRpb25hbEV4cHJlc3Npb24gPSBDb25kaXRpb25hbEV4cHJlc3Npb247XHJcblx0dmFyIENvbnRpbnVlU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29udGludWVTdGF0ZW1lbnQobGFiZWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Db250aW51ZVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ29udGludWVTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbnRpbnVlU3RhdGVtZW50ID0gQ29udGludWVTdGF0ZW1lbnQ7XHJcblx0dmFyIERlYnVnZ2VyU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRGVidWdnZXJTdGF0ZW1lbnQoKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRGVidWdnZXJTdGF0ZW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIERlYnVnZ2VyU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5EZWJ1Z2dlclN0YXRlbWVudCA9IERlYnVnZ2VyU3RhdGVtZW50O1xyXG5cdHZhciBEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBEaXJlY3RpdmUoZXhwcmVzc2lvbiwgZGlyZWN0aXZlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRGlyZWN0aXZlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5EaXJlY3RpdmUgPSBEaXJlY3RpdmU7XHJcblx0dmFyIERvV2hpbGVTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBEb1doaWxlU3RhdGVtZW50KGJvZHksIHRlc3QpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Eb1doaWxlU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIERvV2hpbGVTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkRvV2hpbGVTdGF0ZW1lbnQgPSBEb1doaWxlU3RhdGVtZW50O1xyXG5cdHZhciBFbXB0eVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEVtcHR5U3RhdGVtZW50KCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkVtcHR5U3RhdGVtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFbXB0eVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRW1wdHlTdGF0ZW1lbnQgPSBFbXB0eVN0YXRlbWVudDtcclxuXHR2YXIgRXhwb3J0QWxsRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnRBbGxEZWNsYXJhdGlvbihzb3VyY2UpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnRBbGxEZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnRBbGxEZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBFeHBvcnRBbGxEZWNsYXJhdGlvbjtcclxuXHR2YXIgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcclxuXHR2YXIgRXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIHNwZWNpZmllcnMsIHNvdXJjZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydE5hbWVkRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydE5hbWVkRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBFeHBvcnROYW1lZERlY2xhcmF0aW9uO1xyXG5cdHZhciBFeHBvcnRTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnRTcGVjaWZpZXIobG9jYWwsIGV4cG9ydGVkKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0U3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5leHBvcnRlZCA9IGV4cG9ydGVkO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnRTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydFNwZWNpZmllciA9IEV4cG9ydFNwZWNpZmllcjtcclxuXHR2YXIgRXhwcmVzc2lvblN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHByZXNzaW9uU3RhdGVtZW50ID0gRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHR2YXIgRm9ySW5TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvckluU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmVhY2ggPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRm9ySW5TdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZvckluU3RhdGVtZW50ID0gRm9ySW5TdGF0ZW1lbnQ7XHJcblx0dmFyIEZvck9mU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRm9yT2ZTdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Gb3JPZlN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGb3JPZlN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRm9yT2ZTdGF0ZW1lbnQgPSBGb3JPZlN0YXRlbWVudDtcclxuXHR2YXIgRm9yU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRm9yU3RhdGVtZW50KGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvclN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGb3JTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZvclN0YXRlbWVudCA9IEZvclN0YXRlbWVudDtcclxuXHR2YXIgRnVuY3Rpb25EZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSwgZ2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSBGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdHZhciBGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSwgZ2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5GdW5jdGlvbkV4cHJlc3Npb24gPSBGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIElkZW50aWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJZGVudGlmaWVyKG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSWRlbnRpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSWRlbnRpZmllciA9IElkZW50aWZpZXI7XHJcblx0dmFyIElmU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSWZTdGF0ZW1lbnQodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSWZTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcclxuXHQgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJZlN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSWZTdGF0ZW1lbnQgPSBJZlN0YXRlbWVudDtcclxuXHR2YXIgSW1wb3J0RGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCBzb3VyY2UpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0RGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydERlY2xhcmF0aW9uID0gSW1wb3J0RGVjbGFyYXRpb247XHJcblx0dmFyIEltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XHJcblx0dmFyIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihsb2NhbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XHJcblx0dmFyIEltcG9ydFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydFNwZWNpZmllcihsb2NhbCwgaW1wb3J0ZWQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnRTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgICAgICB0aGlzLmltcG9ydGVkID0gaW1wb3J0ZWQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydFNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0U3BlY2lmaWVyID0gSW1wb3J0U3BlY2lmaWVyO1xyXG5cdHZhciBMYWJlbGVkU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTGFiZWxlZFN0YXRlbWVudChsYWJlbCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkxhYmVsZWRTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBMYWJlbGVkU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5MYWJlbGVkU3RhdGVtZW50ID0gTGFiZWxlZFN0YXRlbWVudDtcclxuXHR2YXIgTGl0ZXJhbCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIExpdGVyYWwodmFsdWUsIHJhdykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWw7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnJhdyA9IHJhdztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTGl0ZXJhbDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTGl0ZXJhbCA9IExpdGVyYWw7XHJcblx0dmFyIE1ldGFQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE1ldGFQcm9wZXJ0eShtZXRhLCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1ldGFQcm9wZXJ0eTtcclxuXHQgICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE1ldGFQcm9wZXJ0eTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTWV0YVByb3BlcnR5ID0gTWV0YVByb3BlcnR5O1xyXG5cdHZhciBNZXRob2REZWZpbml0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTWV0aG9kRGVmaW5pdGlvbihrZXksIGNvbXB1dGVkLCB2YWx1ZSwga2luZCwgaXNTdGF0aWMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZXRob2REZWZpbml0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG5cdCAgICAgICAgdGhpcy5zdGF0aWMgPSBpc1N0YXRpYztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTWV0aG9kRGVmaW5pdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTWV0aG9kRGVmaW5pdGlvbiA9IE1ldGhvZERlZmluaXRpb247XHJcblx0dmFyIE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE1vZHVsZShib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUHJvZ3JhbTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZVR5cGUgPSAnbW9kdWxlJztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTW9kdWxlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Nb2R1bGUgPSBNb2R1bGU7XHJcblx0dmFyIE5ld0V4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBOZXdFeHByZXNzaW9uKGNhbGxlZSwgYXJncykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk5ld0V4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTmV3RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTmV3RXhwcmVzc2lvbiA9IE5ld0V4cHJlc3Npb247XHJcblx0dmFyIE9iamVjdEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5PYmplY3RFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gT2JqZWN0RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuT2JqZWN0RXhwcmVzc2lvbiA9IE9iamVjdEV4cHJlc3Npb247XHJcblx0dmFyIE9iamVjdFBhdHRlcm4gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBPYmplY3RQYXR0ZXJuKHByb3BlcnRpZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuO1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gT2JqZWN0UGF0dGVybjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuT2JqZWN0UGF0dGVybiA9IE9iamVjdFBhdHRlcm47XHJcblx0dmFyIFByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUHJvcGVydHkoa2luZCwga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUHJvcGVydHk7XHJcblx0ICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcblx0ICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcclxuXHQgICAgICAgIHRoaXMuc2hvcnRoYW5kID0gc2hvcnRoYW5kO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBQcm9wZXJ0eTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUHJvcGVydHkgPSBQcm9wZXJ0eTtcclxuXHR2YXIgUmVnZXhMaXRlcmFsID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmVnZXhMaXRlcmFsKHZhbHVlLCByYXcsIHBhdHRlcm4sIGZsYWdzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMucmF3ID0gcmF3O1xyXG5cdCAgICAgICAgdGhpcy5yZWdleCA9IHsgcGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzIH07XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFJlZ2V4TGl0ZXJhbDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUmVnZXhMaXRlcmFsID0gUmVnZXhMaXRlcmFsO1xyXG5cdHZhciBSZXN0RWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJlc3RFbGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFJlc3RFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5SZXN0RWxlbWVudCA9IFJlc3RFbGVtZW50O1xyXG5cdHZhciBSZXR1cm5TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZXR1cm5TdGF0ZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFJldHVyblN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUmV0dXJuU3RhdGVtZW50ID0gUmV0dXJuU3RhdGVtZW50O1xyXG5cdHZhciBTY3JpcHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTY3JpcHQoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlByb2dyYW07XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2VUeXBlID0gJ3NjcmlwdCc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFNjcmlwdDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU2NyaXB0ID0gU2NyaXB0O1xyXG5cdHZhciBTZXF1ZW5jZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFNlcXVlbmNlRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gU2VxdWVuY2VFeHByZXNzaW9uO1xyXG5cdHZhciBTcHJlYWRFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3ByZWFkRWxlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlNwcmVhZEVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFNwcmVhZEVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNwcmVhZEVsZW1lbnQgPSBTcHJlYWRFbGVtZW50O1xyXG5cdHZhciBTdGF0aWNNZW1iZXJFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3RhdGljTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTdGF0aWNNZW1iZXJFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TdGF0aWNNZW1iZXJFeHByZXNzaW9uID0gU3RhdGljTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR2YXIgU3VwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTdXBlcigpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5TdXBlcjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3VwZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN1cGVyID0gU3VwZXI7XHJcblx0dmFyIFN3aXRjaENhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTd2l0Y2hDYXNlKHRlc3QsIGNvbnNlcXVlbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Td2l0Y2hDYXNlO1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN3aXRjaENhc2U7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN3aXRjaENhc2UgPSBTd2l0Y2hDYXNlO1xyXG5cdHZhciBTd2l0Y2hTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlN3aXRjaFN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuZGlzY3JpbWluYW50ID0gZGlzY3JpbWluYW50O1xyXG5cdCAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTd2l0Y2hTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN3aXRjaFN0YXRlbWVudCA9IFN3aXRjaFN0YXRlbWVudDtcclxuXHR2YXIgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKHRhZywgcXVhc2kpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLnRhZyA9IHRhZztcclxuXHQgICAgICAgIHRoaXMucXVhc2kgPSBxdWFzaTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XHJcblx0dmFyIFRlbXBsYXRlRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRlbXBsYXRlRWxlbWVudCh2YWx1ZSwgdGFpbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRlbXBsYXRlRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRlbXBsYXRlRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGVtcGxhdGVFbGVtZW50ID0gVGVtcGxhdGVFbGVtZW50O1xyXG5cdHZhciBUZW1wbGF0ZUxpdGVyYWwgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUZW1wbGF0ZUxpdGVyYWwocXVhc2lzLCBleHByZXNzaW9ucykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRlbXBsYXRlTGl0ZXJhbDtcclxuXHQgICAgICAgIHRoaXMucXVhc2lzID0gcXVhc2lzO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUZW1wbGF0ZUxpdGVyYWw7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbCA9IFRlbXBsYXRlTGl0ZXJhbDtcclxuXHR2YXIgVGhpc0V4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUaGlzRXhwcmVzc2lvbigpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UaGlzRXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGhpc0V4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRoaXNFeHByZXNzaW9uID0gVGhpc0V4cHJlc3Npb247XHJcblx0dmFyIFRocm93U3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UaHJvd1N0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGhyb3dTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRocm93U3RhdGVtZW50ID0gVGhyb3dTdGF0ZW1lbnQ7XHJcblx0dmFyIFRyeVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRyeVN0YXRlbWVudChibG9jaywgaGFuZGxlciwgZmluYWxpemVyKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVHJ5U3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xyXG5cdCAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuXHQgICAgICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUcnlTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRyeVN0YXRlbWVudCA9IFRyeVN0YXRlbWVudDtcclxuXHR2YXIgVW5hcnlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgICAgIHRoaXMucHJlZml4ID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVW5hcnlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5VbmFyeUV4cHJlc3Npb24gPSBVbmFyeUV4cHJlc3Npb247XHJcblx0dmFyIFVwZGF0ZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBVcGRhdGVFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmd1bWVudCwgcHJlZml4KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVXBkYXRlRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBVcGRhdGVFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5VcGRhdGVFeHByZXNzaW9uID0gVXBkYXRlRXhwcmVzc2lvbjtcclxuXHR2YXIgVmFyaWFibGVEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xyXG5cdCAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVmFyaWFibGVEZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdGlvbiA9IFZhcmlhYmxlRGVjbGFyYXRpb247XHJcblx0dmFyIFZhcmlhYmxlRGVjbGFyYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFZhcmlhYmxlRGVjbGFyYXRvcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdG9yID0gVmFyaWFibGVEZWNsYXJhdG9yO1xyXG5cdHZhciBXaGlsZVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFdoaWxlU3RhdGVtZW50KHRlc3QsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5XaGlsZVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBXaGlsZVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuV2hpbGVTdGF0ZW1lbnQgPSBXaGlsZVN0YXRlbWVudDtcclxuXHR2YXIgV2l0aFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFdpdGhTdGF0ZW1lbnQob2JqZWN0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguV2l0aFN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gV2l0aFN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuV2l0aFN0YXRlbWVudCA9IFdpdGhTdGF0ZW1lbnQ7XHJcblx0dmFyIFlpZWxkRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFlpZWxkRXhwcmVzc2lvbihhcmd1bWVudCwgZGVsZWdhdGUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5ZaWVsZEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFlpZWxkRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuWWllbGRFeHByZXNzaW9uID0gWWllbGRFeHByZXNzaW9uO1xyXG5cblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgYXNzZXJ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cdHZhciBlcnJvcl9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHR2YXIgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cdHZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHR2YXIgc2Nhbm5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHR2YXIgdG9rZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cdHZhciBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyID0gJ0Fycm93UGFyYW1ldGVyUGxhY2VIb2xkZXInO1xyXG5cdHZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBQYXJzZXIoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcblx0ICAgICAgICB0aGlzLmNvbmZpZyA9IHtcclxuXHQgICAgICAgICAgICByYW5nZTogKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2UsXHJcblx0ICAgICAgICAgICAgbG9jOiAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jLFxyXG5cdCAgICAgICAgICAgIHNvdXJjZTogbnVsbCxcclxuXHQgICAgICAgICAgICB0b2tlbnM6ICh0eXBlb2Ygb3B0aW9ucy50b2tlbnMgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy50b2tlbnMsXHJcblx0ICAgICAgICAgICAgY29tbWVudDogKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5jb21tZW50LFxyXG5cdCAgICAgICAgICAgIHRvbGVyYW50OiAodHlwZW9mIG9wdGlvbnMudG9sZXJhbnQgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy50b2xlcmFudFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MgJiYgb3B0aW9ucy5zb3VyY2UgJiYgb3B0aW9ucy5zb3VyY2UgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbmZpZy5zb3VyY2UgPSBTdHJpbmcob3B0aW9ucy5zb3VyY2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBuZXcgZXJyb3JfaGFuZGxlcl8xLkVycm9ySGFuZGxlcigpO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhbnQgPSB0aGlzLmNvbmZpZy50b2xlcmFudDtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lciA9IG5ldyBzY2FubmVyXzEuU2Nhbm5lcihjb2RlLCB0aGlzLmVycm9ySGFuZGxlcik7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIudHJhY2tDb21tZW50ID0gdGhpcy5jb25maWcuY29tbWVudDtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3JQcmVjZWRlbmNlID0ge1xyXG5cdCAgICAgICAgICAgICcpJzogMCxcclxuXHQgICAgICAgICAgICAnOyc6IDAsXHJcblx0ICAgICAgICAgICAgJywnOiAwLFxyXG5cdCAgICAgICAgICAgICc9JzogMCxcclxuXHQgICAgICAgICAgICAnXSc6IDAsXHJcblx0ICAgICAgICAgICAgJ3x8JzogMSxcclxuXHQgICAgICAgICAgICAnJiYnOiAyLFxyXG5cdCAgICAgICAgICAgICd8JzogMyxcclxuXHQgICAgICAgICAgICAnXic6IDQsXHJcblx0ICAgICAgICAgICAgJyYnOiA1LFxyXG5cdCAgICAgICAgICAgICc9PSc6IDYsXHJcblx0ICAgICAgICAgICAgJyE9JzogNixcclxuXHQgICAgICAgICAgICAnPT09JzogNixcclxuXHQgICAgICAgICAgICAnIT09JzogNixcclxuXHQgICAgICAgICAgICAnPCc6IDcsXHJcblx0ICAgICAgICAgICAgJz4nOiA3LFxyXG5cdCAgICAgICAgICAgICc8PSc6IDcsXHJcblx0ICAgICAgICAgICAgJz49JzogNyxcclxuXHQgICAgICAgICAgICAnPDwnOiA4LFxyXG5cdCAgICAgICAgICAgICc+Pic6IDgsXHJcblx0ICAgICAgICAgICAgJz4+Pic6IDgsXHJcblx0ICAgICAgICAgICAgJysnOiA5LFxyXG5cdCAgICAgICAgICAgICctJzogOSxcclxuXHQgICAgICAgICAgICAnKic6IDExLFxyXG5cdCAgICAgICAgICAgICcvJzogMTEsXHJcblx0ICAgICAgICAgICAgJyUnOiAxMVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMubG9va2FoZWFkID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDIgLyogRU9GICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IDAsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IDAsXHJcblx0ICAgICAgICAgICAgZW5kOiAwXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5oYXNMaW5lVGVybWluYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0ID0ge1xyXG5cdCAgICAgICAgICAgIGlzTW9kdWxlOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBhd2FpdDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcclxuXHQgICAgICAgICAgICBhbGxvd1N0cmljdERpcmVjdGl2ZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICBhbGxvd1lpZWxkOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjogbnVsbCxcclxuXHQgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGxhYmVsU2V0OiB7fSxcclxuXHQgICAgICAgICAgICBzdHJpY3Q6IGZhbHNlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIgPSB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IDAsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiAwXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyID0ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiAwLFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogMFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIgPSB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH1cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50aHJvd0Vycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2VGb3JtYXQpIHtcclxuXHQgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuXHQgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcblx0ICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cdCAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XHJcblx0ICAgICAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGlkeCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGFzdE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgIHZhciBsaW5lID0gdGhpcy5sYXN0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbiArIDE7XHJcblx0ICAgICAgICB0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRvbGVyYXRlRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZUZvcm1hdCkge1xyXG5cdCAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuXHQgICAgICAgICAgICB2YWx1ZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0ICAgICAgICB2YXIgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZywgZnVuY3Rpb24gKHdob2xlLCBpZHgpIHtcclxuXHQgICAgICAgICAgICBhc3NlcnRfMS5hc3NlcnQoaWR4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaWR4XTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uICsgMTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugb2YgdGhlIHRva2VuLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnVuZXhwZWN0ZWRUb2tlbkVycm9yID0gZnVuY3Rpb24gKHRva2VuLCBtZXNzYWdlKSB7XHJcblx0ICAgICAgICB2YXIgbXNnID0gbWVzc2FnZSB8fCBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbjtcclxuXHQgICAgICAgIHZhciB2YWx1ZTtcclxuXHQgICAgICAgIGlmICh0b2tlbikge1xyXG5cdCAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xyXG5cdCAgICAgICAgICAgICAgICBtc2cgPSAodG9rZW4udHlwZSA9PT0gMiAvKiBFT0YgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkRU9TIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllciA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRTdHJpbmcgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDEwIC8qIFRlbXBsYXRlICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRlbXBsYXRlIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc0Z1dHVyZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRSZXNlcnZlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSAnSUxMRUdBTCc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgnJTAnLCB2YWx1ZSk7XHJcblx0ICAgICAgICBpZiAodG9rZW4gJiYgdHlwZW9mIHRva2VuLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdG9rZW4uc3RhcnQ7XHJcblx0ICAgICAgICAgICAgdmFyIGxpbmUgPSB0b2tlbi5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgIHZhciBsYXN0TWFya2VyTGluZVN0YXJ0ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4IC0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbjtcclxuXHQgICAgICAgICAgICB2YXIgY29sdW1uID0gdG9rZW4uc3RhcnQgLSBsYXN0TWFya2VyTGluZVN0YXJ0ICsgMTtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGFzdE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMubGFzdE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uICsgMTtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50aHJvd1VuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgbWVzc2FnZSkge1xyXG5cdCAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkVG9rZW5FcnJvcih0b2tlbiwgbWVzc2FnZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYXRlKHRoaXMudW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jb2xsZWN0Q29tbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmNvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgY29tbWVudHMgPSB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNvbW1lbnRzLmxlbmd0aCA+IDAgJiYgdGhpcy5kZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGNvbW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBub2RlID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGUubXVsdGlMaW5lID8gJ0Jsb2NrQ29tbWVudCcgOiAnTGluZUNvbW1lbnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKGUuc2xpY2VbMF0sIGUuc2xpY2VbMV0pXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yYW5nZSA9IGUucmFuZ2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sb2MgPSBlLmxvYztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBlLmxvYy5zdGFydC5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGUubG9jLnN0YXJ0LmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBlLnJhbmdlWzBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5sb2MuZW5kLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogZS5sb2MuZW5kLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBlLnJhbmdlWzFdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBGcm9tIGludGVybmFsIHJlcHJlc2VudGF0aW9uIHRvIGFuIGV4dGVybmFsIHN0cnVjdHVyZVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmdldFRva2VuUmF3ID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jb252ZXJ0VG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHZhciB0ID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IHRva2VuXzEuVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiB0aGlzLmdldFRva2VuUmF3KHRva2VuKVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgIHQucmFuZ2UgPSBbdG9rZW4uc3RhcnQsIHRva2VuLmVuZF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcubG9jKSB7XHJcblx0ICAgICAgICAgICAgdC5sb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnN0YXJ0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLykge1xyXG5cdCAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gdG9rZW4ucGF0dGVybjtcclxuXHQgICAgICAgICAgICB2YXIgZmxhZ3MgPSB0b2tlbi5mbGFncztcclxuXHQgICAgICAgICAgICB0LnJlZ2V4ID0geyBwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm5leHRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaW5kZXggIT09IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgdGhpcy5oYXNMaW5lVGVybWluYXRvciA9ICh0b2tlbi5saW5lTnVtYmVyICE9PSBuZXh0LmxpbmVOdW1iZXIpO1xyXG5cdCAgICAgICAgaWYgKG5leHQgJiYgdGhpcy5jb250ZXh0LnN0cmljdCAmJiBuZXh0LnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKG5leHQudmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG5leHQudHlwZSA9IDQgLyogS2V5d29yZCAqLztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmxvb2thaGVhZCA9IG5leHQ7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zICYmIG5leHQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKG5leHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5uZXh0UmVnZXhUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnNjYW5uZXIuc2NhblJlZ0V4cCgpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIC8vIFBvcCB0aGUgcHJldmlvdXMgdG9rZW4sICcvJyBvciAnLz0nXHJcblx0ICAgICAgICAgICAgLy8gVGhpcyBpcyBhZGRlZCBmcm9tIHRoZSBsb29rYWhlYWQgdG9rZW4uXHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbih0b2tlbikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUHJpbWUgdGhlIG5leHQgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgdGhpcy5sb29rYWhlYWQgPSB0b2tlbjtcclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zdGFydE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zdGFydE1hcmtlci5jb2x1bW5cclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuc3RhcnROb2RlID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0b2tlbi5zdGFydCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0b2tlbi5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdG9rZW4uc3RhcnQgLSB0b2tlbi5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAobWFya2VyLCBub2RlKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICBub2RlLnJhbmdlID0gW21hcmtlci5pbmRleCwgdGhpcy5sYXN0TWFya2VyLmluZGV4XTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MpIHtcclxuXHQgICAgICAgICAgICBub2RlLmxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IG1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBtYXJrZXIuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGFzdE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxhc3RNYXJrZXIuY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5zb3VyY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgbm9kZS5sb2Muc291cmNlID0gdGhpcy5jb25maWcuc291cmNlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogbWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1hcmtlci5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG1hcmtlci5pbmRleFxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGFzdE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxhc3RNYXJrZXIuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLmxhc3RNYXJrZXIuaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbm9kZTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZXhwZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDcgLyogUHVuY3R1YXRvciAqLyB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gUXVpZXRseSBleHBlY3QgYSBjb21tYSB3aGVuIGluIHRvbGVyYW50IG1vZGUsIG90aGVyd2lzZSBkZWxlZ2F0ZXMgdG8gZXhwZWN0KCkuXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZXhwZWN0Q29tbWFTZXBhcmF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnLCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnOycpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cclxuXHQgICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZXhwZWN0S2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDQgLyogS2V5d29yZCAqLyB8fCB0b2tlbi52YWx1ZSAhPT0ga2V5d29yZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXl3b3JkXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hLZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBjb250ZXh0dWFsIGtleXdvcmRcclxuXHQgICAgLy8gKHdoZXJlIGFuIGlkZW50aWZpZXIgaXMgc29tZXRpbWVzIGEga2V5d29yZCBkZXBlbmRpbmcgb24gdGhlIGNvbnRleHQpXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hDb250ZXh0dWFsS2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBpcyBhbiBhc3NpZ25tZW50IG9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hBc3NpZ24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gNyAvKiBQdW5jdHVhdG9yICovKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG9wID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICByZXR1cm4gb3AgPT09ICc9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnKj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcqKj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcvPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyU9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICctPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJzw8PScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJz4+Pj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcmPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnfD0nO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBDb3ZlciBncmFtbWFyIHN1cHBvcnQuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIFdoZW4gYW4gYXNzaWdubWVudCBleHByZXNzaW9uIHBvc2l0aW9uIHN0YXJ0cyB3aXRoIGFuIGxlZnQgcGFyZW50aGVzaXMsIHRoZSBkZXRlcm1pbmF0aW9uIG9mIHRoZSB0eXBlXHJcblx0ICAgIC8vIG9mIHRoZSBzeW50YXggaXMgdG8gYmUgZGVmZXJyZWQgYXJiaXRyYXJpbHkgbG9uZyB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJlbnRoZXNlcyBwYWlyIChwbHVzIGEgbG9va2FoZWFkKVxyXG5cdCAgICAvLyBvciB0aGUgZmlyc3QgY29tbWEuIFRoaXMgc2l0dWF0aW9uIGFsc28gZGVmZXJzIHRoZSBkZXRlcm1pbmF0aW9uIG9mIGFsbCB0aGUgZXhwcmVzc2lvbnMgbmVzdGVkIGluIHRoZSBwYWlyLlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBUaGVyZSBhcmUgdGhyZWUgcHJvZHVjdGlvbnMgdGhhdCBjYW4gYmUgcGFyc2VkIGluIGEgcGFyZW50aGVzZXMgcGFpciB0aGF0IG5lZWRzIHRvIGJlIGRldGVybWluZWRcclxuXHQgICAgLy8gYWZ0ZXIgdGhlIG91dGVybW9zdCBwYWlyIGlzIGNsb3NlZC4gVGhleSBhcmU6XHJcblx0ICAgIC8vXHJcblx0ICAgIC8vICAgMS4gQXNzaWdubWVudEV4cHJlc3Npb25cclxuXHQgICAgLy8gICAyLiBCaW5kaW5nRWxlbWVudHNcclxuXHQgICAgLy8gICAzLiBBc3NpZ25tZW50VGFyZ2V0c1xyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBJbiBvcmRlciB0byBhdm9pZCBleHBvbmVudGlhbCBiYWNrdHJhY2tpbmcsIHdlIHVzZSB0d28gZmxhZ3MgdG8gZGVub3RlIGlmIHRoZSBwcm9kdWN0aW9uIGNhbiBiZVxyXG5cdCAgICAvLyBiaW5kaW5nIGVsZW1lbnQgb3IgYXNzaWdubWVudCB0YXJnZXQuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIFRoZSB0aHJlZSBwcm9kdWN0aW9ucyBoYXZlIHRoZSByZWxhdGlvbnNoaXA6XHJcblx0ICAgIC8vXHJcblx0ICAgIC8vICAgQmluZGluZ0VsZW1lbnRzIOKKhiBBc3NpZ25tZW50VGFyZ2V0cyDiioYgQXNzaWdubWVudEV4cHJlc3Npb25cclxuXHQgICAgLy9cclxuXHQgICAgLy8gd2l0aCBhIHNpbmdsZSBleGNlcHRpb24gdGhhdCBDb3ZlckluaXRpYWxpemVkTmFtZSB3aGVuIHVzZWQgZGlyZWN0bHkgaW4gYW4gRXhwcmVzc2lvbiwgZ2VuZXJhdGVzXHJcblx0ICAgIC8vIGFuIGVhcmx5IGVycm9yLiBUaGVyZWZvcmUsIHdlIG5lZWQgdGhlIHRoaXJkIHN0YXRlLCBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IsIHRvIHRyYWNrIHRoZVxyXG5cdCAgICAvLyBmaXJzdCB1c2FnZSBvZiBDb3ZlckluaXRpYWxpemVkTmFtZSBhbmQgcmVwb3J0IGl0IHdoZW4gd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwYXJlbnRoZXNlcyBwYWlyLlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBpc29sYXRlQ292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlciBmdW5jdGlvbiB3aXRoIGEgbmV3IGNvdmVyIGdyYW1tYXIgY29udGV4dCwgYW5kIGl0IGRvZXMgbm90XHJcblx0ICAgIC8vIGVmZmVjdCB0aGUgY3VycmVudCBmbGFncy4gVGhpcyBtZWFucyB0aGUgcHJvZHVjdGlvbiB0aGUgcGFyc2VyIHBhcnNlcyBpcyBvbmx5IHVzZWQgYXMgYW4gZXhwcmVzc2lvbi4gVGhlcmVmb3JlXHJcblx0ICAgIC8vIHRoZSBDb3ZlckluaXRpYWxpemVkTmFtZSBjaGVjayBpcyBjb25kdWN0ZWQuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIGluaGVyaXRDb3ZlckdyYW1tYXIgZnVuY3Rpb24gcnVucyB0aGUgZ2l2ZW4gcGFyc2UgZnVuY3Rpb24gd2l0aCBhIG5ldyBjb3ZlciBncmFtbWFyIGNvbnRleHQsIGFuZCBpdCBwcm9wYWdhdGVzXHJcblx0ICAgIC8vIHRoZSBmbGFncyBvdXRzaWRlIG9mIHRoZSBwYXJzZXIuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgdXNlZCBhcyBhIHBhcnQgb2YgYSBwb3RlbnRpYWxcclxuXHQgICAgLy8gcGF0dGVybi4gVGhlIENvdmVySW5pdGlhbGl6ZWROYW1lIGNoZWNrIGlzIGRlZmVycmVkLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzb2xhdGVDb3ZlckdyYW1tYXIgPSBmdW5jdGlvbiAocGFyc2VGdW5jdGlvbikge1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudCA9IHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0ID0gdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRnVuY3Rpb24uY2FsbCh0aGlzKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pbmhlcml0Q292ZXJHcmFtbWFyID0gZnVuY3Rpb24gKHBhcnNlRnVuY3Rpb24pIHtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQgPSB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldCA9IHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZ1bmN0aW9uLmNhbGwodGhpcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ICYmIHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ICYmIHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yIHx8IHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNvbnN1bWVTZW1pY29sb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovICYmICF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnN0YXJ0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcmltYXJ5LWV4cHJlc3Npb25cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByaW1hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgdmFyIHRva2VuLCByYXc7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKCh0aGlzLmNvbnRleHQuaXNNb2R1bGUgfHwgdGhpcy5jb250ZXh0LmF3YWl0KSAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gJ2F3YWl0Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkgPyB0aGlzLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCkgOiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodGhpcy5uZXh0VG9rZW4oKS52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubG9va2FoZWFkLm9jdGFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUgPT09ICd0cnVlJywgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKG51bGwsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDEwIC8qIFRlbXBsYXRlICovOlxyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnKCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VHcm91cEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXJyYXlJbml0aWFsaXplcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VPYmplY3RJbml0aWFsaXplcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICcvJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJy89JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuaW5kZXggPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0UmVnZXhUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJlZ2V4TGl0ZXJhbCh0b2tlbi5yZWdleCwgcmF3LCB0b2tlbi5wYXR0ZXJuLCB0b2tlbi5mbGFncykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkICYmIHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2xldCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRoaXMubmV4dFRva2VuKCkudmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGhpc0V4cHJlc3Npb24oKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY2xhc3MnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQ2xhc3NFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS1pbml0aWFsaXplclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3ByZWFkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnLi4uJyk7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TcHJlYWRFbGVtZW50KGFyZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXJyYXlJbml0aWFsaXplciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlU3ByZWFkRWxlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5BcnJheUV4cHJlc3Npb24oZWxlbWVudHMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LWluaXRpYWxpemVyXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eU1ldGhvZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwYXJhbXMuc2ltcGxlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgcGFyYW1zLmZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4ocGFyYW1zLmZpcnN0UmVzdHJpY3RlZCwgcGFyYW1zLm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgcGFyYW1zLnN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihwYXJhbXMuc3RyaWN0ZWQsIHBhcmFtcy5tZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICByZXR1cm4gYm9keTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKHBhcmFtcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eU1ldGhvZEFzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0F3YWl0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1zLnBhcmFtcywgbWV0aG9kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RQcm9wZXJ0eUtleSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIGtleTtcclxuXHQgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnWycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGtleTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc1Byb3BlcnR5S2V5ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuXHQgICAgICAgIHJldHVybiAoa2V5LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIGtleS5uYW1lID09PSB2YWx1ZSkgfHxcclxuXHQgICAgICAgICAgICAoa2V5LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsICYmIGtleS52YWx1ZSA9PT0gdmFsdWUpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0UHJvcGVydHkgPSBmdW5jdGlvbiAoaGFzUHJvdG8pIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBraW5kO1xyXG5cdCAgICAgICAgdmFyIGtleSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc2hvcnRoYW5kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgaXNBc3luYyA9ICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmIChpZCA9PT0gJ2FzeW5jJykgJiZcclxuXHQgICAgICAgICAgICAgICAgIXRoaXMubWF0Y2goJzonKSAmJiAhdGhpcy5tYXRjaCgnKCcpICYmICF0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gaXNBc3luYyA/IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIDogdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKGlkKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbG9va2FoZWFkUHJvcGVydHlLZXkgPSB0aGlzLnF1YWxpZmllZFByb3BlcnR5TmFtZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICFpc0FzeW5jICYmIHRva2VuLnZhbHVlID09PSAnZ2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnZ2V0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICFpc0FzeW5jICYmIHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnc2V0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VTZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJyonICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZW5lcmF0b3JNZXRob2QoKTtcclxuXHQgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFrZXkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJzonKSAmJiAhaXNBc3luYykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWNvbXB1dGVkICYmIHRoaXMuaXNQcm9wZXJ0eUtleShrZXksICdfX3Byb3RvX18nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Byb3RvLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBoYXNQcm90by52YWx1ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gaXNBc3luYyA/IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEFzeW5jRnVuY3Rpb24oKSA6IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzc2lnbm1lbnRQYXR0ZXJuKGlkLCBpbml0KSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpZDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Qcm9wZXJ0eShraW5kLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdEluaXRpYWxpemVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGhhc1Byb3RvID0geyB2YWx1ZTogZmFsc2UgfTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eShoYXNQcm90bykpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRlbXBsYXRlLWxpdGVyYWxzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUhlYWQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQodGhpcy5sb29rYWhlYWQuaGVhZCwgJ1RlbXBsYXRlIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgdGVtcGxhdGUgaGVhZCcpO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB2YXIgY29va2VkID0gdG9rZW4uY29va2VkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGVtcGxhdGVFbGVtZW50KHsgcmF3OiByYXcsIGNvb2tlZDogY29va2VkIH0sIHRva2VuLnRhaWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAxMCAvKiBUZW1wbGF0ZSAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgdmFyIGNvb2tlZCA9IHRva2VuLmNvb2tlZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRlbXBsYXRlRWxlbWVudCh7IHJhdzogcmF3LCBjb29rZWQ6IGNvb2tlZCB9LCB0b2tlbi50YWlsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUxpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcblx0ICAgICAgICB2YXIgcXVhc2lzID0gW107XHJcblx0ICAgICAgICB2YXIgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVIZWFkKCk7XHJcblx0ICAgICAgICBxdWFzaXMucHVzaChxdWFzaSk7XHJcblx0ICAgICAgICB3aGlsZSAoIXF1YXNpLnRhaWwpIHtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xyXG5cdCAgICAgICAgICAgIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIHF1YXNpcy5wdXNoKHF1YXNpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRlbXBsYXRlTGl0ZXJhbChxdWFzaXMsIGV4cHJlc3Npb25zKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdyb3VwaW5nLW9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuID0gZnVuY3Rpb24gKGV4cHIpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50OlxyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5TcHJlYWRFbGVtZW50OlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuYXJndW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5BcnJheUV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIuZWxlbWVudHNbaV0gIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmVsZW1lbnRzW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5PYmplY3RFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIucHJvcGVydGllc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGV4cHIub3BlcmF0b3I7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIubGVmdCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIC8vIEFsbG93IG90aGVyIG5vZGUgdHlwZSBmb3IgdG9sZXJhbnQgcGFyc2luZy5cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VHcm91cEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtczogW10sXHJcblx0ICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VSZXN0RWxlbWVudChwYXJhbXMpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbZXhwcl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBhcnJvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByZXNzaW9uc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogZXhwcmVzc2lvbnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcmVzc2lvbnNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGV4cHJlc3Npb25zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKCFhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgZXhwci5uYW1lID09PSAneWllbGQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtleHByXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuZXhwcmVzc2lvbnNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguU2VxdWVuY2VFeHByZXNzaW9uID8gZXhwci5leHByZXNzaW9ucyA6IFtleHByXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbWV0ZXJzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1sZWZ0LWhhbmQtc2lkZS1leHByZXNzaW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBhcmdzID0gW107XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlU3ByZWFkRWxlbWVudCgpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgcmV0dXJuIGFyZ3M7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyB8fFxyXG5cdCAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyB8fFxyXG5cdCAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IDEgLyogQm9vbGVhbkxpdGVyYWwgKi8gfHxcclxuXHQgICAgICAgICAgICB0b2tlbi50eXBlID09PSA1IC8qIE51bGxMaXRlcmFsICovO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5pc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTmV3RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChpZC5uYW1lID09PSAnbmV3JywgJ05ldyBleHByZXNzaW9uIG11c3Qgc3RhcnQgd2l0aCBgbmV3YCcpO1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gJ3RhcmdldCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgTm9kZS5NZXRhUHJvcGVydHkoaWQsIHByb3BlcnR5KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBjYWxsZWUgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5tYXRjaCgnKCcpID8gdGhpcy5wYXJzZUFyZ3VtZW50cygpIDogW107XHJcblx0ICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlLk5ld0V4cHJlc3Npb24oY2FsbGVlLCBhcmdzKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIGV4cHIpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXN5bmNBcmd1bWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgcmV0dXJuIGFyZztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFzeW5jQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBhcmdzID0gW107XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlU3ByZWFkRWxlbWVudCgpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXN5bmNBcmd1bWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3MucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDb21tYVNlcGFyYXRvcigpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICByZXR1cm4gYXJncztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIG1heWJlQXN5bmMgPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnc3VwZXInKSAmJiB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShleHByLCBuZXcgTm9kZS5TdXBlcigpKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJygnKSAmJiAhdGhpcy5tYXRjaCgnLicpICYmICF0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLm1hdGNoS2V5d29yZCgnbmV3JykgPyB0aGlzLnBhcnNlTmV3RXhwcmVzc2lvbiA6IHRoaXMucGFyc2VQcmltYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcuJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuU3RhdGljTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGFzeW5jQXJyb3cgPSBtYXliZUFzeW5jICYmIChzdGFydFRva2VuLmxpbmVOdW1iZXIgPT09IHRoaXMubG9va2FoZWFkLmxpbmVOdW1iZXIpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXN5bmNBcnJvdyA/IHRoaXMucGFyc2VBc3luY0FyZ3VtZW50cygpIDogdGhpcy5wYXJzZUFyZ3VtZW50cygpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQ2FsbEV4cHJlc3Npb24oZXhwciwgYXJncykpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoYXN5bmNBcnJvdyAmJiB0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihhcmdzW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGFyZ3MsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDEwIC8qIFRlbXBsYXRlICovICYmIHRoaXMubG9va2FoZWFkLmhlYWQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGV4cHIsIHF1YXNpKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3VwZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdzdXBlcicpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCdbJykgJiYgIXRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3VwZXIoKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KHRoaXMuY29udGV4dC5hbGxvd0luLCAnY2FsbGVlIG9mIG5ldyBleHByZXNzaW9uIGFsd2F5cyBhbGxvdyBpbiBrZXl3b3JkLicpO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9ICh0aGlzLm1hdGNoS2V5d29yZCgnc3VwZXInKSAmJiB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpID8gdGhpcy5wYXJzZVN1cGVyKCkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLm1hdGNoS2V5d29yZCgnbmV3JykgPyB0aGlzLnBhcnNlTmV3RXhwcmVzc2lvbiA6IHRoaXMucGFyc2VQcmltYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcuJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TdGF0aWNNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDEwIC8qIFRlbXBsYXRlICovICYmIHRoaXMubG9va2FoZWFkLmhlYWQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZXhwciwgcXVhc2kpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy11cGRhdGUtZXhwcmVzc2lvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVwZGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKysnKSB8fCB0aGlzLm1hdGNoKCctLScpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKTtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiB0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdExIU1ByZWZpeCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIHByZWZpeCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVXBkYXRlRXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwciwgcHJlZml4KSk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcrKycpIHx8IHRoaXMubWF0Y2goJy0tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgdGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdExIU1Bvc3RmaXgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0VG9rZW4oKS52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5VcGRhdGVFeHByZXNzaW9uKG9wZXJhdG9yLCBleHByLCBwcmVmaXgpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy11bmFyeS1vcGVyYXRvcnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUF3YWl0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gdGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXdhaXRFeHByZXNzaW9uKGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VVbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcrJykgfHwgdGhpcy5tYXRjaCgnLScpIHx8IHRoaXMubWF0Y2goJ34nKSB8fCB0aGlzLm1hdGNoKCchJykgfHxcclxuXHQgICAgICAgICAgICB0aGlzLm1hdGNoS2V5d29yZCgnZGVsZXRlJykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ3ZvaWQnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKSk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci5vcGVyYXRvciA9PT0gJ2RlbGV0ZScgJiYgZXhwci5hcmd1bWVudC50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3REZWxldGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dC5hd2FpdCAmJiB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2F3YWl0JykpIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUF3YWl0RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VVcGRhdGVFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIGlmIChleHByLnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5VbmFyeUV4cHJlc3Npb24gJiYgdGhpcy5tYXRjaCgnKionKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdmFyIGxlZnQgPSBleHByO1xyXG5cdCAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbignKionLCBsZWZ0LCByaWdodCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWV4cC1vcGVyYXRvclxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tdWx0aXBsaWNhdGl2ZS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWRkaXRpdmUtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJpdHdpc2Utc2hpZnQtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlbGF0aW9uYWwtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVxdWFsaXR5LW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1iaW5hcnktYml0d2lzZS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYmluYXJ5LWxvZ2ljYWwtb3BlcmF0b3JzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuYmluYXJ5UHJlY2VkZW5jZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgdmFyIG9wID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB2YXIgcHJlY2VkZW5jZTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8pIHtcclxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gdGhpcy5vcGVyYXRvclByZWNlZGVuY2Vbb3BdIHx8IDA7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gKG9wID09PSAnaW5zdGFuY2VvZicgfHwgKHRoaXMuY29udGV4dC5hbGxvd0luICYmIG9wID09PSAnaW4nKSkgPyA3IDogMDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2UgPSAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHByZWNlZGVuY2U7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgcHJlYyA9IHRoaXMuYmluYXJ5UHJlY2VkZW5jZSh0b2tlbik7XHJcblx0ICAgICAgICBpZiAocHJlYyA+IDApIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHZhciBtYXJrZXJzID0gW3N0YXJ0VG9rZW4sIHRoaXMubG9va2FoZWFkXTtcclxuXHQgICAgICAgICAgICB2YXIgbGVmdCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFjayA9IFtsZWZ0LCB0b2tlbi52YWx1ZSwgcmlnaHRdO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmVjZWRlbmNlcyA9IFtwcmVjXTtcclxuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBwcmVjID0gdGhpcy5iaW5hcnlQcmVjZWRlbmNlKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHByZWMgPD0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxyXG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoKHN0YWNrLmxlbmd0aCA+IDIpICYmIChwcmVjIDw9IHByZWNlZGVuY2VzW3ByZWNlZGVuY2VzLmxlbmd0aCAtIDFdKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZXMucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIC8vIFNoaWZ0LlxyXG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMubmV4dFRva2VuKCkudmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICBwcmVjZWRlbmNlcy5wdXNoKHByZWMpO1xyXG5cdCAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2godGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXHJcblx0ICAgICAgICAgICAgdmFyIGkgPSBzdGFjay5sZW5ndGggLSAxO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSBzdGFja1tpXTtcclxuXHQgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xyXG5cdCAgICAgICAgICAgIHdoaWxlIChpID4gMSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKG1hcmtlcnMucG9wKCkpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBzdGFja1tpIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIHN0YWNrW2kgLSAyXSwgZXhwcikpO1xyXG5cdCAgICAgICAgICAgICAgICBpIC09IDI7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbmRpdGlvbmFsLW9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUJpbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz8nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB2YXIgY29uc2VxdWVudCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Db25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXNzaWdubWVudC1vcGVyYXRvcnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jaGVja1BhdHRlcm5QYXJhbSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJhbSkge1xyXG5cdCAgICAgICAgc3dpdGNoIChwYXJhbS50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtLCBwYXJhbS5uYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0uYXJndW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5sZWZ0KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0uZWxlbWVudHNbaV0gIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmVsZW1lbnRzW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ucHJvcGVydGllc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBvcHRpb25zLnNpbXBsZSA9IG9wdGlvbnMuc2ltcGxlICYmIChwYXJhbSBpbnN0YW5jZW9mIE5vZGUuSWRlbnRpZmllcik7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QgPSBmdW5jdGlvbiAoZXhwcikge1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtleHByXTtcclxuXHQgICAgICAgIHZhciBvcHRpb25zO1xyXG5cdCAgICAgICAgdmFyIGFzeW5jQXJyb3cgPSBmYWxzZTtcclxuXHQgICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyOlxyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXMgPSBleHByLnBhcmFtcztcclxuXHQgICAgICAgICAgICAgICAgYXN5bmNBcnJvdyA9IGV4cHIuYXN5bmM7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgb3B0aW9ucyA9IHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IHRydWUsXHJcblx0ICAgICAgICAgICAgcGFyYW1TZXQ6IHt9XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNbaV07XHJcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybikge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmlnaHQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LllpZWxkRXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJpZ2h0LmFyZ3VtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbS5yaWdodC50eXBlID0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbS5yaWdodC5uYW1lID0gJ3lpZWxkJztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbS5yaWdodC5hcmd1bWVudDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbS5yaWdodC5kZWxlZ2F0ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChhc3luY0Fycm93ICYmIHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIHBhcmFtLm5hbWUgPT09ICdhd2FpdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0pO1xyXG5cdCAgICAgICAgICAgIHBhcmFtc1tpXSA9IHBhcmFtO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgfHwgIXRoaXMuY29udGV4dC5hbGxvd1lpZWxkKSB7XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LllpZWxkRXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAob3B0aW9ucy5tZXNzYWdlID09PSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuY29udGV4dC5zdHJpY3QgPyBvcHRpb25zLnN0cmljdGVkIDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgb3B0aW9ucy5tZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiBvcHRpb25zLnNpbXBsZSxcclxuXHQgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuXHQgICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5hbGxvd1lpZWxkICYmIHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VZaWVsZEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gc3RhcnRUb2tlbjtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgKHRva2VuLmxpbmVOdW1iZXIgPT09IHRoaXMubG9va2FoZWFkLmxpbmVOdW1iZXIpICYmIHRva2VuLnZhbHVlID09PSAnYXN5bmMnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gfHwgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGFyZyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbYXJnXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyIHx8IHRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyb3ctZnVuY3Rpb24tZGVmaW5pdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgaXNBc3luYyA9IGV4cHIuYXN5bmM7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5yZWludGVycHJldEFzQ292ZXJGb3JtYWxzTGlzdChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGxpc3QpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IGxpc3Quc2ltcGxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBpc0FzeW5jO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gYm9keS50eXBlICE9PSBzeW50YXhfMS5TeW50YXguQmxvY2tTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBsaXN0LmZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obGlzdC5maXJzdFJlc3RyaWN0ZWQsIGxpc3QubWVzc2FnZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBsaXN0LnN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsaXN0LnN0cmljdGVkLCBsaXN0Lm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IGlzQXN5bmMgPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obGlzdC5wYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihsaXN0LnBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBd2FpdDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hBc3NpZ24oKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gZXhwcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNBc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQXNzaWdubWVudEV4cHJlc3Npb24ob3BlcmF0b3IsIGV4cHIsIHJpZ2h0KSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb21tYS1vcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJsb2NrXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2V4cG9ydCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc01vZHVsZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc01vZHVsZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VJbXBvcnREZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oeyBpbkZvcjogZmFsc2UgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2xldCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLmlzTGV4aWNhbERlY2xhcmF0aW9uKCkgPyB0aGlzLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHsgaW5Gb3I6IGZhbHNlIH0pIDogdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gc3RhdGVtZW50O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBibG9jayA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBibG9jay5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CbG9ja1N0YXRlbWVudChibG9jaykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1sZXQtYW5kLWNvbnN0LWRlY2xhcmF0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGV4aWNhbEJpbmRpbmcgPSBmdW5jdGlvbiAoa2luZCwgb3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBpZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAoa2luZCA9PT0gJ2NvbnN0Jykge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaEtleXdvcmQoJ2luJykgJiYgIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXIsICdjb25zdCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoKCFvcHRpb25zLmluRm9yICYmIGlkLnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB8fCB0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPScpO1xyXG5cdCAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbiAoa2luZCwgb3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIGxpc3QgPSBbdGhpcy5wYXJzZUxleGljYWxCaW5kaW5nKGtpbmQsIG9wdGlvbnMpXTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGxpc3QucHVzaCh0aGlzLnBhcnNlTGV4aWNhbEJpbmRpbmcoa2luZCwgb3B0aW9ucykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGxpc3Q7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNMZXhpY2FsRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNjYW5uZXIuc2F2ZVN0YXRlKCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5yZXN0b3JlU3RhdGUoc3RhdGUpO1xyXG5cdCAgICAgICAgcmV0dXJuIChuZXh0LnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ1snKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiBuZXh0LnZhbHVlID09PSAneycpIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIG5leHQudmFsdWUgPT09ICdsZXQnKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiBuZXh0LnZhbHVlID09PSAneWllbGQnKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxleGljYWxEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGtpbmQgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGtpbmQgPT09ICdsZXQnIHx8IGtpbmQgPT09ICdjb25zdCcsICdMZXhpY2FsIGRlY2xhcmF0aW9uIG11c3QgYmUgZWl0aGVyIGxldCBvciBjb25zdCcpO1xyXG5cdCAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdChraW5kLCBvcHRpb25zKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGVzdHJ1Y3R1cmluZy1iaW5kaW5nLXBhdHRlcm5zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5kaW5nUmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJy4uLicpO1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZXN0RWxlbWVudChhcmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFycmF5UGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLnBhcnNlQmluZGluZ1Jlc3RFbGVtZW50KHBhcmFtcywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXJyYXlQYXR0ZXJuKGVsZW1lbnRzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eVBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc2hvcnRoYW5kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdCAgICAgICAgdmFyIHZhbHVlO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIHZhciBrZXlUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB2YXIgaW5pdCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcihrZXlUb2tlbi52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goa2V5VG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoa2V5VG9rZW4pLCBuZXcgTm9kZS5Bc3NpZ25tZW50UGF0dGVybihpbml0LCBleHByKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLm1hdGNoKCc6JykpIHtcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goa2V5VG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdFBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh0aGlzLnBhcnNlUHJvcGVydHlQYXR0ZXJuKHBhcmFtcywga2luZCkpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk9iamVjdFBhdHRlcm4ocHJvcGVydGllcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBwYXR0ZXJuO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlQXJyYXlQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXJzZU9iamVjdFBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnbGV0JykgJiYgKGtpbmQgPT09ICdjb25zdCcgfHwga2luZCA9PT0gJ2xldCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuTGV0SW5MZXhpY2FsQmluZGluZyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcihraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBwYXR0ZXJuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0ID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkFzc2lnbm1lbnRQYXR0ZXJuKHBhdHRlcm4sIHJpZ2h0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdmFyaWFibGUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoa2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIHRva2VuLnZhbHVlID09PSAneWllbGQnKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZXh0LmFsbG93WWllbGQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0IHx8IHRva2VuLnZhbHVlICE9PSAnbGV0JyB8fCBraW5kICE9PSAndmFyJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICgodGhpcy5jb250ZXh0LmlzTW9kdWxlIHx8IHRoaXMuY29udGV4dC5hd2FpdCkgJiYgdG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmIHRva2VuLnZhbHVlID09PSAnYXdhaXQnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsICd2YXInKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFZhck5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGlkLnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmICFvcHRpb25zLmluRm9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG9wdCA9IHsgaW5Gb3I6IG9wdGlvbnMuaW5Gb3IgfTtcclxuXHQgICAgICAgIHZhciBsaXN0ID0gW107XHJcblx0ICAgICAgICBsaXN0LnB1c2godGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24ob3B0KSk7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBsaXN0LnB1c2godGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24ob3B0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbGlzdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndmFyJyk7XHJcblx0ICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHsgaW5Gb3I6IGZhbHNlIH0pO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZW1wdHktc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWV4cHJlc3Npb24tc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwcmVzc2lvblN0YXRlbWVudChleHByKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlmLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSWZDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgY29uc2VxdWVudDtcclxuXHQgICAgICAgIHZhciBhbHRlcm5hdGUgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpZicpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBjb25zZXF1ZW50ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIGNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlSWZDbGF1c2UoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Vsc2UnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBhbHRlcm5hdGUgPSB0aGlzLnBhcnNlSWZDbGF1c2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZG8td2hpbGUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEb1doaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZG8nKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Eb1doaWxlU3RhdGVtZW50KGJvZHksIHRlc3QpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtd2hpbGUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VXaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLldoaWxlU3RhdGVtZW50KHRlc3QsIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZm9yLXN0YXRlbWVudFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mb3ItaW4tYW5kLWZvci1vZi1zdGF0ZW1lbnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdXBkYXRlID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBmb3JJbiA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgbGVmdCwgcmlnaHQ7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmb3InKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgndmFyJykpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoeyBpbkZvcjogdHJ1ZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdpbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVjbCA9IGRlY2xhcmF0aW9uc1swXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsLmluaXQgJiYgKGRlY2wuaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybiB8fCBkZWNsLmlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuIHx8IHRoaXMuY29udGV4dC5zdHJpY3QpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRm9ySW5PZkxvb3BJbml0aWFsaXplciwgJ2Zvci1pbicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjb25zdCcpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdsZXQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBraW5kID0gdGhpcy5uZXh0VG9rZW4oKS52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSAnaW4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5JZGVudGlmaWVyKGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3Qoa2luZCwgeyBpbkZvcjogdHJ1ZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2luJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGluaXRTdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdpbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgfHwgaW5pdC50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JJbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oaW5pdCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0IHx8IGluaXQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luRm9yTG9vcCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oaW5pdCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRTZXEgPSBbaW5pdF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0U2VxLnB1c2godGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShpbml0U3RhcnRUb2tlbiksIG5ldyBOb2RlLlNlcXVlbmNlRXhwcmVzc2lvbihpbml0U2VxKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGJvZHk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVN0YXRlbWVudCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSA/XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Gb3JTdGF0ZW1lbnQoaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgIGZvckluID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Gb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkpIDpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Gb3JPZlN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb250aW51ZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY29udGludWUnKTtcclxuXHQgICAgICAgIHZhciBsYWJlbCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGxhYmVsID0gaWQ7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZXh0LmxhYmVsU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlVua25vd25MYWJlbCwgaWQubmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIXRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxDb250aW51ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Db250aW51ZVN0YXRlbWVudChsYWJlbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1icmVhay1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJyZWFrU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnYnJlYWsnKTtcclxuXHQgICAgICAgIHZhciBsYWJlbCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29udGV4dC5sYWJlbFNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Vbmtub3duTGFiZWwsIGlkLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBsYWJlbCA9IGlkO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIXRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiAmJiAhdGhpcy5jb250ZXh0LmluU3dpdGNoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJyZWFrU3RhdGVtZW50KGxhYmVsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJldHVybi1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdyZXR1cm4nKTtcclxuXHQgICAgICAgIHZhciBoYXNBcmd1bWVudCA9ICF0aGlzLm1hdGNoKCc7JykgJiYgIXRoaXMubWF0Y2goJ30nKSAmJlxyXG5cdCAgICAgICAgICAgICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmIHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gaGFzQXJndW1lbnQgPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogbnVsbDtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmV0dXJuU3RhdGVtZW50KGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdpdGgtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RNb2RlV2l0aCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3dpdGgnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5XaXRoU3RhdGVtZW50KG9iamVjdCwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zd2l0Y2gtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTd2l0Y2hDYXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0ZXN0O1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHRlc3QgPSBudWxsO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjYXNlJyk7XHJcblx0ICAgICAgICAgICAgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgdmFyIGNvbnNlcXVlbnQgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdjYXNlJykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Td2l0Y2hDYXNlKHRlc3QsIGNvbnNlcXVlbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3N3aXRjaCcpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBkaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luU3dpdGNoID0gdGhpcy5jb250ZXh0LmluU3dpdGNoO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBjYXNlcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIGNsYXVzZSA9IHRoaXMucGFyc2VTd2l0Y2hDYXNlKCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNsYXVzZS50ZXN0ID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Rm91bmQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk11bHRpcGxlRGVmYXVsdHNJblN3aXRjaCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2FzZXMucHVzaChjbGF1c2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IHByZXZpb3VzSW5Td2l0Y2g7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Td2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1sYWJlbGxlZC1zdGF0ZW1lbnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMYWJlbGxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB2YXIgc3RhdGVtZW50O1xyXG5cdCAgICAgICAgaWYgKChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSAmJiB0aGlzLm1hdGNoKCc6JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnRleHQubGFiZWxTZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuUmVkZWNsYXJhdGlvbiwgJ0xhYmVsJywgaWQubmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbFNldFtrZXldID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB2YXIgYm9keSA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb24pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9uLmdlbmVyYXRvcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5HZW5lcmF0b3JJbkxlZ2FjeUNvbnRleHQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkgPSBkZWNsYXJhdGlvbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRleHQubGFiZWxTZXRba2V5XTtcclxuXHQgICAgICAgICAgICBzdGF0ZW1lbnQgPSBuZXcgTm9kZS5MYWJlbGVkU3RhdGVtZW50KGlkLCBib2R5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIHN0YXRlbWVudCA9IG5ldyBOb2RlLkV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBzdGF0ZW1lbnQpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10aHJvdy1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRocm93U3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndGhyb3cnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTmV3bGluZUFmdGVyVGhyb3cpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHJ5LXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2F0Y2hDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjYXRjaCcpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBwYXJhbSA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcyk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1NYXAgPSB7fTtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIHBhcmFtc1tpXS52YWx1ZTtcclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtTWFwLCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkR1cGxpY2F0ZUJpbmRpbmcsIHBhcmFtc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHBhcmFtTWFwW2tleV0gPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgcGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQocGFyYW0ubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0Q2F0Y2hWYXJpYWJsZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DYXRjaENsYXVzZShwYXJhbSwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRmluYWxseUNsYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZmluYWxseScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndHJ5Jyk7XHJcblx0ICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5tYXRjaEtleXdvcmQoJ2NhdGNoJykgPyB0aGlzLnBhcnNlQ2F0Y2hDbGF1c2UoKSA6IG51bGw7XHJcblx0ICAgICAgICB2YXIgZmluYWxpemVyID0gdGhpcy5tYXRjaEtleXdvcmQoJ2ZpbmFsbHknKSA/IHRoaXMucGFyc2VGaW5hbGx5Q2xhdXNlKCkgOiBudWxsO1xyXG5cdCAgICAgICAgaWYgKCFoYW5kbGVyICYmICFmaW5hbGl6ZXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Ob0NhdGNoT3JGaW5hbGx5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRyeVN0YXRlbWVudChibG9jaywgaGFuZGxlciwgZmluYWxpemVyKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRlYnVnZ2VyLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdkZWJ1Z2dlcicpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5EZWJ1Z2dlclN0YXRlbWVudCgpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS1zdGF0ZW1lbnRzLWFuZC1kZWNsYXJhdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZW1lbnQ7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDEwIC8qIFRlbXBsYXRlICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICcoJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gJzsnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkgPyB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpIDogdGhpcy5wYXJzZUxhYmVsbGVkU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdicmVhayc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUJyZWFrU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdjb250aW51ZSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUNvbnRpbnVlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWJ1Z2dlcic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdkbyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZURvV2hpbGVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Zvcic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUZvclN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdpZic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUlmU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXR1cm4nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N3aXRjaCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAndGhyb3cnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJ5JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd2YXInOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VWYXJpYWJsZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2hpbGUnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2l0aCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBzdGF0ZW1lbnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0xhYmVsU2V0ID0gdGhpcy5jb250ZXh0LmxhYmVsU2V0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJblN3aXRjaCA9IHRoaXMuY29udGV4dC5pblN3aXRjaDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luRnVuY3Rpb25Cb2R5ID0gdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmxhYmVsU2V0ID0ge307XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5ID0gdHJ1ZTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmxhYmVsU2V0ID0gcHJldmlvdXNMYWJlbFNldDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSBwcmV2aW91c0luU3dpdGNoO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5ID0gcHJldmlvdXNJbkZ1bmN0aW9uQm9keTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJsb2NrU3RhdGVtZW50KGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS52YWxpZGF0ZVBhcmFtID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmFtLCBuYW1lKSB7XHJcblx0ICAgICAgICB2YXIga2V5ID0gJyQnICsgbmFtZTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKG5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChuYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChuYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMucGFyYW1TZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucy5wYXJhbVNldCwga2V5LCB7IHZhbHVlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgb3B0aW9ucy5wYXJhbVNldFtrZXldID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcuLi4nKTtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkRlZmF1bHRSZXN0UGFyYW1ldGVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuUGFyYW1ldGVyQWZ0ZXJSZXN0UGFyYW1ldGVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJlc3RFbGVtZW50KGFyZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9ybWFsUGFyYW1ldGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBwYXJhbSA9IHRoaXMubWF0Y2goJy4uLicpID8gdGhpcy5wYXJzZVJlc3RFbGVtZW50KHBhcmFtcykgOiB0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcyk7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbXNbaV0sIHBhcmFtc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBvcHRpb25zLnNpbXBsZSA9IG9wdGlvbnMuc2ltcGxlICYmIChwYXJhbSBpbnN0YW5jZW9mIE5vZGUuSWRlbnRpZmllcik7XHJcblx0ICAgICAgICBvcHRpb25zLnBhcmFtcy5wdXNoKHBhcmFtKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZvcm1hbFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICB2YXIgb3B0aW9ucztcclxuXHQgICAgICAgIG9wdGlvbnMgPSB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtczogW10sXHJcblx0ICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBmaXJzdFJlc3RyaWN0ZWRcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICBvcHRpb25zLnBhcmFtU2V0ID0ge307XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXIob3B0aW9ucyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiBvcHRpb25zLnNpbXBsZSxcclxuXHQgICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLFxyXG5cdCAgICAgICAgICAgIHN0cmljdGVkOiBvcHRpb25zLnN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBtYXRjaCA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIGlmIChtYXRjaCkge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Nhbm5lci5zYXZlU3RhdGUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLnJlc3RvcmVTdGF0ZShzdGF0ZSk7XHJcblx0ICAgICAgICAgICAgbWF0Y2ggPSAoc3RhdGUubGluZU51bWJlciA9PT0gbmV4dC5saW5lTnVtYmVyKSAmJiAobmV4dC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pICYmIChuZXh0LnZhbHVlID09PSAnZnVuY3Rpb24nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBtYXRjaDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoaWRlbnRpZmllcklzT3B0aW9uYWwpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIGlmIChpc0FzeW5jKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGlzQXN5bmMgPyBmYWxzZSA6IHRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgIGlmIChpc0dlbmVyYXRvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWVzc2FnZTtcclxuXHQgICAgICAgIHZhciBpZCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZmlyc3RSZXN0cmljdGVkID0gbnVsbDtcclxuXHQgICAgICAgIGlmICghaWRlbnRpZmllcklzT3B0aW9uYWwgfHwgIXRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IGlzQXN5bmM7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9ICFpc0dlbmVyYXRvcjtcclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoZmlyc3RSZXN0cmljdGVkKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcztcclxuXHQgICAgICAgIHZhciBzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLmZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2UpIHtcclxuXHQgICAgICAgICAgICBtZXNzYWdlID0gZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gZm9ybWFsUGFyYW1ldGVycy5zaW1wbGU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQWxsb3dBd2FpdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIGlzQXN5bmMgPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5LCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgaWYgKGlzQXN5bmMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gaXNBc3luYyA/IGZhbHNlIDogdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgaWYgKGlzR2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXNzYWdlO1xyXG5cdCAgICAgICAgdmFyIGlkID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBmaXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gaXNBc3luYztcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gIWlzR2VuZXJhdG9yO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZCA9ICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpID8gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCkgOiB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKGZpcnN0UmVzdHJpY3RlZCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gZm9ybWFsUGFyYW1ldGVycy5wYXJhbXM7XHJcblx0ICAgICAgICB2YXIgc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLnN0cmljdGVkO1xyXG5cdCAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5maXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlKSB7XHJcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IGZvcm1hbFBhcmFtZXRlcnMuc2ltcGxlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0FsbG93QXdhaXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiBpc0FzeW5jID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHksIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRpcmVjdGl2ZS1wcm9sb2d1ZXMtYW5kLXRoZS11c2Utc3RyaWN0LWRpcmVjdGl2ZVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRGlyZWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsKSA/IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pLnNsaWNlKDEsIC0xKSA6IG51bGw7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIGRpcmVjdGl2ZSA/IG5ldyBOb2RlLkRpcmVjdGl2ZShleHByLCBkaXJlY3RpdmUpIDogbmV3IE5vZGUuRXhwcmVzc2lvblN0YXRlbWVudChleHByKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZmlyc3RSZXN0cmljdGVkID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBib2R5ID0gW107XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRGlyZWN0aXZlKCk7XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHN0YXRlbWVudCk7XHJcblx0ICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IHN0YXRlbWVudC5kaXJlY3RpdmU7XHJcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXJlY3RpdmUgIT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBib2R5O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tZXRob2QtZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLnZhbHVlID09PSAnWyc7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VHZXR0ZXJNZXRob2QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRHZXR0ZXJBcml0eSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKGZvcm1hbFBhcmFtZXRlcnMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNldHRlck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMubGVuZ3RoICE9PSAxKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuQmFkU2V0dGVyQXJpdHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoZm9ybWFsUGFyYW1ldGVycy5wYXJhbXNbMF0gaW5zdGFuY2VvZiBOb2RlLlJlc3RFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuQmFkU2V0dGVyUmVzdFBhcmFtZXRlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKGZvcm1hbFBhcmFtZXRlcnMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUdlbmVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1zLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZW5lcmF0b3ItZnVuY3Rpb24tZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc1N0YXJ0T2ZFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHZhbHVlID09PSAnWycpIHx8ICh2YWx1ZSA9PT0gJygnKSB8fCAodmFsdWUgPT09ICd7JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJysnKSB8fCAodmFsdWUgPT09ICctJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJyEnKSB8fCAodmFsdWUgPT09ICd+JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJysrJykgfHwgKHZhbHVlID09PSAnLS0nKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnLycpIHx8ICh2YWx1ZSA9PT0gJy89Jyk7IC8vIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsXHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGFydCA9ICh2YWx1ZSA9PT0gJ2NsYXNzJykgfHwgKHZhbHVlID09PSAnZGVsZXRlJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgfHwgKHZhbHVlID09PSAnbGV0JykgfHwgKHZhbHVlID09PSAnbmV3JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ3N1cGVyJykgfHwgKHZhbHVlID09PSAndGhpcycpIHx8ICh2YWx1ZSA9PT0gJ3R5cGVvZicpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICd2b2lkJykgfHwgKHZhbHVlID09PSAneWllbGQnKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gc3RhcnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VZaWVsZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd5aWVsZCcpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBkZWxlZ2F0ZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgZGVsZWdhdGUgPSB0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdGFydE9mRXhwcmVzc2lvbigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuWWllbGRFeHByZXNzaW9uKGFyZ3VtZW50LCBkZWxlZ2F0ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jbGFzcy1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24gKGhhc0NvbnN0cnVjdG9yKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIga2luZCA9ICcnO1xyXG5cdCAgICAgICAgdmFyIGtleSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaXNTdGF0aWMgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IGtleTtcclxuXHQgICAgICAgICAgICBpZiAoaWQubmFtZSA9PT0gJ3N0YXRpYycgJiYgKHRoaXMucXVhbGlmaWVkUHJvcGVydHlOYW1lKHRoaXMubG9va2FoZWFkKSB8fCB0aGlzLm1hdGNoKCcqJykpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgJiYgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgKHRva2VuLnZhbHVlID09PSAnYXN5bmMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHVuY3R1YXRvciA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocHVuY3R1YXRvciAhPT0gJzonICYmIHB1bmN0dWF0b3IgIT09ICcoJyAmJiBwdW5jdHVhdG9yICE9PSAnKicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlzQXN5bmMgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2dldCcgfHwgdG9rZW4udmFsdWUgPT09ICdzZXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2NvbnN0cnVjdG9yJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkNvbnN0cnVjdG9ySXNBc3luYyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGxvb2thaGVhZFByb3BlcnR5S2V5ID0gdGhpcy5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2dldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICAgICAga2luZCA9ICdnZXQnO1xyXG5cdCAgICAgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ3NldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICAgICAga2luZCA9ICdzZXQnO1xyXG5cdCAgICAgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVNldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJyonICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZW5lcmF0b3JNZXRob2QoKTtcclxuXHQgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFraW5kICYmIGtleSAmJiB0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gaXNBc3luYyA/IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEFzeW5jRnVuY3Rpb24oKSA6IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKCk7XHJcblx0ICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICgha2luZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGtpbmQgPT09ICdpbml0Jykge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnbWV0aG9kJztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghY29tcHV0ZWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoaXNTdGF0aWMgJiYgdGhpcy5pc1Byb3BlcnR5S2V5KGtleSwgJ3Byb3RvdHlwZScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RhdGljUHJvdG90eXBlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCFpc1N0YXRpYyAmJiB0aGlzLmlzUHJvcGVydHlLZXkoa2V5LCAnY29uc3RydWN0b3InKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ21ldGhvZCcgfHwgIW1ldGhvZCB8fCAodmFsdWUgJiYgdmFsdWUuZ2VuZXJhdG9yKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5Db25zdHJ1Y3RvclNwZWNpYWxNZXRob2QpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChoYXNDb25zdHJ1Y3Rvci52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVDb25zdHJ1Y3Rvcik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBoYXNDb25zdHJ1Y3Rvci52YWx1ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAga2luZCA9ICdjb25zdHJ1Y3Rvcic7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTWV0aG9kRGVmaW5pdGlvbihrZXksIGNvbXB1dGVkLCB2YWx1ZSwga2luZCwgaXNTdGF0aWMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRWxlbWVudExpc3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGhhc0NvbnN0cnVjdG9yID0geyB2YWx1ZTogZmFsc2UgfTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlQ2xhc3NFbGVtZW50KGhhc0NvbnN0cnVjdG9yKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiBib2R5O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NCb2R5ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50TGlzdCA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnRMaXN0KCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DbGFzc0JvZHkoZWxlbWVudExpc3QpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoaWRlbnRpZmllcklzT3B0aW9uYWwpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NsYXNzJyk7XHJcblx0ICAgICAgICB2YXIgaWQgPSAoaWRlbnRpZmllcklzT3B0aW9uYWwgJiYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDMgLyogSWRlbnRpZmllciAqLykpID8gbnVsbCA6IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIHZhciBzdXBlckNsYXNzID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZXh0ZW5kcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBzdXBlckNsYXNzID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBjbGFzc0JvZHkgPSB0aGlzLnBhcnNlQ2xhc3NCb2R5KCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DbGFzc0RlY2xhcmF0aW9uKGlkLCBzdXBlckNsYXNzLCBjbGFzc0JvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NsYXNzJyk7XHJcblx0ICAgICAgICB2YXIgaWQgPSAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSA/IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKSA6IG51bGw7XHJcblx0ICAgICAgICB2YXIgc3VwZXJDbGFzcyA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgc3VwZXJDbGFzcyA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5wYXJzZUNsYXNzQm9keSgpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2xhc3NFeHByZXNzaW9uKGlkLCBzdXBlckNsYXNzLCBjbGFzc0JvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2NyaXB0c1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tb2R1bGVzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc01vZHVsZSA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKCk7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTW9kdWxlKGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMoKTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TY3JpcHQoYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pbXBvcnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VNb2R1bGVTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRNb2R1bGVTcGVjaWZpZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBpbXBvcnQgezxmb28gYXMgYmFyPn0gLi4uO1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpbXBvcnRlZDtcclxuXHQgICAgICAgIHZhciBsb2NhbDtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpbXBvcnRlZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBsb2NhbCA9IGltcG9ydGVkO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaW1wb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICBsb2NhbCA9IGltcG9ydGVkO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydFNwZWNpZmllcihsb2NhbCwgaW1wb3J0ZWQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8ge2ZvbywgYmFyIGFzIGJhc31cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU5hbWVkSW1wb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gc3BlY2lmaWVycztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaW1wb3J0IDxmb28+IC4uLjtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGltcG9ydCA8KiBhcyBmb28+IC4uLjtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKicpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Ob0FzQWZ0ZXJJbXBvcnROYW1lc3BhY2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciBsb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGxvY2FsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnaW1wb3J0Jyk7XHJcblx0ICAgICAgICB2YXIgc3JjO1xyXG5cdCAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICAvLyBpbXBvcnQgJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgc3JjID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBpbXBvcnQge2Jhcn1cclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHRoaXMucGFyc2VOYW1lZEltcG9ydHMoKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBpbXBvcnQgKiBhcyBmb29cclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNJZGVudGlmaWVyTmFtZSh0aGlzLmxvb2thaGVhZCkgJiYgIXRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvb1xyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywgKiBhcyBmb29cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb28sIHtiYXJ9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHRoaXMucGFyc2VOYW1lZEltcG9ydHMoKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBtZXNzYWdlc18xLk1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHNyYyA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0RGVjbGFyYXRpb24oc3BlY2lmaWVycywgc3JjKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWV4cG9ydHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIHZhciBleHBvcnRlZCA9IGxvY2FsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydFNwZWNpZmllcihsb2NhbCwgZXhwb3J0ZWQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHBvcnQnKTtcclxuXHQgICAgICAgIHZhciBleHBvcnREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XHJcblx0ICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9vICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKHRydWUpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGNsYXNzIGZvbyB7fVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbih0cnVlKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZiAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBhc3luYyB4ID0+IHhcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSA/IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKHRydWUpIDogdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQge307XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCAoMSArIDIpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLm1hdGNoKCd7JykgPyB0aGlzLnBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKCdbJykgPyB0aGlzLnBhcnNlQXJyYXlJbml0aWFsaXplcigpIDogdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgLy8gZXhwb3J0ICogZnJvbSAnZm9vJztcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmxvb2thaGVhZC52YWx1ZSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogbWVzc2FnZXNfMS5NZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgc3JjID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnRBbGxEZWNsYXJhdGlvbihzcmMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIC8vIGV4cG9ydCB2YXIgZiA9IDE7XHJcblx0ICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnbGV0JzpcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHsgaW5Gb3I6IGZhbHNlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ3Zhcic6XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBbXSwgbnVsbCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIFtdLCBudWxsKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xyXG5cdCAgICAgICAgICAgIHZhciBzb3VyY2UgPSBudWxsO1xyXG5cdCAgICAgICAgICAgIHZhciBpc0V4cG9ydEZyb21JZGVudGlmaWVyID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpc0V4cG9ydEZyb21JZGVudGlmaWVyID0gaXNFeHBvcnRGcm9tSWRlbnRpZmllciB8fCB0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpO1xyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fSBmcm9tICdmb28nO1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2Zvb30gZnJvbSAnZm9vJztcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgc291cmNlID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoaXNFeHBvcnRGcm9tSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2RlZmF1bHR9OyAvLyBtaXNzaW5nIGZyb21DbGF1c2VcclxuXHQgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmxvb2thaGVhZC52YWx1ZSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogbWVzc2FnZXNfMS5NZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7Zm9vfTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnROYW1lZERlY2xhcmF0aW9uKG51bGwsIHNwZWNpZmllcnMsIHNvdXJjZSkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cG9ydERlY2xhcmF0aW9uO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gUGFyc2VyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XHJcblxuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0Ly8gRW5zdXJlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxyXG5cdC8vIFRoaXMgaXMgb25seSB0byBoYXZlIGEgYmV0dGVyIGNvbnRyYWN0IHNlbWFudGljLCBpLmUuIGFub3RoZXIgc2FmZXR5IG5ldFxyXG5cdC8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxyXG5cdC8vIERvIE5PVCB1c2UgdGhpcyB0byBlbmZvcmNlIGEgY2VydGFpbiBjb25kaXRpb24gb24gYW55IHVzZXIgaW5wdXQuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcclxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcblx0ICAgIGlmICghY29uZGl0aW9uKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FTU0VSVDogJyArIG1lc3NhZ2UpO1xyXG5cdCAgICB9XHJcblx0fVxyXG5cdGV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xyXG5cblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgRXJyb3JIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXJyb3JIYW5kbGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMudG9sZXJhbnQgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnJlY29yZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS50b2xlcmF0ZSA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdCAgICAgICAgaWYgKHRoaXMudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnJlY29yZEVycm9yKGVycm9yKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdEVycm9yID0gZnVuY3Rpb24gKG1zZywgY29sdW1uKSB7XHJcblx0ICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobXNnKTtcclxuXHQgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBjYXRjaCAoYmFzZSkge1xyXG5cdCAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5jcmVhdGUgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XHJcblx0ICAgICAgICAgICAgICAgIGVycm9yID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcclxuXHQgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yLCAnY29sdW1uJywgeyB2YWx1ZTogY29sdW1uIH0pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICByZXR1cm4gZXJyb3I7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcclxuXHQgICAgICAgIHZhciBtc2cgPSAnTGluZSAnICsgbGluZSArICc6ICcgKyBkZXNjcmlwdGlvbjtcclxuXHQgICAgICAgIHZhciBlcnJvciA9IHRoaXMuY29uc3RydWN0RXJyb3IobXNnLCBjb2wpO1xyXG5cdCAgICAgICAgZXJyb3IuaW5kZXggPSBpbmRleDtcclxuXHQgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lO1xyXG5cdCAgICAgICAgZXJyb3IuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcclxuXHQgICAgICAgIHJldHVybiBlcnJvcjtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS50aHJvd0Vycm9yID0gZnVuY3Rpb24gKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKSB7XHJcblx0ICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKTtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS50b2xlcmF0ZUVycm9yID0gZnVuY3Rpb24gKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKTtcclxuXHQgICAgICAgIGlmICh0aGlzLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5yZWNvcmRFcnJvcihlcnJvcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIEVycm9ySGFuZGxlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXJyb3JIYW5kbGVyID0gRXJyb3JIYW5kbGVyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0Ly8gRXJyb3IgbWVzc2FnZXMgc2hvdWxkIGJlIGlkZW50aWNhbCB0byBWOC5cclxuXHRleHBvcnRzLk1lc3NhZ2VzID0ge1xyXG5cdCAgICBCYWRHZXR0ZXJBcml0eTogJ0dldHRlciBtdXN0IG5vdCBoYXZlIGFueSBmb3JtYWwgcGFyYW1ldGVycycsXHJcblx0ICAgIEJhZFNldHRlckFyaXR5OiAnU2V0dGVyIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBmb3JtYWwgcGFyYW1ldGVyJyxcclxuXHQgICAgQmFkU2V0dGVyUmVzdFBhcmFtZXRlcjogJ1NldHRlciBmdW5jdGlvbiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIHJlc3QgcGFyYW1ldGVyJyxcclxuXHQgICAgQ29uc3RydWN0b3JJc0FzeW5jOiAnQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhbiBhc3luYyBtZXRob2QnLFxyXG5cdCAgICBDb25zdHJ1Y3RvclNwZWNpYWxNZXRob2Q6ICdDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFjY2Vzc29yJyxcclxuXHQgICAgRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXI6ICdNaXNzaW5nIGluaXRpYWxpemVyIGluICUwIGRlY2xhcmF0aW9uJyxcclxuXHQgICAgRGVmYXVsdFJlc3RQYXJhbWV0ZXI6ICdVbmV4cGVjdGVkIHRva2VuID0nLFxyXG5cdCAgICBEdXBsaWNhdGVCaW5kaW5nOiAnRHVwbGljYXRlIGJpbmRpbmcgJTAnLFxyXG5cdCAgICBEdXBsaWNhdGVDb25zdHJ1Y3RvcjogJ0EgY2xhc3MgbWF5IG9ubHkgaGF2ZSBvbmUgY29uc3RydWN0b3InLFxyXG5cdCAgICBEdXBsaWNhdGVQcm90b1Byb3BlcnR5OiAnRHVwbGljYXRlIF9fcHJvdG9fXyBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIGluIG9iamVjdCBsaXRlcmFscycsXHJcblx0ICAgIEZvckluT2ZMb29wSW5pdGlhbGl6ZXI6ICclMCBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplcicsXHJcblx0ICAgIEdlbmVyYXRvckluTGVnYWN5Q29udGV4dDogJ0dlbmVyYXRvciBkZWNsYXJhdGlvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGxlZ2FjeSBjb250ZXh0cycsXHJcblx0ICAgIElsbGVnYWxCcmVhazogJ0lsbGVnYWwgYnJlYWsgc3RhdGVtZW50JyxcclxuXHQgICAgSWxsZWdhbENvbnRpbnVlOiAnSWxsZWdhbCBjb250aW51ZSBzdGF0ZW1lbnQnLFxyXG5cdCAgICBJbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb246ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIElsbGVnYWxMYW5ndWFnZU1vZGVEaXJlY3RpdmU6ICdJbGxlZ2FsIFxcJ3VzZSBzdHJpY3RcXCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdCcsXHJcblx0ICAgIElsbGVnYWxSZXR1cm46ICdJbGxlZ2FsIHJldHVybiBzdGF0ZW1lbnQnLFxyXG5cdCAgICBJbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZDogJ0tleXdvcmQgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnMnLFxyXG5cdCAgICBJbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2U6ICdJbnZhbGlkIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZScsXHJcblx0ICAgIEludmFsaWRMSFNJbkFzc2lnbm1lbnQ6ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGFzc2lnbm1lbnQnLFxyXG5cdCAgICBJbnZhbGlkTEhTSW5Gb3JJbjogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcclxuXHQgICAgSW52YWxpZExIU0luRm9yTG9vcDogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWxvb3AnLFxyXG5cdCAgICBJbnZhbGlkTW9kdWxlU3BlY2lmaWVyOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIEludmFsaWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXHJcblx0ICAgIExldEluTGV4aWNhbEJpbmRpbmc6ICdsZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lJyxcclxuXHQgICAgTWlzc2luZ0Zyb21DbGF1c2U6ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcclxuXHQgICAgTmV3bGluZUFmdGVyVGhyb3c6ICdJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cnLFxyXG5cdCAgICBOb0FzQWZ0ZXJJbXBvcnROYW1lc3BhY2U6ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgTm9DYXRjaE9yRmluYWxseTogJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxyXG5cdCAgICBQYXJhbWV0ZXJBZnRlclJlc3RQYXJhbWV0ZXI6ICdSZXN0IHBhcmFtZXRlciBtdXN0IGJlIGxhc3QgZm9ybWFsIHBhcmFtZXRlcicsXHJcblx0ICAgIFJlZGVjbGFyYXRpb246ICclMCBcXCclMVxcJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkJyxcclxuXHQgICAgU3RhdGljUHJvdG90eXBlOiAnQ2xhc3NlcyBtYXkgbm90IGhhdmUgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZScsXHJcblx0ICAgIFN0cmljdENhdGNoVmFyaWFibGU6ICdDYXRjaCB2YXJpYWJsZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0RGVsZXRlOiAnRGVsZXRlIG9mIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUuJyxcclxuXHQgICAgU3RyaWN0RnVuY3Rpb246ICdJbiBzdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrJyxcclxuXHQgICAgU3RyaWN0RnVuY3Rpb25OYW1lOiAnRnVuY3Rpb24gbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TEhTQXNzaWdubWVudDogJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RMSFNQb3N0Zml4OiAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TEhTUHJlZml4OiAnUHJlZml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RNb2RlV2l0aDogJ1N0cmljdCBtb2RlIGNvZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnQnLFxyXG5cdCAgICBTdHJpY3RPY3RhbExpdGVyYWw6ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcclxuXHQgICAgU3RyaWN0UGFyYW1EdXBlOiAnU3RyaWN0IG1vZGUgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMnLFxyXG5cdCAgICBTdHJpY3RQYXJhbU5hbWU6ICdQYXJhbWV0ZXIgbmFtZSBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdFJlc2VydmVkV29yZDogJ1VzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdFZhck5hbWU6ICdWYXJpYWJsZSBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBUZW1wbGF0ZU9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiB0ZW1wbGF0ZSBzdHJpbmdzLicsXHJcblx0ICAgIFVuZXhwZWN0ZWRFT1M6ICdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRJZGVudGlmaWVyOiAnVW5leHBlY3RlZCBpZGVudGlmaWVyJyxcclxuXHQgICAgVW5leHBlY3RlZE51bWJlcjogJ1VuZXhwZWN0ZWQgbnVtYmVyJyxcclxuXHQgICAgVW5leHBlY3RlZFJlc2VydmVkOiAnVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkJyxcclxuXHQgICAgVW5leHBlY3RlZFN0cmluZzogJ1VuZXhwZWN0ZWQgc3RyaW5nJyxcclxuXHQgICAgVW5leHBlY3RlZFRlbXBsYXRlOiAnVW5leHBlY3RlZCBxdWFzaSAlMCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRUb2tlbjogJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxyXG5cdCAgICBVbmV4cGVjdGVkVG9rZW5JbGxlZ2FsOiAnVW5leHBlY3RlZCB0b2tlbiBJTExFR0FMJyxcclxuXHQgICAgVW5rbm93bkxhYmVsOiAnVW5kZWZpbmVkIGxhYmVsIFxcJyUwXFwnJyxcclxuXHQgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLydcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGFzc2VydF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHR2YXIgY2hhcmFjdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cdHZhciBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblx0ZnVuY3Rpb24gaGV4VmFsdWUoY2gpIHtcclxuXHQgICAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBvY3RhbFZhbHVlKGNoKSB7XHJcblx0ICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpO1xyXG5cdH1cclxuXHR2YXIgU2Nhbm5lciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNjYW5uZXIoY29kZSwgaGFuZGxlcikge1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBjb2RlO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cdCAgICAgICAgdGhpcy50cmFja0NvbW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMubGVuZ3RoID0gY29kZS5sZW5ndGg7XHJcblx0ICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuXHQgICAgICAgIHRoaXMubGluZU51bWJlciA9IChjb2RlLmxlbmd0aCA+IDApID8gMSA6IDA7XHJcblx0ICAgICAgICB0aGlzLmxpbmVTdGFydCA9IDA7XHJcblx0ICAgICAgICB0aGlzLmN1cmx5U3RhY2sgPSBbXTtcclxuXHQgICAgfVxyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zYXZlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5yZXN0b3JlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuXHQgICAgICAgIHRoaXMuaW5kZXggPSBzdGF0ZS5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGluZU51bWJlciA9IHN0YXRlLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuZW9mID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPj0gdGhpcy5sZW5ndGg7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnRocm93VW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuSWxsZWdhbDsgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLnRocm93RXJyb3IodGhpcy5pbmRleCwgdGhpcy5saW5lTnVtYmVyLCB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgKyAxLCBtZXNzYWdlKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG5cdCAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW5JbGxlZ2FsOyB9XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmF0ZUVycm9yKHRoaXMuaW5kZXgsIHRoaXMubGluZU51bWJlciwgdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0ICsgMSwgbWVzc2FnZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbW1lbnRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNraXBTaW5nbGVMaW5lQ29tbWVudCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHQgICAgICAgIHZhciBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0LCBsb2M7XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5pbmRleCAtIG9mZnNldDtcclxuXHQgICAgICAgICAgICBsb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCAtIG9mZnNldFxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHt9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCAtIDFcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiBmYWxzZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgb2Zmc2V0LCB0aGlzLmluZGV4IC0gMV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleCAtIDFdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAxMyAmJiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpID09PSAxMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgIG11bHRpTGluZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyBvZmZzZXQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5za2lwTXVsdGlMaW5lQ29tbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0LCBsb2M7XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5pbmRleCAtIDI7XHJcblx0ICAgICAgICAgICAgbG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgLSAyXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge31cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSA9PT0gMHgwQSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MkEpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gQmxvY2sgY29tbWVudCBlbmRzIHdpdGggJyovJy5cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpID09PSAweDJGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpTGluZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIDIsIHRoaXMuaW5kZXggLSAyXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUmFuIG9mZiB0aGUgZW5kIG9mIHRoZSBmaWxlIC0gdGhlIHdob2xlIHRoaW5nIGlzIGEgY29tbWVudFxyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyAyLCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnRzO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBzdGFydCA9ICh0aGlzLmluZGV4ID09PSAwKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc1doaXRlU3BhY2UoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgPT09IDB4MEEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJGKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgyRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBTaW5nbGVMaW5lQ29tbWVudCgyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJBKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcE11bHRpTGluZUNvbW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQgJiYgY2ggPT09IDB4MkQpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gVSswMDNFIGlzICc+J1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpID09PSAweDJEKSAmJiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMikgPT09IDB4M0UpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyAnLS0+JyBpcyBhIHNpbmdsZS1saW5lIGNvbW1lbnRcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwU2luZ2xlTGluZUNvbW1lbnQoMyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDNDKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5zbGljZSh0aGlzLmluZGV4ICsgMSwgdGhpcy5pbmRleCArIDQpID09PSAnIS0tJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSA0OyAvLyBgPCEtLWBcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwU2luZ2xlTGluZUNvbW1lbnQoNCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZ1dHVyZS1yZXNlcnZlZC13b3Jkc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc0Z1dHVyZVJlc2VydmVkV29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgc3dpdGNoIChpZCkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ2VudW0nOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2V4cG9ydCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnaW1wb3J0JzpcclxuXHQgICAgICAgICAgICBjYXNlICdzdXBlcic6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGlkKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwYWNrYWdlJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwcml2YXRlJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwcm90ZWN0ZWQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3B1YmxpYyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnc3RhdGljJzpcclxuXHQgICAgICAgICAgICBjYXNlICd5aWVsZCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnbGV0JzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc1Jlc3RyaWN0ZWRXb3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWtleXdvcmRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzS2V5d29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDI6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKTtcclxuXHQgICAgICAgICAgICBjYXNlIDM6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAndHJ5JykgfHwgKGlkID09PSAnbGV0Jyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNTpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHwgKGlkID09PSAneWllbGQnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNjpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcclxuXHQgICAgICAgICAgICBjYXNlIDc6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpIHx8IChpZCA9PT0gJ2V4dGVuZHMnKTtcclxuXHQgICAgICAgICAgICBjYXNlIDg6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcclxuXHQgICAgICAgICAgICBjYXNlIDEwOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuY29kZVBvaW50QXQgPSBmdW5jdGlvbiAoaSkge1xyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdChpKTtcclxuXHQgICAgICAgIGlmIChjcCA+PSAweEQ4MDAgJiYgY3AgPD0gMHhEQkZGKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHNlY29uZCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQoaSArIDEpO1xyXG5cdCAgICAgICAgICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gY3A7XHJcblx0ICAgICAgICAgICAgICAgIGNwID0gKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY3A7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5IZXhFc2NhcGUgPSBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0ICAgICAgICB2YXIgbGVuID0gKHByZWZpeCA9PT0gJ3UnKSA/IDQgOiAyO1xyXG5cdCAgICAgICAgdmFyIGNvZGUgPSAwO1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5lb2YoKSAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgaGV4VmFsdWUodGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIHZhciBjb2RlID0gMDtcclxuXHQgICAgICAgIC8vIEF0IGxlYXN0LCBvbmUgaGV4IGRpZ2l0IGlzIHJlcXVpcmVkLlxyXG5cdCAgICAgICAgaWYgKGNoID09PSAnfScpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArIGhleFZhbHVlKGNoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYgfHwgY2ggIT09ICd9Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjb2RlKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuZ2V0SWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXgrKztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIEJsYWNrc2xhc2ggKFUrMDA1QykgbWFya3MgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcGxleElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPj0gMHhEODAwICYmIGNoIDwgMHhERkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycy5cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wbGV4SWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zbGljZShzdGFydCwgdGhpcy5pbmRleCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmdldENvbXBsZXhJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5jb2RlUG9pbnRBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgIHZhciBpZCA9IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKTtcclxuXHQgICAgICAgIHRoaXMuaW5kZXggKz0gaWQubGVuZ3RoO1xyXG5cdCAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgdmFyIGNoO1xyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDVDKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgIT09IDB4NzUpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuSGV4RXNjYXBlKCd1Jyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gbnVsbCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZCA9IGNoO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY3AgPSB0aGlzLmNvZGVQb2ludEF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY3ApKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjaCA9IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKTtcclxuXHQgICAgICAgICAgICBpZCArPSBjaDtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ICs9IGNoLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICAgICAgaWYgKGNwID09PSAweDVDKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyKDAsIGlkLmxlbmd0aCAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSAhPT0gMHg3NSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5IZXhFc2NhcGUoJ3UnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gbnVsbCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZCArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gaWQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLm9jdGFsVG9EZWNpbWFsID0gZnVuY3Rpb24gKGNoKSB7XHJcblx0ICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxyXG5cdCAgICAgICAgdmFyIG9jdGFsID0gKGNoICE9PSAnMCcpO1xyXG5cdCAgICAgICAgdmFyIGNvZGUgPSBvY3RhbFZhbHVlKGNoKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5lb2YoKSAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArIG9jdGFsVmFsdWUodGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXSk7XHJcblx0ICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcclxuXHQgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcclxuXHQgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiYgIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyBvY3RhbFZhbHVlKHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK10pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgY29kZTogY29kZSxcclxuXHQgICAgICAgICAgICBvY3RhbDogb2N0YWxcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW5hbWVzLWFuZC1rZXl3b3Jkc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciB0eXBlO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICB2YXIgaWQgPSAodGhpcy5zb3VyY2UuY2hhckNvZGVBdChzdGFydCkgPT09IDB4NUMpID8gdGhpcy5nZXRDb21wbGV4SWRlbnRpZmllcigpIDogdGhpcy5nZXRJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAvLyBUaGVyZSBpcyBubyBrZXl3b3JkIG9yIGxpdGVyYWwgd2l0aCBvbmx5IG9uZSBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICAvLyBUaHVzLCBpdCBtdXN0IGJlIGFuIGlkZW50aWZpZXIuXHJcblx0ICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDMgLyogSWRlbnRpZmllciAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKGlkKSkge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSA0IC8qIEtleXdvcmQgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDUgLyogTnVsbExpdGVyYWwgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDEgLyogQm9vbGVhbkxpdGVyYWwgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gMyAvKiBJZGVudGlmaWVyICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHR5cGUgIT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAoc3RhcnQgKyBpZC5sZW5ndGggIT09IHRoaXMuaW5kZXgpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSByZXN0b3JlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBpZCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wdW5jdHVhdG9yc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUHVuY3R1YXRvciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAvLyBDaGVjayBmb3IgbW9zdCBjb21tb24gc2luZ2xlLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgIHZhciBzdHIgPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIHN3aXRjaCAoc3RyKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAnKCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAneyc6XHJcblx0ICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnB1c2goJ3snKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJy4nOlxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJy4nICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXggKyAxXSA9PT0gJy4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTcHJlYWQgb3BlcmF0b3I6IC4uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uLic7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnfSc6XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICcpJzpcclxuXHQgICAgICAgICAgICBjYXNlICc7JzpcclxuXHQgICAgICAgICAgICBjYXNlICcsJzpcclxuXHQgICAgICAgICAgICBjYXNlICdbJzpcclxuXHQgICAgICAgICAgICBjYXNlICddJzpcclxuXHQgICAgICAgICAgICBjYXNlICc6JzpcclxuXHQgICAgICAgICAgICBjYXNlICc/JzpcclxuXHQgICAgICAgICAgICBjYXNlICd+JzpcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAvLyA0LWNoYXJhY3RlciBwdW5jdHVhdG9yLlxyXG5cdCAgICAgICAgICAgICAgICBzdHIgPSB0aGlzLnNvdXJjZS5zdWJzdHIodGhpcy5pbmRleCwgNCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICc+Pj49Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSA0O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIDMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJz09PScgfHwgc3RyID09PSAnIT09JyB8fCBzdHIgPT09ICc+Pj4nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPDw9JyB8fCBzdHIgPT09ICc+Pj0nIHx8IHN0ciA9PT0gJyoqPScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIDIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICcmJicgfHwgc3RyID09PSAnfHwnIHx8IHN0ciA9PT0gJz09JyB8fCBzdHIgPT09ICchPScgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnKz0nIHx8IHN0ciA9PT0gJy09JyB8fCBzdHIgPT09ICcqPScgfHwgc3RyID09PSAnLz0nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJysrJyB8fCBzdHIgPT09ICctLScgfHwgc3RyID09PSAnPDwnIHx8IHN0ciA9PT0gJz4+JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcmPScgfHwgc3RyID09PSAnfD0nIHx8IHN0ciA9PT0gJ149JyB8fCBzdHIgPT09ICclPScgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPD0nIHx8IHN0ciA9PT0gJz49JyB8fCBzdHIgPT09ICc9PicgfHwgc3RyID09PSAnKionKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2Yoc3RyKSA+PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSBzdGFydCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNyAvKiBQdW5jdHVhdG9yICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBzdHIsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtbnVtZXJpYy1saXRlcmFsc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuSGV4TGl0ZXJhbCA9IGZ1bmN0aW9uIChzdGFydCkge1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAobnVtLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KCcweCcgKyBudW0sIDE2KSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuQmluYXJ5TGl0ZXJhbCA9IGZ1bmN0aW9uIChzdGFydCkge1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgdmFyIGNoO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChudW0ubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgLy8gb25seSAwYiBvciAwQlxyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY2gpIHx8IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtLCAyKSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuT2N0YWxMaXRlcmFsID0gZnVuY3Rpb24gKHByZWZpeCwgc3RhcnQpIHtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIHZhciBvY3RhbCA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQocHJlZml4LmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIG51bSA9ICcwJyArIHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFvY3RhbCAmJiBudW0ubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgLy8gb25seSAwbyBvciAwT1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkgfHwgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW0sIDgpLFxyXG5cdCAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc0ltcGxpY2l0T2N0YWxMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gSW1wbGljaXQgb2N0YWwsIHVubGVzcyB0aGVyZSBpcyBhIG5vbi1vY3RhbCBkaWdpdC5cclxuXHQgICAgICAgIC8vIChBbm5leCBCLjEuMSBvbiBOdW1lcmljIExpdGVyYWxzKVxyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuaW5kZXggKyAxOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW2ldO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJzgnIHx8IGNoID09PSAnOScpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5OdW1lcmljTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVtzdGFydF07XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpIHx8IChjaCA9PT0gJy4nKSwgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgaWYgKGNoICE9PSAnLicpIHtcclxuXHQgICAgICAgICAgICBudW0gPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxyXG5cdCAgICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXHJcblx0ICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIGluIEVTNiBzdGFydHMgd2l0aCAnMG8nLlxyXG5cdCAgICAgICAgICAgIC8vIEJpbmFyeSBudW1iZXIgaW4gRVM2IHN0YXJ0cyB3aXRoICcwYicuXHJcblx0ICAgICAgICAgICAgaWYgKG51bSA9PT0gJzAnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdiJyB8fCBjaCA9PT0gJ0InKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQmluYXJ5TGl0ZXJhbChzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnbycgfHwgY2ggPT09ICdPJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9jdGFsTGl0ZXJhbChjaCwgc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ltcGxpY2l0T2N0YWxMaXRlcmFsKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcclxuXHQgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bSksXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtc3RyaW5nLWxpdGVyYWxzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5TdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBxdW90ZSA9IHRoaXMuc291cmNlW3N0YXJ0XTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydCgocXVvdGUgPT09ICdcXCcnIHx8IHF1b3RlID09PSAnXCInKSwgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xyXG5cdCAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIG9jdGFsID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc3RyID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgcXVvdGUgPSAnJztcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWNoIHx8ICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWRfMSA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkXzEgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkXzE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWQgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZEhleEVzY2FwZVNlcXVlbmNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzgnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzknOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvY3RUb0RlYyA9IHRoaXMub2N0YWxUb0RlY2ltYWwoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSBvY3RUb0RlYy5vY3RhbCB8fCBvY3RhbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG9jdFRvRGVjLmNvZGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAocXVvdGUgIT09ICcnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogOCAvKiBTdHJpbmdMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBzdHIsXHJcblx0ICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5UZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjb29rZWQgPSAnJztcclxuXHQgICAgICAgIHZhciB0ZXJtaW5hdGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGhlYWQgPSAodGhpcy5zb3VyY2Vbc3RhcnRdID09PSAnYCcpO1xyXG5cdCAgICAgICAgdmFyIHRhaWwgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciByYXdPZmZzZXQgPSAyO1xyXG5cdCAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICdgJykge1xyXG5cdCAgICAgICAgICAgICAgICByYXdPZmZzZXQgPSAxO1xyXG5cdCAgICAgICAgICAgICAgICB0YWlsID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyQnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucHVzaCgnJHsnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xccic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcdCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN0b3JlID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWRfMiA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkXzIgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdW5lc2NhcGVkXzI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gcmVzdG9yZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWQgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZEhleEVzY2FwZVNlcXVlbmNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdW5lc2NhcGVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGYnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHYnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcwJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWw6IFxcMDEgXFwwMiBhbmQgc28gb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVGVtcGxhdGVPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXDAnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWw6IFxcMSBcXDJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5UZW1wbGF0ZU9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXG4nO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghaGVhZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wb3AoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogMTAgLyogVGVtcGxhdGUgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHRoaXMuc291cmNlLnNsaWNlKHN0YXJ0ICsgMSwgdGhpcy5pbmRleCAtIHJhd09mZnNldCksXHJcblx0ICAgICAgICAgICAgY29va2VkOiBjb29rZWQsXHJcblx0ICAgICAgICAgICAgaGVhZDogaGVhZCxcclxuXHQgICAgICAgICAgICB0YWlsOiB0YWlsLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLXJlZ3VsYXItZXhwcmVzc2lvbi1saXRlcmFsc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50ZXN0UmVnRXhwID0gZnVuY3Rpb24gKHBhdHRlcm4sIGZsYWdzKSB7XHJcblx0ICAgICAgICAvLyBUaGUgQk1QIGNoYXJhY3RlciB0byB1c2UgYXMgYSByZXBsYWNlbWVudCBmb3IgYXN0cmFsIHN5bWJvbHMgd2hlblxyXG5cdCAgICAgICAgLy8gdHJhbnNsYXRpbmcgYW4gRVM2IFwidVwiLWZsYWdnZWQgcGF0dGVybiB0byBhbiBFUzUtY29tcGF0aWJsZVxyXG5cdCAgICAgICAgLy8gYXBwcm94aW1hdGlvbi5cclxuXHQgICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoICdcXHVGRkZGJyBlbmFibGVzIGZhbHNlIHBvc2l0aXZlcyBpbiB1bmxpa2VseVxyXG5cdCAgICAgICAgLy8gc2NlbmFyaW9zLiBGb3IgZXhhbXBsZSwgYFtcXHV7MTA0NGZ9LVxcdXsxMDQ0MH1dYCBpcyBhbiBpbnZhbGlkXHJcblx0ICAgICAgICAvLyBwYXR0ZXJuIHRoYXQgd291bGQgbm90IGJlIGRldGVjdGVkIGJ5IHRoaXMgc3Vic3RpdHV0aW9uLlxyXG5cdCAgICAgICAgdmFyIGFzdHJhbFN1YnN0aXR1dGUgPSAnXFx1RkZGRic7XHJcblx0ICAgICAgICB2YXIgdG1wID0gcGF0dGVybjtcclxuXHQgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHQgICAgICAgIGlmIChmbGFncy5pbmRleE9mKCd1JykgPj0gMCkge1xyXG5cdCAgICAgICAgICAgIHRtcCA9IHRtcFxyXG5cdCAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfXxcXFxcdShbYS1mQS1GMC05XXs0fSkvZywgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHBhcnNlSW50KCQxIHx8ICQyLCAxNik7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiAweDEwRkZGRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2VsZi50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhc3RyYWxTdWJzdGl0dXRlO1xyXG5cdCAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csIGFzdHJhbFN1YnN0aXR1dGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXHJcblx0ICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgIFJlZ0V4cCh0bXApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgY2F0Y2ggKGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvclxyXG5cdCAgICAgICAgLy8gYG51bGxgIGluIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdFxyXG5cdCAgICAgICAgLy8gdXNlcy5cclxuXHQgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgY2F0Y2ggKGV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5SZWdFeHBCb2R5ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XHJcblx0ICAgICAgICB2YXIgc3RyID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIHZhciBjbGFzc01hcmtlciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1yZWd1bGFyLWV4cHJlc3Npb24tbGl0ZXJhbHNcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjbGFzc01hcmtlcikge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdbJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBFeGNsdWRlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxyXG5cdCAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RyID0gJyc7XHJcblx0ICAgICAgICB2YXIgZmxhZ3MgPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiAhdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSB0aGlzLnNjYW5IZXhFc2NhcGUoJ3UnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2hhcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHN0ciArPSAnXFxcXHUnOyByZXN0b3JlIDwgdGhpcy5pbmRleDsgKytyZXN0b3JlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB0aGlzLnNvdXJjZVtyZXN0b3JlXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gcmVzdG9yZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBmbGFncztcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblJlZ0V4cCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMuc2NhblJlZ0V4cEJvZHkoKTtcclxuXHQgICAgICAgIHZhciBmbGFncyA9IHRoaXMuc2NhblJlZ0V4cEZsYWdzKCk7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnRlc3RSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxyXG5cdCAgICAgICAgICAgIGZsYWdzOiBmbGFncyxcclxuXHQgICAgICAgICAgICByZWdleDogdmFsdWUsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIEVPRiAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmluZGV4LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY3ApKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4MjggfHwgY3AgPT09IDB4MjkgfHwgY3AgPT09IDB4M0IpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuUHVuY3R1YXRvcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHgyNyB8fCBjcCA9PT0gMHgyMikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5TdHJpbmdMaXRlcmFsKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBEb3QgKC4pIFUrMDAyRSBjYW4gYWxzbyBzdGFydCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciwgaGVuY2UgdGhlIG5lZWRcclxuXHQgICAgICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHgyRSkge1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1lcmljTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuUHVuY3R1YXRvcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjcCkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuTnVtZXJpY0xpdGVyYWwoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFRlbXBsYXRlIGxpdGVyYWxzIHN0YXJ0IHdpdGggYCAoVSswMDYwKSBmb3IgdGVtcGxhdGUgaGVhZFxyXG5cdCAgICAgICAgLy8gb3IgfSAoVSswMDdEKSBmb3IgdGVtcGxhdGUgbWlkZGxlIG9yIHRlbXBsYXRlIHRhaWwuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4NjAgfHwgKGNwID09PSAweDdEICYmIHRoaXMuY3VybHlTdGFja1t0aGlzLmN1cmx5U3RhY2subGVuZ3RoIC0gMV0gPT09ICckeycpKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblRlbXBsYXRlKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBQb3NzaWJsZSBpZGVudGlmaWVyIHN0YXJ0IGluIGEgc3Vycm9nYXRlIHBhaXIuXHJcblx0ICAgICAgICBpZiAoY3AgPj0gMHhEODAwICYmIGNwIDwgMHhERkZGKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLmNvZGVQb2ludEF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNjYW5QdW5jdHVhdG9yKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBTY2FubmVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TY2FubmVyID0gU2Nhbm5lcjtcclxuXG5cbi8qKiovIH0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lID0ge307XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMSAvKiBCb29sZWFuTGl0ZXJhbCAqL10gPSAnQm9vbGVhbic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMiAvKiBFT0YgKi9dID0gJzxlbmQ+JztcclxuXHRleHBvcnRzLlRva2VuTmFtZVszIC8qIElkZW50aWZpZXIgKi9dID0gJ0lkZW50aWZpZXInO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzQgLyogS2V5d29yZCAqL10gPSAnS2V5d29yZCc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNSAvKiBOdWxsTGl0ZXJhbCAqL10gPSAnTnVsbCc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNiAvKiBOdW1lcmljTGl0ZXJhbCAqL10gPSAnTnVtZXJpYyc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNyAvKiBQdW5jdHVhdG9yICovXSA9ICdQdW5jdHVhdG9yJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs4IC8qIFN0cmluZ0xpdGVyYWwgKi9dID0gJ1N0cmluZyc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqL10gPSAnUmVndWxhckV4cHJlc3Npb24nO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzEwIC8qIFRlbXBsYXRlICovXSA9ICdUZW1wbGF0ZSc7XHJcblxuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8vIEdlbmVyYXRlZCBieSBnZW5lcmF0ZS14aHRtbC1lbnRpdGllcy5qcy4gRE8gTk9UIE1PRElGWSFcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5YSFRNTEVudGl0aWVzID0ge1xyXG5cdCAgICBxdW90OiAnXFx1MDAyMicsXHJcblx0ICAgIGFtcDogJ1xcdTAwMjYnLFxyXG5cdCAgICBhcG9zOiAnXFx1MDAyNycsXHJcblx0ICAgIGd0OiAnXFx1MDAzRScsXHJcblx0ICAgIG5ic3A6ICdcXHUwMEEwJyxcclxuXHQgICAgaWV4Y2w6ICdcXHUwMEExJyxcclxuXHQgICAgY2VudDogJ1xcdTAwQTInLFxyXG5cdCAgICBwb3VuZDogJ1xcdTAwQTMnLFxyXG5cdCAgICBjdXJyZW46ICdcXHUwMEE0JyxcclxuXHQgICAgeWVuOiAnXFx1MDBBNScsXHJcblx0ICAgIGJydmJhcjogJ1xcdTAwQTYnLFxyXG5cdCAgICBzZWN0OiAnXFx1MDBBNycsXHJcblx0ICAgIHVtbDogJ1xcdTAwQTgnLFxyXG5cdCAgICBjb3B5OiAnXFx1MDBBOScsXHJcblx0ICAgIG9yZGY6ICdcXHUwMEFBJyxcclxuXHQgICAgbGFxdW86ICdcXHUwMEFCJyxcclxuXHQgICAgbm90OiAnXFx1MDBBQycsXHJcblx0ICAgIHNoeTogJ1xcdTAwQUQnLFxyXG5cdCAgICByZWc6ICdcXHUwMEFFJyxcclxuXHQgICAgbWFjcjogJ1xcdTAwQUYnLFxyXG5cdCAgICBkZWc6ICdcXHUwMEIwJyxcclxuXHQgICAgcGx1c21uOiAnXFx1MDBCMScsXHJcblx0ICAgIHN1cDI6ICdcXHUwMEIyJyxcclxuXHQgICAgc3VwMzogJ1xcdTAwQjMnLFxyXG5cdCAgICBhY3V0ZTogJ1xcdTAwQjQnLFxyXG5cdCAgICBtaWNybzogJ1xcdTAwQjUnLFxyXG5cdCAgICBwYXJhOiAnXFx1MDBCNicsXHJcblx0ICAgIG1pZGRvdDogJ1xcdTAwQjcnLFxyXG5cdCAgICBjZWRpbDogJ1xcdTAwQjgnLFxyXG5cdCAgICBzdXAxOiAnXFx1MDBCOScsXHJcblx0ICAgIG9yZG06ICdcXHUwMEJBJyxcclxuXHQgICAgcmFxdW86ICdcXHUwMEJCJyxcclxuXHQgICAgZnJhYzE0OiAnXFx1MDBCQycsXHJcblx0ICAgIGZyYWMxMjogJ1xcdTAwQkQnLFxyXG5cdCAgICBmcmFjMzQ6ICdcXHUwMEJFJyxcclxuXHQgICAgaXF1ZXN0OiAnXFx1MDBCRicsXHJcblx0ICAgIEFncmF2ZTogJ1xcdTAwQzAnLFxyXG5cdCAgICBBYWN1dGU6ICdcXHUwMEMxJyxcclxuXHQgICAgQWNpcmM6ICdcXHUwMEMyJyxcclxuXHQgICAgQXRpbGRlOiAnXFx1MDBDMycsXHJcblx0ICAgIEF1bWw6ICdcXHUwMEM0JyxcclxuXHQgICAgQXJpbmc6ICdcXHUwMEM1JyxcclxuXHQgICAgQUVsaWc6ICdcXHUwMEM2JyxcclxuXHQgICAgQ2NlZGlsOiAnXFx1MDBDNycsXHJcblx0ICAgIEVncmF2ZTogJ1xcdTAwQzgnLFxyXG5cdCAgICBFYWN1dGU6ICdcXHUwMEM5JyxcclxuXHQgICAgRWNpcmM6ICdcXHUwMENBJyxcclxuXHQgICAgRXVtbDogJ1xcdTAwQ0InLFxyXG5cdCAgICBJZ3JhdmU6ICdcXHUwMENDJyxcclxuXHQgICAgSWFjdXRlOiAnXFx1MDBDRCcsXHJcblx0ICAgIEljaXJjOiAnXFx1MDBDRScsXHJcblx0ICAgIEl1bWw6ICdcXHUwMENGJyxcclxuXHQgICAgRVRIOiAnXFx1MDBEMCcsXHJcblx0ICAgIE50aWxkZTogJ1xcdTAwRDEnLFxyXG5cdCAgICBPZ3JhdmU6ICdcXHUwMEQyJyxcclxuXHQgICAgT2FjdXRlOiAnXFx1MDBEMycsXHJcblx0ICAgIE9jaXJjOiAnXFx1MDBENCcsXHJcblx0ICAgIE90aWxkZTogJ1xcdTAwRDUnLFxyXG5cdCAgICBPdW1sOiAnXFx1MDBENicsXHJcblx0ICAgIHRpbWVzOiAnXFx1MDBENycsXHJcblx0ICAgIE9zbGFzaDogJ1xcdTAwRDgnLFxyXG5cdCAgICBVZ3JhdmU6ICdcXHUwMEQ5JyxcclxuXHQgICAgVWFjdXRlOiAnXFx1MDBEQScsXHJcblx0ICAgIFVjaXJjOiAnXFx1MDBEQicsXHJcblx0ICAgIFV1bWw6ICdcXHUwMERDJyxcclxuXHQgICAgWWFjdXRlOiAnXFx1MDBERCcsXHJcblx0ICAgIFRIT1JOOiAnXFx1MDBERScsXHJcblx0ICAgIHN6bGlnOiAnXFx1MDBERicsXHJcblx0ICAgIGFncmF2ZTogJ1xcdTAwRTAnLFxyXG5cdCAgICBhYWN1dGU6ICdcXHUwMEUxJyxcclxuXHQgICAgYWNpcmM6ICdcXHUwMEUyJyxcclxuXHQgICAgYXRpbGRlOiAnXFx1MDBFMycsXHJcblx0ICAgIGF1bWw6ICdcXHUwMEU0JyxcclxuXHQgICAgYXJpbmc6ICdcXHUwMEU1JyxcclxuXHQgICAgYWVsaWc6ICdcXHUwMEU2JyxcclxuXHQgICAgY2NlZGlsOiAnXFx1MDBFNycsXHJcblx0ICAgIGVncmF2ZTogJ1xcdTAwRTgnLFxyXG5cdCAgICBlYWN1dGU6ICdcXHUwMEU5JyxcclxuXHQgICAgZWNpcmM6ICdcXHUwMEVBJyxcclxuXHQgICAgZXVtbDogJ1xcdTAwRUInLFxyXG5cdCAgICBpZ3JhdmU6ICdcXHUwMEVDJyxcclxuXHQgICAgaWFjdXRlOiAnXFx1MDBFRCcsXHJcblx0ICAgIGljaXJjOiAnXFx1MDBFRScsXHJcblx0ICAgIGl1bWw6ICdcXHUwMEVGJyxcclxuXHQgICAgZXRoOiAnXFx1MDBGMCcsXHJcblx0ICAgIG50aWxkZTogJ1xcdTAwRjEnLFxyXG5cdCAgICBvZ3JhdmU6ICdcXHUwMEYyJyxcclxuXHQgICAgb2FjdXRlOiAnXFx1MDBGMycsXHJcblx0ICAgIG9jaXJjOiAnXFx1MDBGNCcsXHJcblx0ICAgIG90aWxkZTogJ1xcdTAwRjUnLFxyXG5cdCAgICBvdW1sOiAnXFx1MDBGNicsXHJcblx0ICAgIGRpdmlkZTogJ1xcdTAwRjcnLFxyXG5cdCAgICBvc2xhc2g6ICdcXHUwMEY4JyxcclxuXHQgICAgdWdyYXZlOiAnXFx1MDBGOScsXHJcblx0ICAgIHVhY3V0ZTogJ1xcdTAwRkEnLFxyXG5cdCAgICB1Y2lyYzogJ1xcdTAwRkInLFxyXG5cdCAgICB1dW1sOiAnXFx1MDBGQycsXHJcblx0ICAgIHlhY3V0ZTogJ1xcdTAwRkQnLFxyXG5cdCAgICB0aG9ybjogJ1xcdTAwRkUnLFxyXG5cdCAgICB5dW1sOiAnXFx1MDBGRicsXHJcblx0ICAgIE9FbGlnOiAnXFx1MDE1MicsXHJcblx0ICAgIG9lbGlnOiAnXFx1MDE1MycsXHJcblx0ICAgIFNjYXJvbjogJ1xcdTAxNjAnLFxyXG5cdCAgICBzY2Fyb246ICdcXHUwMTYxJyxcclxuXHQgICAgWXVtbDogJ1xcdTAxNzgnLFxyXG5cdCAgICBmbm9mOiAnXFx1MDE5MicsXHJcblx0ICAgIGNpcmM6ICdcXHUwMkM2JyxcclxuXHQgICAgdGlsZGU6ICdcXHUwMkRDJyxcclxuXHQgICAgQWxwaGE6ICdcXHUwMzkxJyxcclxuXHQgICAgQmV0YTogJ1xcdTAzOTInLFxyXG5cdCAgICBHYW1tYTogJ1xcdTAzOTMnLFxyXG5cdCAgICBEZWx0YTogJ1xcdTAzOTQnLFxyXG5cdCAgICBFcHNpbG9uOiAnXFx1MDM5NScsXHJcblx0ICAgIFpldGE6ICdcXHUwMzk2JyxcclxuXHQgICAgRXRhOiAnXFx1MDM5NycsXHJcblx0ICAgIFRoZXRhOiAnXFx1MDM5OCcsXHJcblx0ICAgIElvdGE6ICdcXHUwMzk5JyxcclxuXHQgICAgS2FwcGE6ICdcXHUwMzlBJyxcclxuXHQgICAgTGFtYmRhOiAnXFx1MDM5QicsXHJcblx0ICAgIE11OiAnXFx1MDM5QycsXHJcblx0ICAgIE51OiAnXFx1MDM5RCcsXHJcblx0ICAgIFhpOiAnXFx1MDM5RScsXHJcblx0ICAgIE9taWNyb246ICdcXHUwMzlGJyxcclxuXHQgICAgUGk6ICdcXHUwM0EwJyxcclxuXHQgICAgUmhvOiAnXFx1MDNBMScsXHJcblx0ICAgIFNpZ21hOiAnXFx1MDNBMycsXHJcblx0ICAgIFRhdTogJ1xcdTAzQTQnLFxyXG5cdCAgICBVcHNpbG9uOiAnXFx1MDNBNScsXHJcblx0ICAgIFBoaTogJ1xcdTAzQTYnLFxyXG5cdCAgICBDaGk6ICdcXHUwM0E3JyxcclxuXHQgICAgUHNpOiAnXFx1MDNBOCcsXHJcblx0ICAgIE9tZWdhOiAnXFx1MDNBOScsXHJcblx0ICAgIGFscGhhOiAnXFx1MDNCMScsXHJcblx0ICAgIGJldGE6ICdcXHUwM0IyJyxcclxuXHQgICAgZ2FtbWE6ICdcXHUwM0IzJyxcclxuXHQgICAgZGVsdGE6ICdcXHUwM0I0JyxcclxuXHQgICAgZXBzaWxvbjogJ1xcdTAzQjUnLFxyXG5cdCAgICB6ZXRhOiAnXFx1MDNCNicsXHJcblx0ICAgIGV0YTogJ1xcdTAzQjcnLFxyXG5cdCAgICB0aGV0YTogJ1xcdTAzQjgnLFxyXG5cdCAgICBpb3RhOiAnXFx1MDNCOScsXHJcblx0ICAgIGthcHBhOiAnXFx1MDNCQScsXHJcblx0ICAgIGxhbWJkYTogJ1xcdTAzQkInLFxyXG5cdCAgICBtdTogJ1xcdTAzQkMnLFxyXG5cdCAgICBudTogJ1xcdTAzQkQnLFxyXG5cdCAgICB4aTogJ1xcdTAzQkUnLFxyXG5cdCAgICBvbWljcm9uOiAnXFx1MDNCRicsXHJcblx0ICAgIHBpOiAnXFx1MDNDMCcsXHJcblx0ICAgIHJobzogJ1xcdTAzQzEnLFxyXG5cdCAgICBzaWdtYWY6ICdcXHUwM0MyJyxcclxuXHQgICAgc2lnbWE6ICdcXHUwM0MzJyxcclxuXHQgICAgdGF1OiAnXFx1MDNDNCcsXHJcblx0ICAgIHVwc2lsb246ICdcXHUwM0M1JyxcclxuXHQgICAgcGhpOiAnXFx1MDNDNicsXHJcblx0ICAgIGNoaTogJ1xcdTAzQzcnLFxyXG5cdCAgICBwc2k6ICdcXHUwM0M4JyxcclxuXHQgICAgb21lZ2E6ICdcXHUwM0M5JyxcclxuXHQgICAgdGhldGFzeW06ICdcXHUwM0QxJyxcclxuXHQgICAgdXBzaWg6ICdcXHUwM0QyJyxcclxuXHQgICAgcGl2OiAnXFx1MDNENicsXHJcblx0ICAgIGVuc3A6ICdcXHUyMDAyJyxcclxuXHQgICAgZW1zcDogJ1xcdTIwMDMnLFxyXG5cdCAgICB0aGluc3A6ICdcXHUyMDA5JyxcclxuXHQgICAgenduajogJ1xcdTIwMEMnLFxyXG5cdCAgICB6d2o6ICdcXHUyMDBEJyxcclxuXHQgICAgbHJtOiAnXFx1MjAwRScsXHJcblx0ICAgIHJsbTogJ1xcdTIwMEYnLFxyXG5cdCAgICBuZGFzaDogJ1xcdTIwMTMnLFxyXG5cdCAgICBtZGFzaDogJ1xcdTIwMTQnLFxyXG5cdCAgICBsc3F1bzogJ1xcdTIwMTgnLFxyXG5cdCAgICByc3F1bzogJ1xcdTIwMTknLFxyXG5cdCAgICBzYnF1bzogJ1xcdTIwMUEnLFxyXG5cdCAgICBsZHF1bzogJ1xcdTIwMUMnLFxyXG5cdCAgICByZHF1bzogJ1xcdTIwMUQnLFxyXG5cdCAgICBiZHF1bzogJ1xcdTIwMUUnLFxyXG5cdCAgICBkYWdnZXI6ICdcXHUyMDIwJyxcclxuXHQgICAgRGFnZ2VyOiAnXFx1MjAyMScsXHJcblx0ICAgIGJ1bGw6ICdcXHUyMDIyJyxcclxuXHQgICAgaGVsbGlwOiAnXFx1MjAyNicsXHJcblx0ICAgIHBlcm1pbDogJ1xcdTIwMzAnLFxyXG5cdCAgICBwcmltZTogJ1xcdTIwMzInLFxyXG5cdCAgICBQcmltZTogJ1xcdTIwMzMnLFxyXG5cdCAgICBsc2FxdW86ICdcXHUyMDM5JyxcclxuXHQgICAgcnNhcXVvOiAnXFx1MjAzQScsXHJcblx0ICAgIG9saW5lOiAnXFx1MjAzRScsXHJcblx0ICAgIGZyYXNsOiAnXFx1MjA0NCcsXHJcblx0ICAgIGV1cm86ICdcXHUyMEFDJyxcclxuXHQgICAgaW1hZ2U6ICdcXHUyMTExJyxcclxuXHQgICAgd2VpZXJwOiAnXFx1MjExOCcsXHJcblx0ICAgIHJlYWw6ICdcXHUyMTFDJyxcclxuXHQgICAgdHJhZGU6ICdcXHUyMTIyJyxcclxuXHQgICAgYWxlZnN5bTogJ1xcdTIxMzUnLFxyXG5cdCAgICBsYXJyOiAnXFx1MjE5MCcsXHJcblx0ICAgIHVhcnI6ICdcXHUyMTkxJyxcclxuXHQgICAgcmFycjogJ1xcdTIxOTInLFxyXG5cdCAgICBkYXJyOiAnXFx1MjE5MycsXHJcblx0ICAgIGhhcnI6ICdcXHUyMTk0JyxcclxuXHQgICAgY3JhcnI6ICdcXHUyMUI1JyxcclxuXHQgICAgbEFycjogJ1xcdTIxRDAnLFxyXG5cdCAgICB1QXJyOiAnXFx1MjFEMScsXHJcblx0ICAgIHJBcnI6ICdcXHUyMUQyJyxcclxuXHQgICAgZEFycjogJ1xcdTIxRDMnLFxyXG5cdCAgICBoQXJyOiAnXFx1MjFENCcsXHJcblx0ICAgIGZvcmFsbDogJ1xcdTIyMDAnLFxyXG5cdCAgICBwYXJ0OiAnXFx1MjIwMicsXHJcblx0ICAgIGV4aXN0OiAnXFx1MjIwMycsXHJcblx0ICAgIGVtcHR5OiAnXFx1MjIwNScsXHJcblx0ICAgIG5hYmxhOiAnXFx1MjIwNycsXHJcblx0ICAgIGlzaW46ICdcXHUyMjA4JyxcclxuXHQgICAgbm90aW46ICdcXHUyMjA5JyxcclxuXHQgICAgbmk6ICdcXHUyMjBCJyxcclxuXHQgICAgcHJvZDogJ1xcdTIyMEYnLFxyXG5cdCAgICBzdW06ICdcXHUyMjExJyxcclxuXHQgICAgbWludXM6ICdcXHUyMjEyJyxcclxuXHQgICAgbG93YXN0OiAnXFx1MjIxNycsXHJcblx0ICAgIHJhZGljOiAnXFx1MjIxQScsXHJcblx0ICAgIHByb3A6ICdcXHUyMjFEJyxcclxuXHQgICAgaW5maW46ICdcXHUyMjFFJyxcclxuXHQgICAgYW5nOiAnXFx1MjIyMCcsXHJcblx0ICAgIGFuZDogJ1xcdTIyMjcnLFxyXG5cdCAgICBvcjogJ1xcdTIyMjgnLFxyXG5cdCAgICBjYXA6ICdcXHUyMjI5JyxcclxuXHQgICAgY3VwOiAnXFx1MjIyQScsXHJcblx0ICAgIGludDogJ1xcdTIyMkInLFxyXG5cdCAgICB0aGVyZTQ6ICdcXHUyMjM0JyxcclxuXHQgICAgc2ltOiAnXFx1MjIzQycsXHJcblx0ICAgIGNvbmc6ICdcXHUyMjQ1JyxcclxuXHQgICAgYXN5bXA6ICdcXHUyMjQ4JyxcclxuXHQgICAgbmU6ICdcXHUyMjYwJyxcclxuXHQgICAgZXF1aXY6ICdcXHUyMjYxJyxcclxuXHQgICAgbGU6ICdcXHUyMjY0JyxcclxuXHQgICAgZ2U6ICdcXHUyMjY1JyxcclxuXHQgICAgc3ViOiAnXFx1MjI4MicsXHJcblx0ICAgIHN1cDogJ1xcdTIyODMnLFxyXG5cdCAgICBuc3ViOiAnXFx1MjI4NCcsXHJcblx0ICAgIHN1YmU6ICdcXHUyMjg2JyxcclxuXHQgICAgc3VwZTogJ1xcdTIyODcnLFxyXG5cdCAgICBvcGx1czogJ1xcdTIyOTUnLFxyXG5cdCAgICBvdGltZXM6ICdcXHUyMjk3JyxcclxuXHQgICAgcGVycDogJ1xcdTIyQTUnLFxyXG5cdCAgICBzZG90OiAnXFx1MjJDNScsXHJcblx0ICAgIGxjZWlsOiAnXFx1MjMwOCcsXHJcblx0ICAgIHJjZWlsOiAnXFx1MjMwOScsXHJcblx0ICAgIGxmbG9vcjogJ1xcdTIzMEEnLFxyXG5cdCAgICByZmxvb3I6ICdcXHUyMzBCJyxcclxuXHQgICAgbG96OiAnXFx1MjVDQScsXHJcblx0ICAgIHNwYWRlczogJ1xcdTI2NjAnLFxyXG5cdCAgICBjbHViczogJ1xcdTI2NjMnLFxyXG5cdCAgICBoZWFydHM6ICdcXHUyNjY1JyxcclxuXHQgICAgZGlhbXM6ICdcXHUyNjY2JyxcclxuXHQgICAgbGFuZzogJ1xcdTI3RTgnLFxyXG5cdCAgICByYW5nOiAnXFx1MjdFOSdcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGVycm9yX2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdHZhciBzY2FubmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHR2YXIgdG9rZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cdHZhciBSZWFkZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZWFkZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5jdXJseSA9IHRoaXMucGFyZW4gPSAtMTtcclxuXHQgICAgfVxyXG5cdCAgICAvLyBBIGZ1bmN0aW9uIGZvbGxvd2luZyBvbmUgb2YgdGhvc2UgdG9rZW5zIGlzIGFuIGV4cHJlc3Npb24uXHJcblx0ICAgIFJlYWRlci5wcm90b3R5cGUuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKHQpIHtcclxuXHQgICAgICAgIHJldHVybiBbJygnLCAneycsICdbJywgJ2luJywgJ3R5cGVvZicsICdpbnN0YW5jZW9mJywgJ25ldycsXHJcblx0ICAgICAgICAgICAgJ3JldHVybicsICdjYXNlJywgJ2RlbGV0ZScsICd0aHJvdycsICd2b2lkJyxcclxuXHQgICAgICAgICAgICAvLyBhc3NpZ25tZW50IG9wZXJhdG9yc1xyXG5cdCAgICAgICAgICAgICc9JywgJys9JywgJy09JywgJyo9JywgJyoqPScsICcvPScsICclPScsICc8PD0nLCAnPj49JywgJz4+Pj0nLFxyXG5cdCAgICAgICAgICAgICcmPScsICd8PScsICdePScsICcsJyxcclxuXHQgICAgICAgICAgICAvLyBiaW5hcnkvdW5hcnkgb3BlcmF0b3JzXHJcblx0ICAgICAgICAgICAgJysnLCAnLScsICcqJywgJyoqJywgJy8nLCAnJScsICcrKycsICctLScsICc8PCcsICc+PicsICc+Pj4nLCAnJicsXHJcblx0ICAgICAgICAgICAgJ3wnLCAnXicsICchJywgJ34nLCAnJiYnLCAnfHwnLCAnPycsICc6JywgJz09PScsICc9PScsICc+PScsXHJcblx0ICAgICAgICAgICAgJzw9JywgJzwnLCAnPicsICchPScsICchPT0nXS5pbmRleE9mKHQpID49IDA7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIERldGVybWluZSBpZiBmb3J3YXJkIHNsYXNoICgvKSBpcyBhbiBvcGVyYXRvciBvciBwYXJ0IG9mIGEgcmVndWxhciBleHByZXNzaW9uXHJcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXHJcblx0ICAgIFJlYWRlci5wcm90b3R5cGUuaXNSZWdleFN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy52YWx1ZXNbdGhpcy52YWx1ZXMubGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICB2YXIgcmVnZXggPSAocHJldmlvdXMgIT09IG51bGwpO1xyXG5cdCAgICAgICAgc3dpdGNoIChwcmV2aW91cykge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ3RoaXMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ10nOlxyXG5cdCAgICAgICAgICAgICAgICByZWdleCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICcpJzpcclxuXHQgICAgICAgICAgICAgICAgdmFyIGtleXdvcmQgPSB0aGlzLnZhbHVlc1t0aGlzLnBhcmVuIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgIHJlZ2V4ID0gKGtleXdvcmQgPT09ICdpZicgfHwga2V5d29yZCA9PT0gJ3doaWxlJyB8fCBrZXl3b3JkID09PSAnZm9yJyB8fCBrZXl3b3JkID09PSAnd2l0aCcpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICd9JzpcclxuXHQgICAgICAgICAgICAgICAgLy8gRGl2aWRpbmcgYSBmdW5jdGlvbiBieSBhbnl0aGluZyBtYWtlcyBsaXR0bGUgc2Vuc2UsXHJcblx0ICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxyXG5cdCAgICAgICAgICAgICAgICByZWdleCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDNdID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24oKXt9IC80MlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrID0gdGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDRdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBjaGVjayA/ICF0aGlzLmJlZm9yZUZ1bmN0aW9uRXhwcmVzc2lvbihjaGVjaykgOiBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gNF0gPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE5hbWVkIGZ1bmN0aW9uLCBlLmcuIGZ1bmN0aW9uIGYoKXt9IC80Mi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGVjayA9IHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSA1XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gY2hlY2sgPyAhdGhpcy5iZWZvcmVGdW5jdGlvbkV4cHJlc3Npb24oY2hlY2spIDogdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiByZWdleDtcclxuXHQgICAgfTtcclxuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovIHx8IHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY3VybHkgPSB0aGlzLnZhbHVlcy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnKCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wYXJlbiA9IHRoaXMudmFsdWVzLmxlbmd0aDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh0b2tlbi52YWx1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKG51bGwpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gUmVhZGVyO1xyXG5cdH0oKSk7XHJcblx0dmFyIFRva2VuaXplciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRva2VuaXplcihjb2RlLCBjb25maWcpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbmV3IGVycm9yX2hhbmRsZXJfMS5FcnJvckhhbmRsZXIoKTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYW50ID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcudG9sZXJhbnQgPT09ICdib29sZWFuJyAmJiBjb25maWcudG9sZXJhbnQpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIgPSBuZXcgc2Nhbm5lcl8xLlNjYW5uZXIoY29kZSwgdGhpcy5lcnJvckhhbmRsZXIpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnRyYWNrQ29tbWVudCA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBjb25maWcuY29tbWVudCkgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMudHJhY2tSYW5nZSA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLnJhbmdlID09PSAnYm9vbGVhbicgJiYgY29uZmlnLnJhbmdlKSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy50cmFja0xvYyA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLmxvYyA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy5sb2MpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgUmVhZGVyKCk7XHJcblx0ICAgIH1cclxuXHQgICAgVG9rZW5pemVyLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIuZXJyb3JzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBUb2tlbml6ZXIucHJvdG90eXBlLmdldE5leHRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICB2YXIgY29tbWVudHMgPSB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tZW50cy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBjb21tZW50c1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UoZS5zbGljZVswXSwgZS5zbGljZVsxXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlLm11bHRpTGluZSA/ICdCbG9ja0NvbW1lbnQnIDogJ0xpbmVDb21tZW50JyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja1JhbmdlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IGUucmFuZ2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0xvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQubG9jID0gZS5sb2M7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsb2MgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrTG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB7fVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhcnRSZWdleCA9ICh0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF0gPT09ICcvJykgJiYgdGhpcy5yZWFkZXIuaXNSZWdleFN0YXJ0KCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHN0YXJ0UmVnZXggPyB0aGlzLnNjYW5uZXIuc2NhblJlZ0V4cCgpIDogdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci5wdXNoKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9rZW5fMS5Ub2tlbk5hbWVbdG9rZW4udHlwZV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja1JhbmdlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeS5yYW5nZSA9IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0xvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeS5sb2MgPSBsb2M7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDkgLyogUmVndWxhckV4cHJlc3Npb24gKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gdG9rZW4ucGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmbGFncyA9IHRva2VuLmZsYWdzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkucmVnZXggPSB7IHBhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncyB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zaGlmdCgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gVG9rZW5pemVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XHJcblxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9ub2RlX21vZHVsZXMvZXNwcmltYS9kaXN0L2VzcHJpbWEuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSovXG5cbnZhciBjb21tb24gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcbnZhciBERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG52YXIgREVGQVVMVF9TQUZFX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xuXG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgQ0hBUl9UQUIgICAgICAgICAgICAgICAgICA9IDB4MDk7IC8qIFRhYiAqL1xudmFyIENIQVJfTElORV9GRUVEICAgICAgICAgICAgPSAweDBBOyAvKiBMRiAqL1xudmFyIENIQVJfU1BBQ0UgICAgICAgICAgICAgICAgPSAweDIwOyAvKiBTcGFjZSAqL1xudmFyIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgPSAweDIxOyAvKiAhICovXG52YXIgQ0hBUl9ET1VCTEVfUVVPVEUgICAgICAgICA9IDB4MjI7IC8qIFwiICovXG52YXIgQ0hBUl9TSEFSUCAgICAgICAgICAgICAgICA9IDB4MjM7IC8qICMgKi9cbnZhciBDSEFSX1BFUkNFTlQgICAgICAgICAgICAgID0gMHgyNTsgLyogJSAqL1xudmFyIENIQVJfQU1QRVJTQU5EICAgICAgICAgICAgPSAweDI2OyAvKiAmICovXG52YXIgQ0hBUl9TSU5HTEVfUVVPVEUgICAgICAgICA9IDB4Mjc7IC8qICcgKi9cbnZhciBDSEFSX0FTVEVSSVNLICAgICAgICAgICAgID0gMHgyQTsgLyogKiAqL1xudmFyIENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPSAweDJDOyAvKiAsICovXG52YXIgQ0hBUl9NSU5VUyAgICAgICAgICAgICAgICA9IDB4MkQ7IC8qIC0gKi9cbnZhciBDSEFSX0NPTE9OICAgICAgICAgICAgICAgID0gMHgzQTsgLyogOiAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuXG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDBdICAgPSAnXFxcXDAnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSAgID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gICA9ICdcXFxcYic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDldICAgPSAnXFxcXHQnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSAgID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gICA9ICdcXFxcdic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MENdICAgPSAnXFxcXGYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSAgID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gICA9ICdcXFxcZSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjJdICAgPSAnXFxcXFwiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gICA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdICAgPSAnXFxcXE4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweEEwXSAgID0gJ1xcXFxfJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOV0gPSAnXFxcXFAnO1xuXG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbXG4gICd5JywgJ1knLCAneWVzJywgJ1llcycsICdZRVMnLCAnb24nLCAnT24nLCAnT04nLFxuICAnbicsICdOJywgJ25vJywgJ05vJywgJ05PJywgJ29mZicsICdPZmYnLCAnT0ZGJ1xuXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlTWFwKHNjaGVtYSwgbWFwKSB7XG4gIHZhciByZXN1bHQsIGtleXMsIGluZGV4LCBsZW5ndGgsIHRhZywgc3R5bGUsIHR5cGU7XG5cbiAgaWYgKG1hcCA9PT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHJlc3VsdCA9IHt9O1xuICBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdGFnID0ga2V5c1tpbmRleF07XG4gICAgc3R5bGUgPSBTdHJpbmcobWFwW3RhZ10pO1xuXG4gICAgaWYgKHRhZy5zbGljZSgwLCAyKSA9PT0gJyEhJykge1xuICAgICAgdGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWcuc2xpY2UoMik7XG4gICAgfVxuICAgIHR5cGUgPSBzY2hlbWEuY29tcGlsZWRUeXBlTWFwWydmYWxsYmFjayddW3RhZ107XG5cbiAgICBpZiAodHlwZSAmJiBfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnN0eWxlQWxpYXNlcywgc3R5bGUpKSB7XG4gICAgICBzdHlsZSA9IHR5cGUuc3R5bGVBbGlhc2VzW3N0eWxlXTtcbiAgICB9XG5cbiAgICByZXN1bHRbdGFnXSA9IHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlSGV4KGNoYXJhY3Rlcikge1xuICB2YXIgc3RyaW5nLCBoYW5kbGUsIGxlbmd0aDtcblxuICBzdHJpbmcgPSBjaGFyYWN0ZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cbiAgaWYgKGNoYXJhY3RlciA8PSAweEZGKSB7XG4gICAgaGFuZGxlID0gJ3gnO1xuICAgIGxlbmd0aCA9IDI7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRikge1xuICAgIGhhbmRsZSA9ICd1JztcbiAgICBsZW5ndGggPSA0O1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkZGRkZGKSB7XG4gICAgaGFuZGxlID0gJ1UnO1xuICAgIGxlbmd0aCA9IDg7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIFN0YXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5zY2hlbWEgICAgICAgPSBvcHRpb25zWydzY2hlbWEnXSB8fCBERUZBVUxUX0ZVTExfU0NIRU1BO1xuICB0aGlzLmluZGVudCAgICAgICA9IE1hdGgubWF4KDEsIChvcHRpb25zWydpbmRlbnQnXSB8fCAyKSk7XG4gIHRoaXMuc2tpcEludmFsaWQgID0gb3B0aW9uc1snc2tpcEludmFsaWQnXSB8fCBmYWxzZTtcbiAgdGhpcy5mbG93TGV2ZWwgICAgPSAoY29tbW9uLmlzTm90aGluZyhvcHRpb25zWydmbG93TGV2ZWwnXSkgPyAtMSA6IG9wdGlvbnNbJ2Zsb3dMZXZlbCddKTtcbiAgdGhpcy5zdHlsZU1hcCAgICAgPSBjb21waWxlU3R5bGVNYXAodGhpcy5zY2hlbWEsIG9wdGlvbnNbJ3N0eWxlcyddIHx8IG51bGwpO1xuICB0aGlzLnNvcnRLZXlzICAgICA9IG9wdGlvbnNbJ3NvcnRLZXlzJ10gfHwgZmFsc2U7XG4gIHRoaXMubGluZVdpZHRoICAgID0gb3B0aW9uc1snbGluZVdpZHRoJ10gfHwgODA7XG4gIHRoaXMubm9SZWZzICAgICAgID0gb3B0aW9uc1snbm9SZWZzJ10gfHwgZmFsc2U7XG4gIHRoaXMubm9Db21wYXRNb2RlID0gb3B0aW9uc1snbm9Db21wYXRNb2RlJ10gfHwgZmFsc2U7XG4gIHRoaXMuY29uZGVuc2VGbG93ID0gb3B0aW9uc1snY29uZGVuc2VGbG93J10gfHwgZmFsc2U7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy5leHBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdDtcblxuICB0aGlzLnRhZyA9IG51bGw7XG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgdGhpcy5kdXBsaWNhdGVzID0gW107XG4gIHRoaXMudXNlZER1cGxpY2F0ZXMgPSBudWxsO1xufVxuXG4vLyBJbmRlbnRzIGV2ZXJ5IGxpbmUgaW4gYSBzdHJpbmcuIEVtcHR5IGxpbmVzIChcXG4gb25seSkgYXJlIG5vdCBpbmRlbnRlZC5cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdHJpbmcsIHNwYWNlcykge1xuICB2YXIgaW5kID0gY29tbW9uLnJlcGVhdCgnICcsIHNwYWNlcyksXG4gICAgICBwb3NpdGlvbiA9IDAsXG4gICAgICBuZXh0ID0gLTEsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIGxpbmUsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgIG5leHQgPSBzdHJpbmcuaW5kZXhPZignXFxuJywgcG9zaXRpb24pO1xuICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbik7XG4gICAgICBwb3NpdGlvbiA9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbiwgbmV4dCArIDEpO1xuICAgICAgcG9zaXRpb24gPSBuZXh0ICsgMTtcbiAgICB9XG5cbiAgICBpZiAobGluZS5sZW5ndGggJiYgbGluZSAhPT0gJ1xcbicpIHJlc3VsdCArPSBpbmQ7XG5cbiAgICByZXN1bHQgKz0gbGluZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKSB7XG4gIHJldHVybiAnXFxuJyArIGNvbW1vbi5yZXBlYXQoJyAnLCBzdGF0ZS5pbmRlbnQgKiBsZXZlbCk7XG59XG5cbmZ1bmN0aW9uIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCB0eXBlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1tpbmRleF07XG5cbiAgICBpZiAodHlwZS5yZXNvbHZlKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWzMzXSBzLXdoaXRlIDo6PSBzLXNwYWNlIHwgcy10YWJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjKSB7XG4gIHJldHVybiBjID09PSBDSEFSX1NQQUNFIHx8IGMgPT09IENIQVJfVEFCO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYXJhY3RlciBjYW4gYmUgcHJpbnRlZCB3aXRob3V0IGVzY2FwaW5nLlxuLy8gRnJvbSBZQU1MIDEuMjogXCJhbnkgYWxsb3dlZCBjaGFyYWN0ZXJzIGtub3duIHRvIGJlIG5vbi1wcmludGFibGVcbi8vIHNob3VsZCBhbHNvIGJlIGVzY2FwZWQuIFtIb3dldmVyLF0gVGhpcyBpc27igJl0IG1hbmRhdG9yeVwiXG4vLyBEZXJpdmVkIGZyb20gbmItY2hhciAtIFxcdCAtICN4ODUgLSAjeEEwIC0gI3gyMDI4IC0gI3gyMDI5LlxuZnVuY3Rpb24gaXNQcmludGFibGUoYykge1xuICByZXR1cm4gICgweDAwMDIwIDw9IGMgJiYgYyA8PSAweDAwMDA3RSlcbiAgICAgIHx8ICgoMHgwMDBBMSA8PSBjICYmIGMgPD0gMHgwMEQ3RkYpICYmIGMgIT09IDB4MjAyOCAmJiBjICE9PSAweDIwMjkpXG4gICAgICB8fCAoKDB4MEUwMDAgPD0gYyAmJiBjIDw9IDB4MDBGRkZEKSAmJiBjICE9PSAweEZFRkYgLyogQk9NICovKVxuICAgICAgfHwgICgweDEwMDAwIDw9IGMgJiYgYyA8PSAweDEwRkZGRik7XG59XG5cbi8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYWZ0ZXIgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlKGMpIHtcbiAgLy8gVXNlcyBhIHN1YnNldCBvZiBuYi1jaGFyIC0gYy1mbG93LWluZGljYXRvciAtIFwiOlwiIC0gXCIjXCJcbiAgLy8gd2hlcmUgbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFyay5cbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IDB4RkVGRlxuICAgIC8vIC0gYy1mbG93LWluZGljYXRvclxuICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVRcbiAgICAvLyAtIFwiOlwiIC0gXCIjXCJcbiAgICAmJiBjICE9PSBDSEFSX0NPTE9OXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUDtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmVGaXJzdChjKSB7XG4gIC8vIFVzZXMgYSBzdWJzZXQgb2YgbnMtY2hhciAtIGMtaW5kaWNhdG9yXG4gIC8vIHdoZXJlIG5zLWNoYXIgPSBuYi1jaGFyIC0gcy13aGl0ZS5cbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IDB4RkVGRlxuICAgICYmICFpc1doaXRlc3BhY2UoYykgLy8gLSBzLXdoaXRlXG4gICAgLy8gLSAoYy1pbmRpY2F0b3IgOjo9XG4gICAgLy8g4oCcLeKAnSB8IOKAnD/igJ0gfCDigJw64oCdIHwg4oCcLOKAnSB8IOKAnFvigJ0gfCDigJxd4oCdIHwg4oCce+KAnSB8IOKAnH3igJ1cbiAgICAmJiBjICE9PSBDSEFSX01JTlVTXG4gICAgJiYgYyAhPT0gQ0hBUl9RVUVTVElPTlxuICAgICYmIGMgIT09IENIQVJfQ09MT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTU1BXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gICAgLy8gfCDigJwj4oCdIHwg4oCcJuKAnSB8IOKAnCrigJ0gfCDigJwh4oCdIHwg4oCcfOKAnSB8IOKAnD7igJ0gfCDigJwn4oCdIHwg4oCcXCLigJ1cbiAgICAmJiBjICE9PSBDSEFSX1NIQVJQXG4gICAgJiYgYyAhPT0gQ0hBUl9BTVBFUlNBTkRcbiAgICAmJiBjICE9PSBDSEFSX0FTVEVSSVNLXG4gICAgJiYgYyAhPT0gQ0hBUl9FWENMQU1BVElPTlxuICAgICYmIGMgIT09IENIQVJfVkVSVElDQUxfTElORVxuICAgICYmIGMgIT09IENIQVJfR1JFQVRFUl9USEFOXG4gICAgJiYgYyAhPT0gQ0hBUl9TSU5HTEVfUVVPVEVcbiAgICAmJiBjICE9PSBDSEFSX0RPVUJMRV9RVU9URVxuICAgIC8vIHwg4oCcJeKAnSB8IOKAnEDigJ0gfCDigJxg4oCdKVxuICAgICYmIGMgIT09IENIQVJfUEVSQ0VOVFxuICAgICYmIGMgIT09IENIQVJfQ09NTUVSQ0lBTF9BVFxuICAgICYmIGMgIT09IENIQVJfR1JBVkVfQUNDRU5UO1xufVxuXG52YXIgU1RZTEVfUExBSU4gICA9IDEsXG4gICAgU1RZTEVfU0lOR0xFICA9IDIsXG4gICAgU1RZTEVfTElURVJBTCA9IDMsXG4gICAgU1RZTEVfRk9MREVEICA9IDQsXG4gICAgU1RZTEVfRE9VQkxFICA9IDU7XG5cbi8vIERldGVybWluZXMgd2hpY2ggc2NhbGFyIHN0eWxlcyBhcmUgcG9zc2libGUgYW5kIHJldHVybnMgdGhlIHByZWZlcnJlZCBzdHlsZS5cbi8vIGxpbmVXaWR0aCA9IC0xID0+IG5vIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0ci5sZW5ndGggPiAwLlxuLy8gUG9zdC1jb25kaXRpb25zOlxuLy8gICAgU1RZTEVfUExBSU4gb3IgU1RZTEVfU0lOR0xFID0+IG5vIFxcbiBhcmUgaW4gdGhlIHN0cmluZy5cbi8vICAgIFNUWUxFX0xJVEVSQUwgPT4gbm8gbGluZXMgYXJlIHN1aXRhYmxlIGZvciBmb2xkaW5nIChvciBsaW5lV2lkdGggaXMgLTEpLlxuLy8gICAgU1RZTEVfRk9MREVEID0+IGEgbGluZSA+IGxpbmVXaWR0aCBhbmQgY2FuIGJlIGZvbGRlZCAoYW5kIGxpbmVXaWR0aCAhPSAtMSkuXG5mdW5jdGlvbiBjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBpbmRlbnRQZXJMZXZlbCwgbGluZVdpZHRoLCB0ZXN0QW1iaWd1b3VzVHlwZSkge1xuICB2YXIgaTtcbiAgdmFyIGNoYXI7XG4gIHZhciBoYXNMaW5lQnJlYWsgPSBmYWxzZTtcbiAgdmFyIGhhc0ZvbGRhYmxlTGluZSA9IGZhbHNlOyAvLyBvbmx5IGNoZWNrZWQgaWYgc2hvdWxkVHJhY2tXaWR0aFxuICB2YXIgc2hvdWxkVHJhY2tXaWR0aCA9IGxpbmVXaWR0aCAhPT0gLTE7XG4gIHZhciBwcmV2aW91c0xpbmVCcmVhayA9IC0xOyAvLyBjb3VudCB0aGUgZmlyc3QgbGluZSBjb3JyZWN0bHlcbiAgdmFyIHBsYWluID0gaXNQbGFpblNhZmVGaXJzdChzdHJpbmcuY2hhckNvZGVBdCgwKSlcbiAgICAgICAgICAmJiAhaXNXaGl0ZXNwYWNlKHN0cmluZy5jaGFyQ29kZUF0KHN0cmluZy5sZW5ndGggLSAxKSk7XG5cbiAgaWYgKHNpbmdsZUxpbmVPbmx5KSB7XG4gICAgLy8gQ2FzZTogbm8gYmxvY2sgc3R5bGVzLlxuICAgIC8vIENoZWNrIGZvciBkaXNhbGxvd2VkIGNoYXJhY3RlcnMgdG8gcnVsZSBvdXQgcGxhaW4gYW5kIHNpbmdsZS5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBDYXNlOiBibG9jayBzdHlsZXMgcGVybWl0dGVkLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjaGFyID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgICBoYXNMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAvLyBDaGVjayBpZiBhbnkgbGluZSBjYW4gYmUgZm9sZGVkLlxuICAgICAgICBpZiAoc2hvdWxkVHJhY2tXaWR0aCkge1xuICAgICAgICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fFxuICAgICAgICAgICAgLy8gRm9sZGFibGUgbGluZSA9IHRvbyBsb25nLCBhbmQgbm90IG1vcmUtaW5kZW50ZWQuXG4gICAgICAgICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpO1xuICAgICAgICAgIHByZXZpb3VzTGluZUJyZWFrID0gaTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhcik7XG4gICAgfVxuICAgIC8vIGluIGNhc2UgdGhlIGVuZCBpcyBtaXNzaW5nIGEgXFxuXG4gICAgaGFzRm9sZGFibGVMaW5lID0gaGFzRm9sZGFibGVMaW5lIHx8IChzaG91bGRUcmFja1dpZHRoICYmXG4gICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpKTtcbiAgfVxuICAvLyBBbHRob3VnaCBldmVyeSBzdHlsZSBjYW4gcmVwcmVzZW50IFxcbiB3aXRob3V0IGVzY2FwaW5nLCBwcmVmZXIgYmxvY2sgc3R5bGVzXG4gIC8vIGZvciBtdWx0aWxpbmUsIHNpbmNlIHRoZXkncmUgbW9yZSByZWFkYWJsZSBhbmQgdGhleSBkb24ndCBhZGQgZW1wdHkgbGluZXMuXG4gIC8vIEFsc28gcHJlZmVyIGZvbGRpbmcgYSBzdXBlci1sb25nIGxpbmUuXG4gIGlmICghaGFzTGluZUJyZWFrICYmICFoYXNGb2xkYWJsZUxpbmUpIHtcbiAgICAvLyBTdHJpbmdzIGludGVycHJldGFibGUgYXMgYW5vdGhlciB0eXBlIGhhdmUgdG8gYmUgcXVvdGVkO1xuICAgIC8vIGUuZy4gdGhlIHN0cmluZyAndHJ1ZScgdnMuIHRoZSBib29sZWFuIHRydWUuXG4gICAgcmV0dXJuIHBsYWluICYmICF0ZXN0QW1iaWd1b3VzVHlwZShzdHJpbmcpXG4gICAgICA/IFNUWUxFX1BMQUlOIDogU1RZTEVfU0lOR0xFO1xuICB9XG4gIC8vIEVkZ2UgY2FzZTogYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGNhbiBvbmx5IGhhdmUgb25lIGRpZ2l0LlxuICBpZiAoc3RyaW5nWzBdID09PSAnICcgJiYgaW5kZW50UGVyTGV2ZWwgPiA5KSB7XG4gICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgfVxuICAvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgYmxvY2sgc3R5bGVzIGFyZSB2YWxpZC5cbiAgLy8gUHJlZmVyIGxpdGVyYWwgc3R5bGUgdW5sZXNzIHdlIHdhbnQgdG8gZm9sZC5cbiAgcmV0dXJuIGhhc0ZvbGRhYmxlTGluZSA/IFNUWUxFX0ZPTERFRCA6IFNUWUxFX0xJVEVSQUw7XG59XG5cbi8vIE5vdGU6IGxpbmUgYnJlYWtpbmcvZm9sZGluZyBpcyBpbXBsZW1lbnRlZCBmb3Igb25seSB0aGUgZm9sZGVkIHN0eWxlLlxuLy8gTkIuIFdlIGRyb3AgdGhlIGxhc3QgdHJhaWxpbmcgbmV3bGluZSAoaWYgYW55KSBvZiBhIHJldHVybmVkIGJsb2NrIHNjYWxhclxuLy8gIHNpbmNlIHRoZSBkdW1wZXIgYWRkcyBpdHMgb3duIG5ld2xpbmUuIFRoaXMgYWx3YXlzIHdvcmtzOlxuLy8gICAg4oCiIE5vIGVuZGluZyBuZXdsaW5lID0+IHVuYWZmZWN0ZWQ7IGFscmVhZHkgdXNpbmcgc3RyaXAgXCItXCIgY2hvbXBpbmcuXG4vLyAgICDigKIgRW5kaW5nIG5ld2xpbmUgICAgPT4gcmVtb3ZlZCB0aGVuIHJlc3RvcmVkLlxuLy8gIEltcG9ydGFudGx5LCB0aGlzIGtlZXBzIHRoZSBcIitcIiBjaG9tcCBpbmRpY2F0b3IgZnJvbSBnYWluaW5nIGFuIGV4dHJhIGxpbmUuXG5mdW5jdGlvbiB3cml0ZVNjYWxhcihzdGF0ZSwgc3RyaW5nLCBsZXZlbCwgaXNrZXkpIHtcbiAgc3RhdGUuZHVtcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIicnXCI7XG4gICAgfVxuICAgIGlmICghc3RhdGUubm9Db21wYXRNb2RlICYmXG4gICAgICAgIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYLmluZGV4T2Yoc3RyaW5nKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBcIidcIiArIHN0cmluZyArIFwiJ1wiO1xuICAgIH1cblxuICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQgKiBNYXRoLm1heCgxLCBsZXZlbCk7IC8vIG5vIDAtaW5kZW50IHNjYWxhcnNcbiAgICAvLyBBcyBpbmRlbnRhdGlvbiBnZXRzIGRlZXBlciwgbGV0IHRoZSB3aWR0aCBkZWNyZWFzZSBtb25vdG9uaWNhbGx5XG4gICAgLy8gdG8gdGhlIGxvd2VyIGJvdW5kIG1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKS5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpbXBsaWVzXG4gICAgLy8gIHN0YXRlLmxpbmVXaWR0aCDiiaQgNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGlzIGZpeGVkIGF0IHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyAgc3RhdGUubGluZVdpZHRoID4gNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGRlY3JlYXNlcyB1bnRpbCB0aGUgbG93ZXIgYm91bmQuXG4gICAgLy8gVGhpcyBiZWhhdmVzIGJldHRlciB0aGFuIGEgY29uc3RhbnQgbWluaW11bSB3aWR0aCB3aGljaCBkaXNhbGxvd3MgbmFycm93ZXIgb3B0aW9ucyxcbiAgICAvLyBvciBhbiBpbmRlbnQgdGhyZXNob2xkIHdoaWNoIGNhdXNlcyB0aGUgd2lkdGggdG8gc3VkZGVubHkgaW5jcmVhc2UuXG4gICAgdmFyIGxpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aCA9PT0gLTFcbiAgICAgID8gLTEgOiBNYXRoLm1heChNYXRoLm1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKSwgc3RhdGUubGluZVdpZHRoIC0gaW5kZW50KTtcblxuICAgIC8vIFdpdGhvdXQga25vd2luZyBpZiBrZXlzIGFyZSBpbXBsaWNpdC9leHBsaWNpdCwgYXNzdW1lIGltcGxpY2l0IGZvciBzYWZldHkuXG4gICAgdmFyIHNpbmdsZUxpbmVPbmx5ID0gaXNrZXlcbiAgICAgIC8vIE5vIGJsb2NrIHN0eWxlcyBpbiBmbG93IG1vZGUuXG4gICAgICB8fCAoc3RhdGUuZmxvd0xldmVsID4gLTEgJiYgbGV2ZWwgPj0gc3RhdGUuZmxvd0xldmVsKTtcbiAgICBmdW5jdGlvbiB0ZXN0QW1iaWd1aXR5KHN0cmluZykge1xuICAgICAgcmV0dXJuIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyaW5nKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIHN0YXRlLmluZGVudCwgbGluZVdpZHRoLCB0ZXN0QW1iaWd1aXR5KSkge1xuICAgICAgY2FzZSBTVFlMRV9QTEFJTjpcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIGNhc2UgU1RZTEVfU0lOR0xFOlxuICAgICAgICByZXR1cm4gXCInXCIgKyBzdHJpbmcucmVwbGFjZSgvJy9nLCBcIicnXCIpICsgXCInXCI7XG4gICAgICBjYXNlIFNUWUxFX0xJVEVSQUw6XG4gICAgICAgIHJldHVybiAnfCcgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhzdHJpbmcsIGluZGVudCkpO1xuICAgICAgY2FzZSBTVFlMRV9GT0xERUQ6XG4gICAgICAgIHJldHVybiAnPicgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhmb2xkU3RyaW5nKHN0cmluZywgbGluZVdpZHRoKSwgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0RPVUJMRTpcbiAgICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpICsgJ1wiJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdpbXBvc3NpYmxlIGVycm9yOiBpbnZhbGlkIHNjYWxhciBzdHlsZScpO1xuICAgIH1cbiAgfSgpKTtcbn1cblxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0cmluZyBpcyB2YWxpZCBmb3IgYSBibG9jayBzY2FsYXIsIDEgPD0gaW5kZW50UGVyTGV2ZWwgPD0gOS5cbmZ1bmN0aW9uIGJsb2NrSGVhZGVyKHN0cmluZywgaW5kZW50UGVyTGV2ZWwpIHtcbiAgdmFyIGluZGVudEluZGljYXRvciA9IChzdHJpbmdbMF0gPT09ICcgJykgPyBTdHJpbmcoaW5kZW50UGVyTGV2ZWwpIDogJyc7XG5cbiAgLy8gbm90ZSB0aGUgc3BlY2lhbCBjYXNlOiB0aGUgc3RyaW5nICdcXG4nIGNvdW50cyBhcyBhIFwidHJhaWxpbmdcIiBlbXB0eSBsaW5lLlxuICB2YXIgY2xpcCA9ICAgICAgICAgIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuICB2YXIga2VlcCA9IGNsaXAgJiYgKHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMl0gPT09ICdcXG4nIHx8IHN0cmluZyA9PT0gJ1xcbicpO1xuICB2YXIgY2hvbXAgPSBrZWVwID8gJysnIDogKGNsaXAgPyAnJyA6ICctJyk7XG5cbiAgcmV0dXJuIGluZGVudEluZGljYXRvciArIGNob21wICsgJ1xcbic7XG59XG5cbi8vIChTZWUgdGhlIG5vdGUgZm9yIHdyaXRlU2NhbGFyLilcbmZ1bmN0aW9uIGRyb3BFbmRpbmdOZXdsaW5lKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbicgPyBzdHJpbmcuc2xpY2UoMCwgLTEpIDogc3RyaW5nO1xufVxuXG4vLyBOb3RlOiBhIGxvbmcgbGluZSB3aXRob3V0IGEgc3VpdGFibGUgYnJlYWsgcG9pbnQgd2lsbCBleGNlZWQgdGhlIHdpZHRoIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IGV2ZXJ5IGNoYXIgaW4gc3RyIGlzUHJpbnRhYmxlLCBzdHIubGVuZ3RoID4gMCwgd2lkdGggPiAwLlxuZnVuY3Rpb24gZm9sZFN0cmluZyhzdHJpbmcsIHdpZHRoKSB7XG4gIC8vIEluIGZvbGRlZCBzdHlsZSwgJGskIGNvbnNlY3V0aXZlIG5ld2xpbmVzIG91dHB1dCBhcyAkaysxJCBuZXdsaW5lc+KAlFxuICAvLyB1bmxlc3MgdGhleSdyZSBiZWZvcmUgb3IgYWZ0ZXIgYSBtb3JlLWluZGVudGVkIGxpbmUsIG9yIGF0IHRoZSB2ZXJ5XG4gIC8vIGJlZ2lubmluZyBvciBlbmQsIGluIHdoaWNoIGNhc2UgJGskIG1hcHMgdG8gJGskLlxuICAvLyBUaGVyZWZvcmUsIHBhcnNlIGVhY2ggY2h1bmsgYXMgbmV3bGluZShzKSBmb2xsb3dlZCBieSBhIGNvbnRlbnQgbGluZS5cbiAgdmFyIGxpbmVSZSA9IC8oXFxuKykoW15cXG5dKikvZztcblxuICAvLyBmaXJzdCBsaW5lIChwb3NzaWJseSBhbiBlbXB0eSBsaW5lKVxuICB2YXIgcmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dExGID0gc3RyaW5nLmluZGV4T2YoJ1xcbicpO1xuICAgIG5leHRMRiA9IG5leHRMRiAhPT0gLTEgPyBuZXh0TEYgOiBzdHJpbmcubGVuZ3RoO1xuICAgIGxpbmVSZS5sYXN0SW5kZXggPSBuZXh0TEY7XG4gICAgcmV0dXJuIGZvbGRMaW5lKHN0cmluZy5zbGljZSgwLCBuZXh0TEYpLCB3aWR0aCk7XG4gIH0oKSk7XG4gIC8vIElmIHdlIGhhdmVuJ3QgcmVhY2hlZCB0aGUgZmlyc3QgY29udGVudCBsaW5lIHlldCwgZG9uJ3QgYWRkIGFuIGV4dHJhIFxcbi5cbiAgdmFyIHByZXZNb3JlSW5kZW50ZWQgPSBzdHJpbmdbMF0gPT09ICdcXG4nIHx8IHN0cmluZ1swXSA9PT0gJyAnO1xuICB2YXIgbW9yZUluZGVudGVkO1xuXG4gIC8vIHJlc3Qgb2YgdGhlIGxpbmVzXG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IGxpbmVSZS5leGVjKHN0cmluZykpKSB7XG4gICAgdmFyIHByZWZpeCA9IG1hdGNoWzFdLCBsaW5lID0gbWF0Y2hbMl07XG4gICAgbW9yZUluZGVudGVkID0gKGxpbmVbMF0gPT09ICcgJyk7XG4gICAgcmVzdWx0ICs9IHByZWZpeFxuICAgICAgKyAoIXByZXZNb3JlSW5kZW50ZWQgJiYgIW1vcmVJbmRlbnRlZCAmJiBsaW5lICE9PSAnJ1xuICAgICAgICA/ICdcXG4nIDogJycpXG4gICAgICArIGZvbGRMaW5lKGxpbmUsIHdpZHRoKTtcbiAgICBwcmV2TW9yZUluZGVudGVkID0gbW9yZUluZGVudGVkO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR3JlZWR5IGxpbmUgYnJlYWtpbmcuXG4vLyBQaWNrcyB0aGUgbG9uZ2VzdCBsaW5lIHVuZGVyIHRoZSBsaW1pdCBlYWNoIHRpbWUsXG4vLyBvdGhlcndpc2Ugc2V0dGxlcyBmb3IgdGhlIHNob3J0ZXN0IGxpbmUgb3ZlciB0aGUgbGltaXQuXG4vLyBOQi4gTW9yZS1pbmRlbnRlZCBsaW5lcyAqY2Fubm90KiBiZSBmb2xkZWQsIGFzIHRoYXQgd291bGQgYWRkIGFuIGV4dHJhIFxcbi5cbmZ1bmN0aW9uIGZvbGRMaW5lKGxpbmUsIHdpZHRoKSB7XG4gIGlmIChsaW5lID09PSAnJyB8fCBsaW5lWzBdID09PSAnICcpIHJldHVybiBsaW5lO1xuXG4gIC8vIFNpbmNlIGEgbW9yZS1pbmRlbnRlZCBsaW5lIGFkZHMgYSBcXG4sIGJyZWFrcyBjYW4ndCBiZSBmb2xsb3dlZCBieSBhIHNwYWNlLlxuICB2YXIgYnJlYWtSZSA9IC8gW14gXS9nOyAvLyBub3RlOiB0aGUgbWF0Y2ggaW5kZXggd2lsbCBhbHdheXMgYmUgPD0gbGVuZ3RoLTIuXG4gIHZhciBtYXRjaDtcbiAgLy8gc3RhcnQgaXMgYW4gaW5jbHVzaXZlIGluZGV4LiBlbmQsIGN1cnIsIGFuZCBuZXh0IGFyZSBleGNsdXNpdmUuXG4gIHZhciBzdGFydCA9IDAsIGVuZCwgY3VyciA9IDAsIG5leHQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgLy8gSW52YXJpYW50czogMCA8PSBzdGFydCA8PSBsZW5ndGgtMS5cbiAgLy8gICAwIDw9IGN1cnIgPD0gbmV4dCA8PSBtYXgoMCwgbGVuZ3RoLTIpLiBjdXJyIC0gc3RhcnQgPD0gd2lkdGguXG4gIC8vIEluc2lkZSB0aGUgbG9vcDpcbiAgLy8gICBBIG1hdGNoIGltcGxpZXMgbGVuZ3RoID49IDIsIHNvIGN1cnIgYW5kIG5leHQgYXJlIDw9IGxlbmd0aC0yLlxuICB3aGlsZSAoKG1hdGNoID0gYnJlYWtSZS5leGVjKGxpbmUpKSkge1xuICAgIG5leHQgPSBtYXRjaC5pbmRleDtcbiAgICAvLyBtYWludGFpbiBpbnZhcmlhbnQ6IGN1cnIgLSBzdGFydCA8PSB3aWR0aFxuICAgIGlmIChuZXh0IC0gc3RhcnQgPiB3aWR0aCkge1xuICAgICAgZW5kID0gKGN1cnIgPiBzdGFydCkgPyBjdXJyIDogbmV4dDsgLy8gZGVyaXZlIGVuZCA8PSBsZW5ndGgtMlxuICAgICAgcmVzdWx0ICs9ICdcXG4nICsgbGluZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIC8vIHNraXAgdGhlIHNwYWNlIHRoYXQgd2FzIG91dHB1dCBhcyBcXG5cbiAgICAgIHN0YXJ0ID0gZW5kICsgMTsgICAgICAgICAgICAgICAgICAgIC8vIGRlcml2ZSBzdGFydCA8PSBsZW5ndGgtMVxuICAgIH1cbiAgICBjdXJyID0gbmV4dDtcbiAgfVxuXG4gIC8vIEJ5IHRoZSBpbnZhcmlhbnRzLCBzdGFydCA8PSBsZW5ndGgtMSwgc28gdGhlcmUgaXMgc29tZXRoaW5nIGxlZnQgb3Zlci5cbiAgLy8gSXQgaXMgZWl0aGVyIHRoZSB3aG9sZSBzdHJpbmcgb3IgYSBwYXJ0IHN0YXJ0aW5nIGZyb20gbm9uLXdoaXRlc3BhY2UuXG4gIHJlc3VsdCArPSAnXFxuJztcbiAgLy8gSW5zZXJ0IGEgYnJlYWsgaWYgdGhlIHJlbWFpbmRlciBpcyB0b28gbG9uZyBhbmQgdGhlcmUgaXMgYSBicmVhayBhdmFpbGFibGUuXG4gIGlmIChsaW5lLmxlbmd0aCAtIHN0YXJ0ID4gd2lkdGggJiYgY3VyciA+IHN0YXJ0KSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQsIGN1cnIpICsgJ1xcbicgKyBsaW5lLnNsaWNlKGN1cnIgKyAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LnNsaWNlKDEpOyAvLyBkcm9wIGV4dHJhIFxcbiBqb2luZXJcbn1cblxuLy8gRXNjYXBlcyBhIGRvdWJsZS1xdW90ZWQgc3RyaW5nLlxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBjaGFyLCBuZXh0Q2hhcjtcbiAgdmFyIGVzY2FwZVNlcTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAvLyBDaGVjayBmb3Igc3Vycm9nYXRlIHBhaXJzIChyZWZlcmVuY2UgVW5pY29kZSAzLjAgc2VjdGlvbiBcIjMuNyBTdXJyb2dhdGVzXCIpLlxuICAgIGlmIChjaGFyID49IDB4RDgwMCAmJiBjaGFyIDw9IDB4REJGRi8qIGhpZ2ggc3Vycm9nYXRlICovKSB7XG4gICAgICBuZXh0Q2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgIGlmIChuZXh0Q2hhciA+PSAweERDMDAgJiYgbmV4dENoYXIgPD0gMHhERkZGLyogbG93IHN1cnJvZ2F0ZSAqLykge1xuICAgICAgICAvLyBDb21iaW5lIHRoZSBzdXJyb2dhdGUgcGFpciBhbmQgc3RvcmUgaXQgZXNjYXBlZC5cbiAgICAgICAgcmVzdWx0ICs9IGVuY29kZUhleCgoY2hhciAtIDB4RDgwMCkgKiAweDQwMCArIG5leHRDaGFyIC0gMHhEQzAwICsgMHgxMDAwMCk7XG4gICAgICAgIC8vIEFkdmFuY2UgaW5kZXggb25lIGV4dHJhIHNpbmNlIHdlIGFscmVhZHkgdXNlZCB0aGF0IGNoYXIgaGVyZS5cbiAgICAgICAgaSsrOyBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXNjYXBlU2VxID0gRVNDQVBFX1NFUVVFTkNFU1tjaGFyXTtcbiAgICByZXN1bHQgKz0gIWVzY2FwZVNlcSAmJiBpc1ByaW50YWJsZShjaGFyKVxuICAgICAgPyBzdHJpbmdbaV1cbiAgICAgIDogZXNjYXBlU2VxIHx8IGVuY29kZUhleChjaGFyKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgLy8gV3JpdGUgb25seSB2YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0W2luZGV4XSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgaWYgKGluZGV4ICE9PSAwKSBfcmVzdWx0ICs9ICcsJyArICghc3RhdGUuY29uZGVuc2VGbG93ID8gJyAnIDogJycpO1xuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAnWycgKyBfcmVzdWx0ICsgJ10nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0W2luZGV4XSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGlmICghY29tcGFjdCB8fCBpbmRleCAhPT0gMCkge1xuICAgICAgICBfcmVzdWx0ICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBfcmVzdWx0ICs9ICctJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0gJztcbiAgICAgIH1cblxuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICdbXSc7IC8vIEVtcHR5IHNlcXVlbmNlIGlmIG5vIHZhbGlkIHZhbHVlcy5cbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXJCdWZmZXIgPSBzdGF0ZS5jb25kZW5zZUZsb3cgPyAnXCInIDogJyc7XG5cbiAgICBpZiAoaW5kZXggIT09IDApIHBhaXJCdWZmZXIgKz0gJywgJztcblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdEtleSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCkgcGFpckJ1ZmZlciArPSAnPyAnO1xuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wICsgKHN0YXRlLmNvbmRlbnNlRmxvdyA/ICdcIicgOiAnJykgKyAnOicgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJycgOiAnICcpO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RWYWx1ZSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAneycgKyBfcmVzdWx0ICsgJ30nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIGV4cGxpY2l0UGFpcixcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgLy8gQWxsb3cgc29ydGluZyBrZXlzIHNvIHRoYXQgdGhlIG91dHB1dCBmaWxlIGlzIGRldGVybWluaXN0aWNcbiAgaWYgKHN0YXRlLnNvcnRLZXlzID09PSB0cnVlKSB7XG4gICAgLy8gRGVmYXVsdCBzb3J0aW5nXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRlLnNvcnRLZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQ3VzdG9tIHNvcnQgZnVuY3Rpb25cbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoc3RhdGUuc29ydEtleXMpO1xuICB9IGVsc2UgaWYgKHN0YXRlLnNvcnRLZXlzKSB7XG4gICAgLy8gU29tZXRoaW5nIGlzIHdyb25nXG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ3NvcnRLZXlzIG11c3QgYmUgYSBib29sZWFuIG9yIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyQnVmZmVyID0gJyc7XG5cbiAgICBpZiAoIWNvbXBhY3QgfHwgaW5kZXggIT09IDApIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUsIHRydWUpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleS5cbiAgICB9XG5cbiAgICBleHBsaWNpdFBhaXIgPSAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB8fFxuICAgICAgICAgICAgICAgICAgIChzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCk7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFZhbHVlLCB0cnVlLCBleHBsaWNpdFBhaXIpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzonO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mICB8fCB0eXBlLnByZWRpY2F0ZSkgJiZcbiAgICAgICAgKCF0eXBlLmluc3RhbmNlT2YgfHwgKCh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JykgJiYgKG9iamVjdCBpbnN0YW5jZW9mIHR5cGUuaW5zdGFuY2VPZikpKSAmJlxuICAgICAgICAoIXR5cGUucHJlZGljYXRlICB8fCB0eXBlLnByZWRpY2F0ZShvYmplY3QpKSkge1xuXG4gICAgICBzdGF0ZS50YWcgPSBleHBsaWNpdCA/IHR5cGUudGFnIDogJz8nO1xuXG4gICAgICBpZiAodHlwZS5yZXByZXNlbnQpIHtcbiAgICAgICAgc3R5bGUgPSBzdGF0ZS5zdHlsZU1hcFt0eXBlLnRhZ10gfHwgdHlwZS5kZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHR5cGUucmVwcmVzZW50KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudChvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnJlcHJlc2VudCwgc3R5bGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50W3N0eWxlXShvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCwgaXNrZXkpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwoc3RhdGUuZHVtcCk7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSAoc3RhdGUuZmxvd0xldmVsIDwgMCB8fCBzdGF0ZS5mbG93TGV2ZWwgPiBsZXZlbCk7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8IGR1cGxpY2F0ZSB8fCAoc3RhdGUuaW5kZW50ICE9PSAyICYmIGxldmVsID4gMCkpIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZHVwbGljYXRlICYmIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgIHN0YXRlLmR1bXAgPSAnKnJlZl8nICsgZHVwbGljYXRlSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9iamVjdE9yQXJyYXkgJiYgZHVwbGljYXRlICYmICFzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICAgIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgaWYgKGJsb2NrICYmIChPYmplY3Qua2V5cyhzdGF0ZS5kdW1wKS5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIGlmIChibG9jayAmJiAoc3RhdGUuZHVtcC5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmIChzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLnNraXBJbnZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbigndW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgJyArIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHtcbiAgICAgIHN0YXRlLmR1bXAgPSAnITwnICsgc3RhdGUudGFnICsgJz4gJyArIHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZVJlZmVyZW5jZXMob2JqZWN0LCBzdGF0ZSkge1xuICB2YXIgb2JqZWN0cyA9IFtdLFxuICAgICAgZHVwbGljYXRlc0luZGV4ZXMgPSBbXSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkdXBsaWNhdGVzSW5kZXhlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgc3RhdGUuZHVwbGljYXRlcy5wdXNoKG9iamVjdHNbZHVwbGljYXRlc0luZGV4ZXNbaW5kZXhdXSk7XG4gIH1cbiAgc3RhdGUudXNlZER1cGxpY2F0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcykge1xuICB2YXIgb2JqZWN0S2V5TGlzdCxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGlmIChvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChkdXBsaWNhdGVzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgZHVwbGljYXRlc0luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtpbmRleF0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtvYmplY3RLZXlMaXN0W2luZGV4XV0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKTtcblxuICBpZiAoIXN0YXRlLm5vUmVmcykgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuXG4gIGlmICh3cml0ZU5vZGUoc3RhdGUsIDAsIGlucHV0LCB0cnVlLCB0cnVlKSkgcmV0dXJuIHN0YXRlLmR1bXAgKyAnXFxuJztcblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHNhZmVEdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkdW1wKGlucHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZHVtcCAgICAgPSBkdW1wO1xubW9kdWxlLmV4cG9ydHMuc2FmZUR1bXAgPSBzYWZlRHVtcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZHVtcGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvY3VtZW50KSB7XG4gIC8vIGhhbmRsZSBtZXRhZGF0YVxuICBjb25zdCBtZXRhZGF0YSA9IEpTT04ucGFyc2UoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W2RhdGEtbGFtbD1cIm1ldGFkYXRhXCJdJykudGV4dCk7XG4gIGlmICghbWV0YWRhdGEpIHJldHVybjtcbiAgY29uc3QgYXJ0aWNsZUluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gIGFydGljbGVJbmZvLmNsYXNzTGlzdC5hZGQoJ2FydGljbGVJbmZvJyk7XG4gIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKGFydGljbGVJbmZvLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICBjb25zdCBhcnRpY2xlVGl0bGUgPSBtZXRhZGF0YS50aXRsZTtcbiAgaWYgKGFydGljbGVUaXRsZSkge1xuICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndGl0bGUnKTtcbiAgICBpZiAodGl0bGUpIHRpdGxlLmlubmVySFRNTCA9IGFydGljbGVUaXRsZTtcbiAgICBlbHNlIHtcbiAgICAgIG5ld3RpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGl0bGUnKTtcbiAgICAgIG5ld3RpdGxlLmlubmVySFRNTCA9IGFydGljbGVUaXRsZTtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobmV3dGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcbiAgICBoZWFkaW5nLmlubmVySFRNTCA9IGFydGljbGVUaXRsZTtcbiAgICBhcnRpY2xlSW5mby5hcHBlbmRDaGlsZChoZWFkaW5nKTtcbiAgfVxuICBjb25zdCBhcnRpY2xlQXV0aG9ycyA9IG1ldGFkYXRhLmF1dGhvcnMgfHwgW107XG4gIGZvciAobGV0IGF1dGhvciBvZiBhcnRpY2xlQXV0aG9ycykge1xuICAgIGNvbnN0IG5hbWUgPSBhdXRob3IubmFtZTtcbiAgICBjb25zdCBhZGRyZXNzID0gYXV0aG9yLmFkZHJlc3M7XG4gICAgY29uc3QgYXV0aG9yUCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICBhdXRob3JQLmNsYXNzTGlzdC5hZGQoJ2F1dGhvcicpO1xuICAgIGF1dGhvclAuaW5uZXJIVE1MID0gbmFtZSArICcsICcgKyBhZGRyZXNzICsgJy4nO1xuICAgIGFydGljbGVJbmZvLmFwcGVuZENoaWxkKGF1dGhvclApO1xuICB9XG4gIGNvbnN0IGtleXdvcmRzID0gbWV0YWRhdGEua2V5d29yZHM7XG4gIGNvbnN0IGt3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICBrdy5jbGFzc0xpc3QuYWRkKCdrZXl3b3JkcycpO1xuICBrdy5pbm5lckhUTUwgPSAnS2V5d29yZHM6ICcgKyBrZXl3b3Jkcy5qb2luKCcsICcpICsgJy4nO1xuICBhcnRpY2xlSW5mby5hcHBlbmRDaGlsZChrdyk7XG5cbiAgY29uc3QgbGljZW5zaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICBsaWNlbnNpbmcuY2xhc3NMaXN0LmFkZCgnbGljZW5zZScpO1xuXG4gIGxpY2Vuc2luZy5pbm5lckhUTUwgPVxuICAgICdEZXJpdmVkIGZyb20gPGEgaHJlZj1cIicgK1xuICAgIG1ldGFkYXRhLnNvdXJjZSArXG4gICAgJ1wiPicgK1xuICAgIG1ldGFkYXRhLnNvdXJjZSArXG4gICAgJzwvYT4sICcgK1xuICAgIG1ldGFkYXRhLmxpY2Vuc2UgK1xuICAgICcgYW5kIGxpY2Vuc2VkIGFzIHN1Y2guJztcbiAgYXJ0aWNsZUluZm8uYXBwZW5kQ2hpbGQobGljZW5zaW5nKTtcbiAgcmV0dXJuIG1ldGFkYXRhO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCB7IHJlbmFtZVRhZyB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzLmpzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvY3VtZW50KXtcbiAgLy8gcHJlYW1ibGVcbiAgcmVuYW1lVGFnKGRvY3VtZW50LCdwcmVhbWJsZScsICdkaXYnLCAnaGlkZGVuJyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wcmVhbWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgeyByZW5hbWVUYWcgfSA9IHJlcXVpcmUoJy4vaGVscGVycy5qcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb2N1bWVudCl7XG4gIC8vIGFic3RyYWN0XG4gIHJlbmFtZVRhZyhkb2N1bWVudCwgJ2Fic3RyYWN0JywgJ3NlY3Rpb24nLCB0cnVlKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Fic3RyYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCB7IHJlbmFtZVRhZyB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzLmpzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvY3VtZW50KXtcbiAgICBmb3IgKGNoYXB0ZXIgb2YgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnY2hhcHRlcicpKSByZW5hbWVUYWcoZG9jdW1lbnQsICdjaGFwdGVyJywgJ3NlY3Rpb24nLCB0cnVlKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NlY3Rpb25pbmcuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IHsgcmVuYW1lVGFnIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMuanMnKTtcblxuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgcHJvb2Y6IHsgZnVsbE5hbWU6ICdQcm9vZicgfSxcbiAgdGhlb3JlbTogeyBmdWxsTmFtZTogJ1RoZW9yZW0nIH0sXG4gIHByb3Bvc2l0aW9uOiB7IGZ1bGxOYW1lOiAnUHJvcG9zaXRpb24nIH0sXG4gIGxlbW1hOiB7IGZ1bGxOYW1lOiAnTGVtbWEnIH0sXG4gIGNvcm9sbGFyeTogeyBmdWxsTmFtZTogJ0Nvcm9sbGFyeScgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb2N1bWVudCwgY29uZmlnID0gZGVmYXVsdENvbmZpZykge1xuICAvLyBjb252ZXJ0IHN0YXRlbWVudHMgdG8gc2VjdGlvblxuICBjb25zdCBzZWxlY3RvciA9IFtdO1xuICBmb3IgKGxldCBrZXkgaW4gY29uZmlnKSBzZWxlY3Rvci5wdXNoKGtleSk7XG4gIGNvbnN0IHN0YXRlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLmpvaW4oJywnKSk7XG4gIGxldCBzdGF0ZW1lbnRfY291bnRlciA9IDA7XG4gIGZvciAobGV0IHN0YXRlbWVudCBvZiBzdGF0ZW1lbnRzKSB7XG4gICAgY29uc3QgcmVuYW1lZE5vZGUgPSByZW5hbWVUYWcoZG9jdW1lbnQsIHN0YXRlbWVudCwgJ3NlY3Rpb24nLCB0cnVlKTtcbiAgICBjb25zdCBjb25maWdFbnRyeSA9IGNvbmZpZ1tzdGF0ZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICBjb25zdCBmdWxsTmFtZSA9IGNvbmZpZ0VudHJ5LmZ1bGxOYW1lO1xuICAgIHJlbmFtZWROb2RlLmNsYXNzTGlzdC5hZGQoJ3N0YXRlbWVudCcpO1xuICAgIHJlbmFtZWROb2RlLmNsYXNzTGlzdC5hZGQoXG4gICAgICBjb25maWdFbnRyeS5jbGFzc05hbWUgfHwgJ3N0YXRlbWVudF9fJyArIGZ1bGxOYW1lLnRvTG93ZXJDYXNlKClcbiAgICApO1xuICAgIGNvbnN0IG5hbWUgPSByZW5hbWVkTm9kZS5xdWVyeVNlbGVjdG9yKCduYW1lJyk7XG4gICAgLy8gVE9ETyBtYXliZSBuYW1lIGhhbmRsaW5nIGlzIG1vcmUgbGlrZSBhIGhlbHBlciB0aGF0IHNob3VsZCBiZSByZXF1aXJlZCBhbmQgYXBwbGllZCBoZXJlP1xuICAgIGlmIChuYW1lKSBjb250aW51ZTtcbiAgICBzdGF0ZW1lbnRfY291bnRlcisrO1xuICAgIC8vIFRPRE8gbG9vayB1cCBjb3JyZWN0IGhlYWRpbmcgbGV2ZWxcbiAgICBjb25zdCBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICBoZWFkaW5nLmNsYXNzTGlzdC5hZGQoJ25hbWUnKTtcbiAgICBoZWFkaW5nLmlkID0gZnVsbE5hbWUudG9Mb3dlckNhc2UoKSArICctJyArIHN0YXRlbWVudF9jb3VudGVyO1xuICAgIGhlYWRpbmcuaW5uZXJIVE1MID0gZnVsbE5hbWUgKyAnICcgKyBzdGF0ZW1lbnRfY291bnRlcjtcbiAgICByZW5hbWVkTm9kZS5pbnNlcnRCZWZvcmUoaGVhZGluZywgcmVuYW1lZE5vZGUuZmlyc3RDaGlsZCk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zdGF0ZW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvY3VtZW50LCBiZWxvd09yQWJvdmUpIHtcbiAgLy8gaGFuZGxlIGZpZ3VyZXNcbiAgY29uc3QgZmlndXJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2ZpZ3VyZScpO1xuICBmb3IgKGxldCBbaW5kZXgsIGZpZ3VyZV0gb2YgZmlndXJlcy5lbnRyaWVzKCkpIHtcbiAgICBmaWd1cmUuY2xhc3NMaXN0LmFkZCgnZmlndXJlJyk7XG4gICAgY29uc3QgbmFtZSA9IGZpZ3VyZS5xdWVyeVNlbGVjdG9yKCduYW1lJyk7XG4gICAgaWYgKG5hbWUpIGNvbnRpbnVlO1xuICAgIC8vIFRPRE8gbG9vayB1cCBjb3JyZWN0IGhlYWRpbmcgbGV2ZWxcbiAgICBjb25zdCBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICBoZWFkaW5nLmNsYXNzTGlzdC5hZGQoJ25hbWUnKTtcbiAgICBoZWFkaW5nLmlubmVySFRNTCA9ICdGaWd1cmUgJyArIChpbmRleCArIDEpO1xuICAgIGlmIChiZWxvd09yQWJvdmUpIGZpZ3VyZS5pbnNlcnRCZWZvcmUoaGVhZGluZywgZmlndXJlLmNoaWxkcmVuWzFdKTtcbiAgICBlbHNlIGZpZ3VyZS5pbnNlcnRCZWZvcmUoaGVhZGluZywgZmlndXJlLmZpcnN0Q2hpbGQpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZmlndXJlcy5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgeyByZW5hbWVUYWcgfSA9IHJlcXVpcmUoJy4vaGVscGVycy5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvY3VtZW50KSB7XG4gIC8vIGNvbnZlcnQgbmFtZXMgdG8gaGVhZGluZ3NcbiAgY29uc3QgbmFtZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCduYW1lJyk7XG4gIGZvciAobGV0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAvLyBUT0RPIGxvb2sgdXAgY29ycmVjdCBoZWFkaW5nIGxldmVsXG4gICAgY29uc3QgcmVuYW1lZE5vZGUgPSByZW5hbWVUYWcoZG9jdW1lbnQsIG5hbWUsICdoMicsIHRydWUpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbmFtZXMuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IHsgcmVuYW1lVGFnIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb2N1bWVudCkge1xuICAvLyBjb252ZXJ0IGJsYW1lcyB0byBoZWFkaW5nc1xuICBjb25zdCBibGFtZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdibGFtZScpO1xuICBmb3IgKGxldCBibGFtZSBvZiBibGFtZXMpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IGJsYW1lLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgaWYgKHByZXZpb3VzICYmIChwcmV2aW91cy5jbGFzc0xpc3QuY29udGFpbnMoJ25hbWUnKSB8fCBwcmV2aW91cy50YWdOYW1lID09PSAnTkFNRScpKSB7XG4gICAgICBjb25zdCByZW5hbWVkTm9kZSA9IHJlbmFtZVRhZyhkb2N1bWVudCwgYmxhbWUsICdzcGFuJywgdHJ1ZSk7XG4gICAgICBwcmV2aW91cy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpKTtcbiAgICAgIHByZXZpb3VzLmFwcGVuZENoaWxkKHJlbmFtZWROb2RlKTtcbiAgICB9XG4gICAgLy8gVE9ETyBsb29rIHVwIGNvcnJlY3QgaGVhZGluZyBsZXZlbFxuICAgIGVsc2Uge2NvbnN0IHJlbmFtZWROb2RlID0gcmVuYW1lVGFnKGRvY3VtZW50LCBibGFtZSwgJ2gyJywgdHJ1ZSk7fVxuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYmxhbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCB7IHJlbmFtZVRhZyB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9jdW1lbnQpIHtcbiAgLy8gY29udmVydCByZWYgdG8gbGlua3NcbiAgY29uc3QgcmVmcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3JlZicpO1xuICBmb3IgKGxldCByZWYgb2YgcmVmcykge1xuICAgIGNvbnN0IHJlbmFtZWROb2RlID0gcmVuYW1lVGFnKGRvY3VtZW50LCByZWYsICdhJyk7XG4gICAgY29uc3QgdGFyZ2V0SWQgPSByZW5hbWVkTm9kZS5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgIHJlbmFtZWROb2RlLmNsYXNzTGlzdC5hZGQoJ3JlZicpO1xuICAgIHJlbmFtZWROb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyArIHRhcmdldElkKTtcbiAgICByZW5hbWVkTm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgIGlmICghL15cXHMqJC8udGVzdChyZW5hbWVkTm9kZS5pbm5lckhUTUwpKSB7XG4gICAgICAvLyB0aGUgbm9kZSBoYXMgc29tZSBub250cml2aWFsIGNvbnRlbnRzXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gdGhlIG5vZGUgaXMgd2hpdGVzcGFjZS4gcmVwbGFjZSBpdCB3aXRoIG91ciBkZWZhdWx0cy5cbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXRJZCk7XG4gICAgbGV0IHJlZlRleHQgPVxuICAgICAgJzxzcGFuIHN0eWxlPVwiY29sb3I6cmVkOyBiYWNrZ3JvdW5kLWNvbG9yOnllbGxvdzsgYm9yZGVyOiAxcHggc29saWQgcmVkXCI+RVJST1I6IFRBUkdFVCBOT1QgRk9VTkQ8L3NwYW4+JztcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5xdWVyeVNlbGVjdG9yKCdoMSwgaDIsIGgzLCBoNCwgaDUsIGg2JykpIHtcbiAgICAgIGNvbnN0IHRhcmdldEhlYWRpbmcgPSB0YXJnZXQucXVlcnlTZWxlY3RvcignaDEsIGgyLCBoMywgaDQsIGg1LCBoNicpO1xuICAgICAgaWYgKHRhcmdldEhlYWRpbmcpIHtcbiAgICAgICAgY2xvbmVkSGVhZGluZyA9IHRhcmdldEhlYWRpbmcuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAvLyBzdHJpcCBibGFtZVxuICAgICAgICBpZiAodGFyZ2V0SGVhZGluZy5xdWVyeVNlbGVjdG9yKCcuYmxhbWUnKSlcbiAgICAgICAgICB0YXJnZXRIZWFkaW5nLnJlbW92ZUNoaWxkKHRhcmdldEhlYWRpbmcucXVlcnlTZWxlY3RvcignLmJsYW1lJykpO1xuICAgICAgICByZWZUZXh0ID0gY2xvbmVkSGVhZGluZy5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKHJlZiwgJ1RhcmdldCBoYXMgbm8gaGVhZGluZycpO1xuICAgICAgICByZWZUZXh0ID1cbiAgICAgICAgICAnPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7IGJhY2tncm91bmQtY29sb3I6eWVsbG93OyBib3JkZXI6IDFweCBzb2xpZCByZWRcIj5FUlJPUjogVEFSR0VUIEhBUyBOTyBIRUFESU5HPC9zcGFuPic7XG4gICAgICB9XG4gICAgfSBlbHNlIGNvbnNvbGUuZXJyb3IocmVmLCAnVGFyZ2V0IG5vdCBmb3VuZCcpO1xuICAgIHJlbmFtZWROb2RlLmlubmVySFRNTCA9IHJlZlRleHQ7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9yZWZzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvY3VtZW50KSB7XG4gIC8vIHBvcHVsYXRlIGJpYmxpb2dyYXBoaWMgY2l0YXRpb25zXG4gIGNvbnN0IGJpYml0ZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYmlibGlvZ3JhcGh5IGEnKTtcbiAgZm9yIChsZXQgW2luZGV4LCBiaWJpdGVtXSBvZiBiaWJpdGVtcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBjb3VudGVyID0gJ1snICsgKGluZGV4ICsgMSkgKyAnXSc7XG4gICAgLy8gVE9ETyBjcmVhdGUgREwgaW4gYnVpbGRCaWIgaW5zdGVhZFxuICAgIGNvbnN0IGNvdW50ZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY291bnRlciArICcgJyk7XG4gICAgYmliaXRlbS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjb3VudGVyTm9kZSwgYmliaXRlbSk7XG4gICAgY29uc3QgY2l0ZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgJ2NpdGVbdGFyZ2V0PVwiJyArIGJpYml0ZW0uaWQgKyAnXCJdJ1xuICAgICk7XG4gICAgZm9yIChsZXQgY2l0ZSBvZiBjaXRlcykge1xuICAgICAgaWYgKCAvXlxccyokLy50ZXN0KGNpdGUuaW5uZXJIVE1MKSApIHtcbiAgICAgICAgLy8gdGhlIG5vZGUgaXMgd2hpdGVzcGFjZSwgcmVwbGFjZSBpdCB3aXRoIG91ciBkZWZhdWx0c1xuICAgICAgICBjaXRlLmlubmVySFRNTCA9IGNvdW50ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsZWF2ZSBpdCBhbG9uZVxuICAgICAgfVxuICAgICAgY29uc3QgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyArIGJpYml0ZW0uaWQpO1xuICAgICAgY2l0ZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChhbmNob3IsIGNpdGUpO1xuICAgICAgYW5jaG9yLmFwcGVuZENoaWxkKGNpdGUpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY2l0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IHsgcmVuYW1lVGFnIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb2N1bWVudCkge1xuICAvLyBoYW5kbGUgKGZvb3Qpbm90ZXNcbiAgY29uc3Qgbm90ZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdub3RlJyk7XG4gIGZvciAobGV0IFtpbmRleCwgbm90ZV0gb2Ygbm90ZXMuZW50cmllcygpKSB7XG4gICAgY29uc3QgbmV3Tm90ZSA9IHJlbmFtZVRhZyhkb2N1bWVudCwgbm90ZSwgJ3NwYW4nKTtcbiAgICBuZXdOb3RlLmNsYXNzTGlzdC5hZGQoJ2Zvb3Rub3RlJyk7XG4gICAgbmV3Tm90ZS5pZCA9ICdmbi0nICsgaW5kZXg7XG4gICAgY29uc3QgZm5saW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGZubGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBuZXdOb3RlLmlkKTtcbiAgICBmbmxpbmsuaWQgPSAnZm5saW5rJyArIGluZGV4O1xuICAgIGZubGluay5pbm5lckhUTUwgPSAnPHN1cD4nICsgKGluZGV4ICsgMSkgKyAnPC9zdXA+JztcbiAgICBuZXdOb3RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGZubGluaywgbmV3Tm90ZSk7XG4gICAgY29uc3QgYmFja2xpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYmFja2xpbmsuc2V0QXR0cmlidXRlKCdocmVmJywgJyMnICsgZm5saW5rLmlkKTtcbiAgICBiYWNrbGluay5pbm5lckhUTUwgPSAnPHN1cD7wn5SZPC9zdXA+JztcbiAgICBiYWNrbGluay5jbGFzc0xpc3QuYWRkKCdiYWNrbGluaycpO1xuICAgIG5ld05vdGUuYXBwZW5kQ2hpbGQoYmFja2xpbmspO1xuICAgIC8vIFRPRE8gdGhpcyBpcyBub3QgYWN0dWFsbHkgZGlzYWJsaW5nIGNsaWNrc1xuICAgIGZubGluay5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2NsaWNrJyxcbiAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGJhY2tsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnY2xpY2snLFxuICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9ub3Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgeyByZW5hbWVUYWcgfSA9IHJlcXVpcmUoJy4vaGVscGVycy5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvY3VtZW50KSB7XG4gIGNvbnN0IGJpYiA9IHJlbmFtZVRhZyhkb2N1bWVudCwgJ2JpYmxpb2dyYXBoeScsICdzZWN0aW9uJywgdHJ1ZSk7XG4gIGNvbnN0IGhlYWRpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpO1xuICBoZWFkaW5nLmlubmVySFRNTCA9ICdCaWJsaW9ncmFwaHknO1xuICBiaWIuaW5zZXJ0QmVmb3JlKGhlYWRpbmcsIGJpYi5maXJzdENoaWxkKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9iaWJsaW9ncmFwaHkuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIE1hdGhKYXggQ29uc29ydGl1bVxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIHRleDJqYXggPSBmdW5jdGlvbiAoKSB7fTtcblxudGV4MmpheC5wcm90b3R5cGUuY29uZmlnID0ge1xuICAgIGRvYzoge30sXG4gICAgaW5saW5lTWF0aDogWyAvLyBUaGUgc3RhcnQvc3RvcCBwYWlycyBmb3IgaW4tbGluZSBtYXRoXG4gICAgICAgIC8vICAgIFsnJCcsJyQnXSwgICAgICAgICAgICAgICAvLyAgKGNvbW1lbnQgb3V0IGFueSB5b3UgZG9uJ3Qgd2FudCwgb3IgYWRkIHlvdXIgb3duLCBidXRcbiAgICAgICAgWydcXFxcKCcsICdcXFxcKSddIC8vICBiZSBzdXJlIHRoYXQgeW91IGRvbid0IGhhdmUgYW4gZXh0cmEgY29tbWEgYXQgdGhlIGVuZClcbiAgICBdLFxuXG4gICAgZGlzcGxheU1hdGg6IFsgLy8gVGhlIHN0YXJ0L3N0b3AgcGFpcnMgZm9yIGRpc3BsYXkgbWF0aFxuICAgICAgICBbJyQkJywgJyQkJ10sIC8vICAoY29tbWVudCBvdXQgYW55IHlvdSBkb24ndCB3YW50LCBvciBhZGQgeW91ciBvd24sIGJ1dFxuICAgICAgICBbJ1xcXFxbJywgJ1xcXFxdJ10gLy8gIGJlIHN1cmUgdGhhdCB5b3UgZG9uJ3QgaGF2ZSBhbiBleHRyYSBjb21tYSBhdCB0aGUgZW5kKVxuICAgIF0sXG5cbiAgICBiYWxhbmNlQnJhY2VzOiB0cnVlLCAvLyBkZXRlcm1pbmVzIHdoZXRoZXIgdGV4MmpheCByZXF1aXJlcyBicmFjZXMgdG8gYmVcbiAgICAvLyBiYWxhbmNlZCB3aXRoaW4gbWF0aCBkZWxpbWl0ZXJzIChhbGxvd3MgZm9yIG5lc3RlZFxuICAgIC8vIGRvbGxhciBzaWducykuICBTZXQgdG8gZmFsc2UgdG8gZ2V0IHByZS12Mi4wIGNvbXBhdGliaWxpdHkuXG5cbiAgICBza2lwVGFnczogW1wic2NyaXB0XCIsIFwibm9zY3JpcHRcIiwgXCJzdHlsZVwiLCBcInRleHRhcmVhXCIsIFwicHJlXCIsIFwiY29kZVwiLCBcImFubm90YXRpb25cIiwgXCJhbm5vdGF0aW9uLXhtbFwiXSxcbiAgICAvLyBUaGUgbmFtZXMgb2YgdGhlIHRhZ3Mgd2hvc2UgY29udGVudHMgd2lsbCBub3QgYmVcbiAgICAvLyBzY2FubmVkIGZvciBtYXRoIGRlbGltaXRlcnNcblxuICAgIGlnbm9yZUNsYXNzOiBcInRleDJqYXhfaWdub3JlXCIsIC8vIHRoZSBjbGFzcyBuYW1lIG9mIGVsZW1lbnRzIHdob3NlIGNvbnRlbnRzIHNob3VsZFxuICAgIC8vIE5PVCBiZSBwcm9jZXNzZWQgYnkgdGV4MmpheC4gIE5vdGUgdGhhdCB0aGlzXG4gICAgLy8gaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIHNvIGJlIHN1cmUgdG8gcXVvdGUgYW55XG4gICAgLy8gcmVnZXhwIHNwZWNpYWwgY2hhcmFjdGVyc1xuXG4gICAgcHJvY2Vzc0NsYXNzOiBcInRleDJqYXhfcHJvY2Vzc1wiLCAvLyB0aGUgY2xhc3MgbmFtZSBvZiBlbGVtZW50cyB3aG9zZSBjb250ZW50cyBTSE9VTERcbiAgICAvLyBiZSBwcm9jZXNzZWQgd2hlbiB0aGV5IGFwcGVhciBpbnNpZGUgb25lcyB0aGF0XG4gICAgLy8gYXJlIGlnbm9yZWQuICBOb3RlIHRoYXQgdGhpcyBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbixcbiAgICAvLyBzbyBiZSBzdXJlIHRvIHF1b3RlIGFueSByZWdleHAgc3BlY2lhbCBjaGFyYWN0ZXJzXG5cbiAgICBwcm9jZXNzRXNjYXBlczogZmFsc2UsIC8vIHNldCB0byB0cnVlIHRvIGFsbG93IFxcJCB0byBwcm9kdWNlIGEgZG9sbGFyIHdpdGhvdXRcbiAgICAvLyAgIHN0YXJ0aW5nIGluLWxpbmUgbWF0aCBtb2RlXG5cbiAgICBwcm9jZXNzRW52aXJvbm1lbnRzOiB0cnVlLCAvLyBzZXQgdG8gdHJ1ZSB0byBwcm9jZXNzIFxcYmVnaW57eHh4fS4uLlxcZW5ke3h4eH0gb3V0c2lkZVxuICAgIC8vICAgb2YgbWF0aCBtb2RlLCBmYWxzZSB0byBwcmV2ZW50IHRoYXRcblxuICAgIHByb2Nlc3NSZWZzOiB0cnVlLCAvLyBzZXQgdG8gdHJ1ZSB0byBwcm9jZXNzIFxccmVmey4uLn0gb3V0c2lkZSBvZiBtYXRoIG1vZGVcblxufTtcblxudGV4MmpheC5wcm90b3R5cGUuUHJlUHJvY2VzcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKHR5cGVvZiAoZWxlbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZWxlbWVudCA9IHRoaXMuY29uZmlnLmRvYy5nZXRFbGVtZW50QnlJZChlbGVtZW50KVxuICAgIH1cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudCA9IHRoaXMuY29uZmlnLmRvYy5ib2R5XG4gICAgfVxuICAgIGlmICh0aGlzLmNyZWF0ZVBhdHRlcm5zKCkpIHtcbiAgICAgICAgdGhpcy5zY2FuRWxlbWVudChlbGVtZW50LCBlbGVtZW50Lm5leHRTaWJsaW5nKVxuICAgIH1cbn07XG5cbnRleDJqYXgucHJvdG90eXBlLmNyZWF0ZVBhdHRlcm5zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFydHMgPSBbXSxcbiAgICAgICAgcGFydHMgPSBbXSxcbiAgICAgICAgaSwgbSwgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgdGhpcy5tYXRjaCA9IHt9O1xuICAgIGZvciAoaSA9IDAsIG0gPSBjb25maWcuaW5saW5lTWF0aC5sZW5ndGg7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgc3RhcnRzLnB1c2godGhpcy5wYXR0ZXJuUXVvdGUoY29uZmlnLmlubGluZU1hdGhbaV1bMF0pKTtcbiAgICAgICAgdGhpcy5tYXRjaFtjb25maWcuaW5saW5lTWF0aFtpXVswXV0gPSB7XG4gICAgICAgICAgICBtb2RlOiBcInRleFwiLFxuICAgICAgICAgICAgZW5kOiBjb25maWcuaW5saW5lTWF0aFtpXVsxXSxcbiAgICAgICAgICAgIHBhdHRlcm46IHRoaXMuZW5kUGF0dGVybihjb25maWcuaW5saW5lTWF0aFtpXVsxXSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgbSA9IGNvbmZpZy5kaXNwbGF5TWF0aC5sZW5ndGg7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgc3RhcnRzLnB1c2godGhpcy5wYXR0ZXJuUXVvdGUoY29uZmlnLmRpc3BsYXlNYXRoW2ldWzBdKSk7XG4gICAgICAgIHRoaXMubWF0Y2hbY29uZmlnLmRpc3BsYXlNYXRoW2ldWzBdXSA9IHtcbiAgICAgICAgICAgIG1vZGU6IFwidGV4OyBtb2RlPWRpc3BsYXlcIixcbiAgICAgICAgICAgIGVuZDogY29uZmlnLmRpc3BsYXlNYXRoW2ldWzFdLFxuICAgICAgICAgICAgcGF0dGVybjogdGhpcy5lbmRQYXR0ZXJuKGNvbmZpZy5kaXNwbGF5TWF0aFtpXVsxXSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChzdGFydHMuc29ydCh0aGlzLnNvcnRMZW5ndGgpLmpvaW4oXCJ8XCIpKVxuICAgIH1cbiAgICBpZiAoY29uZmlnLnByb2Nlc3NFbnZpcm9ubWVudHMpIHtcbiAgICAgICAgcGFydHMucHVzaChcIlxcXFxcXFxcYmVnaW5cXFxceyhbXn1dKilcXFxcfVwiKVxuICAgIH1cbiAgICBpZiAoY29uZmlnLnByb2Nlc3NFc2NhcGVzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJcXFxcXFxcXCpcXFxcXFxcXFxcXFxcXCRcIilcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5wcm9jZXNzUmVmcykge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiXFxcXFxcXFwoZXEpP3JlZlxcXFx7W159XSpcXFxcfVwiKVxuICAgIH1cbiAgICB0aGlzLnN0YXJ0ID0gbmV3IFJlZ0V4cChwYXJ0cy5qb2luKFwifFwiKSwgXCJnXCIpO1xuICAgIHRoaXMuc2tpcFRhZ3MgPSBuZXcgUmVnRXhwKFwiXihcIiArIGNvbmZpZy5za2lwVGFncy5qb2luKFwifFwiKSArIFwiKSRcIiwgXCJpXCIpO1xuICAgIHZhciBpZ25vcmUgPSBbXTtcbiAgICBpZiAodGhpcy5jb25maWcucHJlUmVtb3ZlQ2xhc3MpIHtcbiAgICAgICAgaWdub3JlLnB1c2godGhpcy5jb25maWcucHJlUmVtb3ZlQ2xhc3MpXG4gICAgfTtcbiAgICBpZiAoY29uZmlnLmlnbm9yZUNsYXNzKSB7XG4gICAgICAgIGlnbm9yZS5wdXNoKGNvbmZpZy5pZ25vcmVDbGFzcylcbiAgICB9XG4gICAgdGhpcy5pZ25vcmVDbGFzcyA9IChpZ25vcmUubGVuZ3RoID8gbmV3IFJlZ0V4cChcIihefCApKFwiICsgaWdub3JlLmpvaW4oXCJ8XCIpICsgXCIpKCB8JClcIikgOiAvXiQvKTtcbiAgICB0aGlzLnByb2Nlc3NDbGFzcyA9IG5ldyBSZWdFeHAoXCIoXnwgKShcIiArIGNvbmZpZy5wcm9jZXNzQ2xhc3MgKyBcIikoIHwkKVwiKTtcbiAgICByZXR1cm4gKHBhcnRzLmxlbmd0aCA+IDApO1xufTtcblxudGV4MmpheC5wcm90b3R5cGUucGF0dGVyblF1b3RlID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC8oW1xcXiQoKXt9Kyo/XFwtfFxcW1xcXVxcOlxcXFxdKS9nLCAnXFxcXCQxJylcbn07XG5cbnRleDJqYXgucHJvdG90eXBlLmVuZFBhdHRlcm4gPSBmdW5jdGlvbiAoZW5kKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAodGhpcy5wYXR0ZXJuUXVvdGUoZW5kKSArIFwifFxcXFxcXFxcLnxbe31dXCIsIFwiZ1wiKTtcbn07XG5cbnRleDJqYXgucHJvdG90eXBlLnNvcnRMZW5ndGggPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIChhID09IGIgPyAwIDogKGEgPCBiID8gLTEgOiAxKSk7XG59O1xuXG50ZXgyamF4LnByb3RvdHlwZS5zY2FuRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdG9wLCBpZ25vcmUpIHtcbiAgICB2YXIgY25hbWUsIHRuYW1lLCBpZ25vcmVDaGlsZCwgcHJvY2VzcztcbiAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50ICE9IHN0b3ApIHtcbiAgICAgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJyN0ZXh0Jykge1xuICAgICAgICAgICAgaWYgKCFpZ25vcmUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5zY2FuVGV4dChlbGVtZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY25hbWUgPSAodHlwZW9mIChlbGVtZW50LmNsYXNzTmFtZSkgPT09IFwidW5kZWZpbmVkXCIgPyBcIlwiIDogZWxlbWVudC5jbGFzc05hbWUpO1xuICAgICAgICAgICAgdG5hbWUgPSAodHlwZW9mIChlbGVtZW50LnRhZ05hbWUpID09PSBcInVuZGVmaW5lZFwiID8gXCJcIiA6IGVsZW1lbnQudGFnTmFtZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjbmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjbmFtZSA9IFN0cmluZyhjbmFtZSlcbiAgICAgICAgICAgIH0gLy8ganN4Z3JhcGggdXNlcyBub24tc3RyaW5nIGNsYXNzIG5hbWVzIVxuICAgICAgICAgICAgcHJvY2VzcyA9IHRoaXMucHJvY2Vzc0NsYXNzLmV4ZWMoY25hbWUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuZmlyc3RDaGlsZCAmJiAhY25hbWUubWF0Y2goLyhefCApTWF0aEpheC8pICYmXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MgfHwgIXRoaXMuc2tpcFRhZ3MuZXhlYyh0bmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgaWdub3JlQ2hpbGQgPSAoaWdub3JlIHx8IHRoaXMuaWdub3JlQ2xhc3MuZXhlYyhjbmFtZSkpICYmICFwcm9jZXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbkVsZW1lbnQoZWxlbWVudC5maXJzdENoaWxkLCBzdG9wLCBpZ25vcmVDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHRTaWJsaW5nXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG50ZXgyamF4LnByb3RvdHlwZS5zY2FuVGV4dCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZVZhbHVlLnJlcGxhY2UoL1xccysvLCAnJykgPT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICB9XG4gICAgdmFyIG1hdGNoLCBwcmV2O1xuICAgIHRoaXMuc2VhcmNoID0ge1xuICAgICAgICBzdGFydDogdHJ1ZVxuICAgIH07XG4gICAgdGhpcy5wYXR0ZXJuID0gdGhpcy5zdGFydDtcbiAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnI3RleHQnICYmXG4gICAgICAgICAgICAobWF0Y2ggPSB0aGlzLnBhdHRlcm4uZXhlYyhlbGVtZW50Lm5vZGVWYWx1ZSkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWFyY2guc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5zdGFydE1hdGNoKG1hdGNoLCBlbGVtZW50KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5lbmRNYXRjaChtYXRjaCwgZWxlbWVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWFyY2gubWF0Y2hlZCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuZW5jbG9zZU1hdGgoZWxlbWVudClcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHByZXYgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHRTaWJsaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYnInIHx8XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJyNjb21tZW50JykpO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZU5hbWUgIT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuc2VhcmNoLmNsb3NlID8gdGhpcy5wcmV2RW5kTWF0Y2goKSA6IHByZXYpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG50ZXgyamF4LnByb3RvdHlwZS5zdGFydE1hdGNoID0gZnVuY3Rpb24gKG1hdGNoLCBlbGVtZW50KSB7XG4gICAgdmFyIGRlbGltID0gdGhpcy5tYXRjaFttYXRjaFswXV07XG4gICAgaWYgKGRlbGltICE9IG51bGwpIHsgLy8gYSBzdGFydCBkZWxpbWl0ZXJcbiAgICAgICAgdGhpcy5zZWFyY2ggPSB7XG4gICAgICAgICAgICBlbmQ6IGRlbGltLmVuZCxcbiAgICAgICAgICAgIG1vZGU6IGRlbGltLm1vZGUsXG4gICAgICAgICAgICBwY291bnQ6IDAsXG4gICAgICAgICAgICBvcGVuOiBlbGVtZW50LFxuICAgICAgICAgICAgb2xlbjogbWF0Y2hbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgb3BvczogdGhpcy5wYXR0ZXJuLmxhc3RJbmRleCAtIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN3aXRjaFBhdHRlcm4oZGVsaW0ucGF0dGVybik7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXS5zdWJzdHIoMCwgNikgPT09IFwiXFxcXGJlZ2luXCIpIHsgLy8gXFxiZWdpbnsuLi59XG4gICAgICAgIHRoaXMuc2VhcmNoID0ge1xuICAgICAgICAgICAgZW5kOiBcIlxcXFxlbmR7XCIgKyBtYXRjaFsxXSArIFwifVwiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXg7IG1vZGU9ZGlzcGxheVwiLFxuICAgICAgICAgICAgcGNvdW50OiAwLFxuICAgICAgICAgICAgb3BlbjogZWxlbWVudCxcbiAgICAgICAgICAgIG9sZW46IDAsXG4gICAgICAgICAgICBvcG9zOiB0aGlzLnBhdHRlcm4ubGFzdEluZGV4IC0gbWF0Y2hbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgaXNCZWdpbkVuZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN3aXRjaFBhdHRlcm4odGhpcy5lbmRQYXR0ZXJuKHRoaXMuc2VhcmNoLmVuZCkpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0uc3Vic3RyKDAsIDQpID09PSBcIlxcXFxyZWZcIiB8fCBtYXRjaFswXS5zdWJzdHIoMCwgNikgPT09IFwiXFxcXGVxcmVmXCIpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSB7XG4gICAgICAgICAgICBtb2RlOiBcIlwiLFxuICAgICAgICAgICAgZW5kOiBcIlwiLFxuICAgICAgICAgICAgb3BlbjogZWxlbWVudCxcbiAgICAgICAgICAgIHBjb3VudDogMCxcbiAgICAgICAgICAgIG9sZW46IDAsXG4gICAgICAgICAgICBvcG9zOiB0aGlzLnBhdHRlcm4ubGFzdEluZGV4IC0gbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kTWF0Y2goW1wiXCJdLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgeyAvLyBlc2NhcGVkIGRvbGxhciBzaWduc1xuICAgICAgICAvLyBwdXQgJCBpbiBhIHNwYW4gc28gaXQgZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGFnYWluXG4gICAgICAgIC8vIHNwbGl0IG9mZiBiYWNrc2xhc2hlcyBzbyB0aGV5IGRvbid0IGdldCByZW1vdmVkIGxhdGVyXG4gICAgICAgIHZhciBzbGFzaGVzID0gbWF0Y2hbMF0uc3Vic3RyKDAsIG1hdGNoWzBdLmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgbiwgc3BhbjtcbiAgICAgICAgaWYgKHNsYXNoZXMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgc3BhbiA9IFtzbGFzaGVzLnJlcGxhY2UoL1xcXFxcXFxcL2csIFwiXFxcXFwiKV07XG4gICAgICAgICAgICBuID0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BhbiA9IFtzbGFzaGVzLnN1YnN0cigxKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIiksIFwiJFwiXTtcbiAgICAgICAgICAgIG4gPSAwXG4gICAgICAgIH1cbiAgICAgICAgZXNjYXBlZCA9IHRoaXMuY29uZmlnLmRvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgZXNjYXBlZC5pbm5lckhUTUwgPSBzcGFuLmpvaW4oJycpO1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuY29uZmlnLmRvYy5jcmVhdGVUZXh0Tm9kZShlbGVtZW50Lm5vZGVWYWx1ZS5zdWJzdHIoMCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgZWxlbWVudC5ub2RlVmFsdWUgPSBlbGVtZW50Lm5vZGVWYWx1ZS5zdWJzdHIobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggLSBuKTtcbiAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlc2NhcGVkLCBlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0ZXh0LCBlc2NhcGVkKTtcbiAgICAgICAgdGhpcy5wYXR0ZXJuLmxhc3RJbmRleCA9IG47XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufTtcblxudGV4MmpheC5wcm90b3R5cGUuZW5kTWF0Y2ggPSBmdW5jdGlvbiAobWF0Y2gsIGVsZW1lbnQpIHtcbiAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2g7XG4gICAgaWYgKG1hdGNoWzBdID09IHNlYXJjaC5lbmQpIHtcbiAgICAgICAgaWYgKCFzZWFyY2guY2xvc2UgfHwgc2VhcmNoLnBjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc2VhcmNoLmNsb3NlID0gZWxlbWVudDtcbiAgICAgICAgICAgIHNlYXJjaC5jcG9zID0gdGhpcy5wYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgICAgICAgIHNlYXJjaC5jbGVuID0gKHNlYXJjaC5pc0JlZ2luRW5kID8gMCA6IG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlYXJjaC5wY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHNlYXJjaC5tYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVuY2xvc2VNYXRoKGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5zd2l0Y2hQYXR0ZXJuKHRoaXMuc3RhcnQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgc2VhcmNoLnBjb3VudCsrXG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gXCJ9XCIgJiYgc2VhcmNoLnBjb3VudCkge1xuICAgICAgICBzZWFyY2gucGNvdW50LS1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59O1xudGV4MmpheC5wcm90b3R5cGUucHJldkVuZE1hdGNoID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VhcmNoLm1hdGNoZWQgPSB0cnVlO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbmNsb3NlTWF0aCh0aGlzLnNlYXJjaC5jbG9zZSk7XG4gICAgdGhpcy5zd2l0Y2hQYXR0ZXJuKHRoaXMuc3RhcnQpO1xuICAgIHJldHVybiBlbGVtZW50O1xufTtcblxudGV4MmpheC5wcm90b3R5cGUuc3dpdGNoUGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSB0aGlzLnBhdHRlcm4ubGFzdEluZGV4O1xuICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgdGhpcy5zZWFyY2guc3RhcnQgPSAocGF0dGVybiA9PT0gdGhpcy5zdGFydCk7XG59O1xuXG50ZXgyamF4LnByb3RvdHlwZS5lbmNsb3NlTWF0aCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoLFxuICAgICAgICBjbG9zZSA9IHNlYXJjaC5jbG9zZSxcbiAgICAgICAgQ0xPU0UsIG1hdGg7XG4gICAgaWYgKHNlYXJjaC5jcG9zID09PSBjbG9zZS5sZW5ndGgpIHtcbiAgICAgICAgY2xvc2UgPSBjbG9zZS5uZXh0U2libGluZ1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlID0gY2xvc2Uuc3BsaXRUZXh0KHNlYXJjaC5jcG9zKVxuICAgIH1cbiAgICBpZiAoIWNsb3NlKSB7XG4gICAgICAgIENMT1NFID0gY2xvc2UgPSBzZWFyY2guY2xvc2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNvbmZpZy5kb2MuY3JlYXRlVGV4dE5vZGUoXCJcIikpO1xuICAgIH1cbiAgICBzZWFyY2guY2xvc2UgPSBjbG9zZTtcbiAgICBtYXRoID0gKHNlYXJjaC5vcG9zID8gc2VhcmNoLm9wZW4uc3BsaXRUZXh0KHNlYXJjaC5vcG9zKSA6IHNlYXJjaC5vcGVuKTtcbiAgICB3aGlsZSAobWF0aC5uZXh0U2libGluZyAmJiBtYXRoLm5leHRTaWJsaW5nICE9PSBjbG9zZSkge1xuICAgICAgICBpZiAobWF0aC5uZXh0U2libGluZy5ub2RlVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChtYXRoLm5leHRTaWJsaW5nLm5vZGVOYW1lID09PSBcIiNjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICBtYXRoLm5vZGVWYWx1ZSArPSBtYXRoLm5leHRTaWJsaW5nLm5vZGVWYWx1ZS5yZXBsYWNlKC9eXFxbQ0RBVEFcXFsoKC58XFxufFxccikqKVxcXVxcXSQvLCBcIiQxXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRoLm5vZGVWYWx1ZSArPSBtYXRoLm5leHRTaWJsaW5nLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1zaWVOZXdsaW5lQnVnKSB7XG4gICAgICAgICAgICBtYXRoLm5vZGVWYWx1ZSArPSAobWF0aC5uZXh0U2libGluZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJyXCIgPyBcIlxcblwiIDogXCIgXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0aC5ub2RlVmFsdWUgKz0gXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgbWF0aC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG1hdGgubmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgICB2YXIgVGVYID0gbWF0aC5ub2RlVmFsdWUuc3Vic3RyKHNlYXJjaC5vbGVuLCBtYXRoLm5vZGVWYWx1ZS5sZW5ndGggLSBzZWFyY2gub2xlbiAtIHNlYXJjaC5jbGVuKTtcbiAgICBtYXRoLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobWF0aCk7XG4gICAgbWF0aCA9IHRoaXMuY3JlYXRlTWF0aFRhZyhzZWFyY2gubW9kZSwgVGVYKTtcbiAgICB0aGlzLnNlYXJjaCA9IHt9O1xuICAgIHRoaXMucGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgIGlmIChDTE9TRSkge1xuICAgICAgICBDTE9TRS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKENMT1NFKVxuICAgIH1cbiAgICByZXR1cm4gbWF0aDtcbn07XG5cbnRleDJqYXgucHJvdG90eXBlLmluc2VydE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaDtcbiAgICBzZWFyY2guY2xvc2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgc2VhcmNoLmNsb3NlKTtcbn07XG5cbnRleDJqYXgucHJvdG90eXBlLmNyZWF0ZU1hdGhUYWcgPSBmdW5jdGlvbiAobW9kZSwgdGV4KSB7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuY29uZmlnLmRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgIHNjcmlwdC50eXBlID0gJ21hdGgvJyArIG1vZGU7XG4gICAgc2NyaXB0LnRleHQgPSB0ZXg7XG4gICAgdGhpcy5pbnNlcnROb2RlKHNjcmlwdCk7XG4gICAgcmV0dXJuIHNjcmlwdDtcbn07XG5cbnRleDJqYXgucHJvdG90eXBlLmZpbHRlclByZXZpZXcgPSBmdW5jdGlvbiAodGV4KSB7XG4gICAgcmV0dXJuIHRleFxufTtcblxuZXhwb3J0cy50ZXgyamF4ID0gbmV3IHRleDJqYXgoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3RleDJqYXguanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBjb21tb25tYXJrLmpzIC0gQ29tbW9tTWFyayBpbiBKYXZhU2NyaXB0XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSm9obiBNYWNGYXJsYW5lXG4vLyBMaWNlbnNlOiBCU0QzLlxuXG4vLyBCYXNpYyB1c2FnZTpcbi8vXG4vLyB2YXIgY29tbW9ubWFyayA9IHJlcXVpcmUoJ2NvbW1vbm1hcmsnKTtcbi8vIHZhciBwYXJzZXIgPSBuZXcgY29tbW9ubWFyay5QYXJzZXIoKTtcbi8vIHZhciByZW5kZXJlciA9IG5ldyBjb21tb25tYXJrLkh0bWxSZW5kZXJlcigpO1xuLy8gY29uc29sZS5sb2cocmVuZGVyZXIucmVuZGVyKHBhcnNlci5wYXJzZSgnSGVsbG8gKndvcmxkKicpKSk7XG5cbm1vZHVsZS5leHBvcnRzLk5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcbm1vZHVsZS5leHBvcnRzLlBhcnNlciA9IHJlcXVpcmUoJy4vYmxvY2tzJyk7XG5tb2R1bGUuZXhwb3J0cy5IdG1sUmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlci9odG1sJyk7XG5tb2R1bGUuZXhwb3J0cy5YbWxSZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyL3htbCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29tbW9ubWFyay9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xudmFyIHVuZXNjYXBlU3RyaW5nID0gcmVxdWlyZSgnLi9jb21tb24nKS51bmVzY2FwZVN0cmluZztcbnZhciBPUEVOVEFHID0gcmVxdWlyZSgnLi9jb21tb24nKS5PUEVOVEFHO1xudmFyIENMT1NFVEFHID0gcmVxdWlyZSgnLi9jb21tb24nKS5DTE9TRVRBRztcblxudmFyIENPREVfSU5ERU5UID0gNDtcblxudmFyIENfVEFCID0gOTtcbnZhciBDX05FV0xJTkUgPSAxMDtcbnZhciBDX0dSRUFURVJUSEFOID0gNjI7XG52YXIgQ19MRVNTVEhBTiA9IDYwO1xudmFyIENfU1BBQ0UgPSAzMjtcbnZhciBDX09QRU5fQlJBQ0tFVCA9IDkxO1xuXG52YXIgSW5saW5lUGFyc2VyID0gcmVxdWlyZSgnLi9pbmxpbmVzJyk7XG5cbnZhciByZUh0bWxCbG9ja09wZW4gPSBbXG4gICAvLi8sIC8vIGR1bW15IGZvciAwXG4gICAvXjwoPzpzY3JpcHR8cHJlfHN0eWxlKSg/Olxcc3w+fCQpL2ksXG4gICAvXjwhLS0vLFxuICAgL148Wz9dLyxcbiAgIC9ePCFbQS1aXS8sXG4gICAvXjwhXFxbQ0RBVEFcXFsvLFxuICAgL148Wy9dPyg/OmFkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9ufGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8Zm9ybXxmcmFtZXxmcmFtZXNldHxoWzEyMzQ1Nl18aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWV8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbnxwfHBhcmFtfHNlY3Rpb258c291cmNlfHRpdGxlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHJ8dHJhY2t8dWwpKD86XFxzfFsvXT9bPl18JCkvaSxcbiAgICBuZXcgUmVnRXhwKCdeKD86JyArIE9QRU5UQUcgKyAnfCcgKyBDTE9TRVRBRyArICcpXFxcXHMqJCcsICdpJylcbl07XG5cbnZhciByZUh0bWxCbG9ja0Nsb3NlID0gW1xuICAgLy4vLCAvLyBkdW1teSBmb3IgMFxuICAgLzxcXC8oPzpzY3JpcHR8cHJlfHN0eWxlKT4vaSxcbiAgIC8tLT4vLFxuICAgL1xcPz4vLFxuICAgLz4vLFxuICAgL1xcXVxcXT4vXG5dO1xuXG52YXIgcmVUaGVtYXRpY0JyZWFrID0gL14oPzooPzpcXCpbIFxcdF0qKXszLH18KD86X1sgXFx0XSopezMsfXwoPzotWyBcXHRdKil7Myx9KVsgXFx0XSokLztcblxudmFyIHJlTWF5YmVTcGVjaWFsID0gL15bI2B+KitfPTw+MC05LV0vO1xuXG52YXIgcmVOb25TcGFjZSA9IC9bXiBcXHRcXGZcXHZcXHJcXG5dLztcblxudmFyIHJlQnVsbGV0TGlzdE1hcmtlciA9IC9eWyorLV0vO1xuXG52YXIgcmVPcmRlcmVkTGlzdE1hcmtlciA9IC9eKFxcZHsxLDl9KShbLildKS87XG5cbnZhciByZUFUWEhlYWRpbmdNYXJrZXIgPSAvXiN7MSw2fSg/OlsgXFx0XSt8JCkvO1xuXG52YXIgcmVDb2RlRmVuY2UgPSAvXmB7Myx9KD8hLipgKXxefnszLH0oPyEuKn4pLztcblxudmFyIHJlQ2xvc2luZ0NvZGVGZW5jZSA9IC9eKD86YHszLH18fnszLH0pKD89ICokKS87XG5cbnZhciByZVNldGV4dEhlYWRpbmdMaW5lID0gL14oPzo9K3wtKylbIFxcdF0qJC87XG5cbnZhciByZUxpbmVFbmRpbmcgPSAvXFxyXFxufFxcbnxcXHIvO1xuXG4vLyBSZXR1cm5zIHRydWUgaWYgc3RyaW5nIGNvbnRhaW5zIG9ubHkgc3BhY2UgY2hhcmFjdGVycy5cbnZhciBpc0JsYW5rID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiAhKHJlTm9uU3BhY2UudGVzdChzKSk7XG59O1xuXG52YXIgaXNTcGFjZU9yVGFiID0gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBjID09PSBDX1NQQUNFIHx8IGMgPT09IENfVEFCO1xufTtcblxudmFyIHBlZWsgPSBmdW5jdGlvbihsbiwgcG9zKSB7XG4gICAgaWYgKHBvcyA8IGxuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbG4uY2hhckNvZGVBdChwb3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59O1xuXG4vLyBET0MgUEFSU0VSXG5cbi8vIFRoZXNlIGFyZSBtZXRob2RzIG9mIGEgUGFyc2VyIG9iamVjdCwgZGVmaW5lZCBiZWxvdy5cblxuLy8gUmV0dXJucyB0cnVlIGlmIGJsb2NrIGVuZHMgd2l0aCBhIGJsYW5rIGxpbmUsIGRlc2NlbmRpbmcgaWYgbmVlZGVkXG4vLyBpbnRvIGxpc3RzIGFuZCBzdWJsaXN0cy5cbnZhciBlbmRzV2l0aEJsYW5rTGluZSA9IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgd2hpbGUgKGJsb2NrKSB7XG4gICAgICAgIGlmIChibG9jay5fbGFzdExpbmVCbGFuaykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSBibG9jay50eXBlO1xuICAgICAgICBpZiAodCA9PT0gJ2xpc3QnIHx8IHQgPT09ICdpdGVtJykge1xuICAgICAgICAgICAgYmxvY2sgPSBibG9jay5fbGFzdENoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gQWRkIGEgbGluZSB0byB0aGUgYmxvY2sgYXQgdGhlIHRpcC4gIFdlIGFzc3VtZSB0aGUgdGlwXG4vLyBjYW4gYWNjZXB0IGxpbmVzIC0tIHRoYXQgY2hlY2sgc2hvdWxkIGJlIGRvbmUgYmVmb3JlIGNhbGxpbmcgdGhpcy5cbnZhciBhZGRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIpIHtcbiAgICAgIHRoaXMub2Zmc2V0ICs9IDE7IC8vIHNraXAgb3ZlciB0YWJcbiAgICAgIC8vIGFkZCBzcGFjZSBjaGFyYWN0ZXJzOlxuICAgICAgdmFyIGNoYXJzVG9UYWIgPSA0IC0gKHRoaXMuY29sdW1uICUgNCk7XG4gICAgICB0aGlzLnRpcC5fc3RyaW5nX2NvbnRlbnQgKz0gKCcgJy5yZXBlYXQoY2hhcnNUb1RhYikpO1xuICAgIH1cbiAgICB0aGlzLnRpcC5fc3RyaW5nX2NvbnRlbnQgKz0gdGhpcy5jdXJyZW50TGluZS5zbGljZSh0aGlzLm9mZnNldCkgKyAnXFxuJztcbn07XG5cbi8vIEFkZCBibG9jayBvZiB0eXBlIHRhZyBhcyBhIGNoaWxkIG9mIHRoZSB0aXAuICBJZiB0aGUgdGlwIGNhbid0XG4vLyBhY2NlcHQgY2hpbGRyZW4sIGNsb3NlIGFuZCBmaW5hbGl6ZSBpdCBhbmQgdHJ5IGl0cyBwYXJlbnQsXG4vLyBhbmQgc28gb24gdGlsIHdlIGZpbmQgYSBibG9jayB0aGF0IGNhbiBhY2NlcHQgY2hpbGRyZW4uXG52YXIgYWRkQ2hpbGQgPSBmdW5jdGlvbih0YWcsIG9mZnNldCkge1xuICAgIHdoaWxlICghdGhpcy5ibG9ja3NbdGhpcy50aXAudHlwZV0uY2FuQ29udGFpbih0YWcpKSB7XG4gICAgICAgIHRoaXMuZmluYWxpemUodGhpcy50aXAsIHRoaXMubGluZU51bWJlciAtIDEpO1xuICAgIH1cblxuICAgIHZhciBjb2x1bW5fbnVtYmVyID0gb2Zmc2V0ICsgMTsgLy8gb2Zmc2V0IDAgPSBjb2x1bW4gMVxuICAgIHZhciBuZXdCbG9jayA9IG5ldyBOb2RlKHRhZywgW1t0aGlzLmxpbmVOdW1iZXIsIGNvbHVtbl9udW1iZXJdLCBbMCwgMF1dKTtcbiAgICBuZXdCbG9jay5fc3RyaW5nX2NvbnRlbnQgPSAnJztcbiAgICB0aGlzLnRpcC5hcHBlbmRDaGlsZChuZXdCbG9jayk7XG4gICAgdGhpcy50aXAgPSBuZXdCbG9jaztcbiAgICByZXR1cm4gbmV3QmxvY2s7XG59O1xuXG4vLyBQYXJzZSBhIGxpc3QgbWFya2VyIGFuZCByZXR1cm4gZGF0YSBvbiB0aGUgbWFya2VyICh0eXBlLFxuLy8gc3RhcnQsIGRlbGltaXRlciwgYnVsbGV0IGNoYXJhY3RlciwgcGFkZGluZykgb3IgbnVsbC5cbnZhciBwYXJzZUxpc3RNYXJrZXIgPSBmdW5jdGlvbihwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciByZXN0ID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgIHZhciBtYXRjaDtcbiAgICB2YXIgbmV4dGM7XG4gICAgdmFyIHNwYWNlc1N0YXJ0Q29sO1xuICAgIHZhciBzcGFjZXNTdGFydE9mZnNldDtcbiAgICB2YXIgZGF0YSA9IHsgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgdGlnaHQ6IHRydWUsICAvLyBsaXN0cyBhcmUgdGlnaHQgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgICBidWxsZXRDaGFyOiBudWxsLFxuICAgICAgICAgICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgICAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICAgICAgICAgICBwYWRkaW5nOiBudWxsLFxuICAgICAgICAgICAgICAgICBtYXJrZXJPZmZzZXQ6IHBhcnNlci5pbmRlbnQgfTtcbiAgICBpZiAoKG1hdGNoID0gcmVzdC5tYXRjaChyZUJ1bGxldExpc3RNYXJrZXIpKSkge1xuICAgICAgICBkYXRhLnR5cGUgPSAnYnVsbGV0JztcbiAgICAgICAgZGF0YS5idWxsZXRDaGFyID0gbWF0Y2hbMF1bMF07XG5cbiAgICB9IGVsc2UgaWYgKChtYXRjaCA9IHJlc3QubWF0Y2gocmVPcmRlcmVkTGlzdE1hcmtlcikpICYmXG4gICAgICAgICAgICAgICAgKGNvbnRhaW5lci50eXBlICE9PSAncGFyYWdyYXBoJyB8fFxuICAgICAgICAgICAgICAgICBtYXRjaFsxXSA9PT0gJzEnKSkge1xuICAgICAgICBkYXRhLnR5cGUgPSAnb3JkZXJlZCc7XG4gICAgICAgIGRhdGEuc3RhcnQgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgIGRhdGEuZGVsaW1pdGVyID0gbWF0Y2hbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHNwYWNlcyBhZnRlclxuICAgIG5leHRjID0gcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UgKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgIGlmICghKG5leHRjID09PSAtMSB8fCBuZXh0YyA9PT0gQ19UQUIgfHwgbmV4dGMgPT09IENfU1BBQ0UpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIGl0IGludGVycnVwdHMgcGFyYWdyYXBoLCBtYWtlIHN1cmUgZmlyc3QgbGluZSBpc24ndCBibGFua1xuICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiYgIXBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlICsgbWF0Y2hbMF0ubGVuZ3RoKS5tYXRjaChyZU5vblNwYWNlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB3ZSd2ZSBnb3QgYSBtYXRjaCEgYWR2YW5jZSBvZmZzZXQgYW5kIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTsgLy8gdG8gc3RhcnQgb2YgbWFya2VyXG4gICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQobWF0Y2hbMF0ubGVuZ3RoLCB0cnVlKTsgLy8gdG8gZW5kIG9mIG1hcmtlclxuICAgIHNwYWNlc1N0YXJ0Q29sID0gcGFyc2VyLmNvbHVtbjtcbiAgICBzcGFjZXNTdGFydE9mZnNldCA9IHBhcnNlci5vZmZzZXQ7XG4gICAgZG8ge1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCB0cnVlKTtcbiAgICAgICAgbmV4dGMgPSBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm9mZnNldCk7XG4gICAgfSB3aGlsZSAocGFyc2VyLmNvbHVtbiAtIHNwYWNlc1N0YXJ0Q29sIDwgNSAmJlxuICAgICAgICAgICBpc1NwYWNlT3JUYWIobmV4dGMpKTtcbiAgICB2YXIgYmxhbmtfaXRlbSA9IHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KSA9PT0gLTE7XG4gICAgdmFyIHNwYWNlc19hZnRlcl9tYXJrZXIgPSBwYXJzZXIuY29sdW1uIC0gc3BhY2VzU3RhcnRDb2w7XG4gICAgaWYgKHNwYWNlc19hZnRlcl9tYXJrZXIgPj0gNSB8fFxuICAgICAgICBzcGFjZXNfYWZ0ZXJfbWFya2VyIDwgMSB8fFxuICAgICAgICBibGFua19pdGVtKSB7XG4gICAgICAgIGRhdGEucGFkZGluZyA9IG1hdGNoWzBdLmxlbmd0aCArIDE7XG4gICAgICAgIHBhcnNlci5jb2x1bW4gPSBzcGFjZXNTdGFydENvbDtcbiAgICAgICAgcGFyc2VyLm9mZnNldCA9IHNwYWNlc1N0YXJ0T2Zmc2V0O1xuICAgICAgICBpZiAoaXNTcGFjZU9yVGFiKHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5wYWRkaW5nID0gbWF0Y2hbMF0ubGVuZ3RoICsgc3BhY2VzX2FmdGVyX21hcmtlcjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBsaXN0IGl0ZW1zIGFyZSBvZiB0aGUgc2FtZSB0eXBlLFxuLy8gd2l0aCB0aGUgc2FtZSBkZWxpbWl0ZXIgYW5kIGJ1bGxldCBjaGFyYWN0ZXIuICBUaGlzIGlzIHVzZWRcbi8vIGluIGFnZ2xvbWVyYXRpbmcgbGlzdCBpdGVtcyBpbnRvIGxpc3RzLlxudmFyIGxpc3RzTWF0Y2ggPSBmdW5jdGlvbihsaXN0X2RhdGEsIGl0ZW1fZGF0YSkge1xuICAgIHJldHVybiAobGlzdF9kYXRhLnR5cGUgPT09IGl0ZW1fZGF0YS50eXBlICYmXG4gICAgICAgICAgICBsaXN0X2RhdGEuZGVsaW1pdGVyID09PSBpdGVtX2RhdGEuZGVsaW1pdGVyICYmXG4gICAgICAgICAgICBsaXN0X2RhdGEuYnVsbGV0Q2hhciA9PT0gaXRlbV9kYXRhLmJ1bGxldENoYXIpO1xufTtcblxuLy8gRmluYWxpemUgYW5kIGNsb3NlIGFueSB1bm1hdGNoZWQgYmxvY2tzLlxudmFyIGNsb3NlVW5tYXRjaGVkQmxvY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmFsbENsb3NlZCkge1xuICAgICAgICAvLyBmaW5hbGl6ZSBhbnkgYmxvY2tzIG5vdCBtYXRjaGVkXG4gICAgICAgIHdoaWxlICh0aGlzLm9sZHRpcCAhPT0gdGhpcy5sYXN0TWF0Y2hlZENvbnRhaW5lcikge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMub2xkdGlwLl9wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplKHRoaXMub2xkdGlwLCB0aGlzLmxpbmVOdW1iZXIgLSAxKTtcbiAgICAgICAgICAgIHRoaXMub2xkdGlwID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsQ2xvc2VkID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vLyAnZmluYWxpemUnIGlzIHJ1biB3aGVuIHRoZSBibG9jayBpcyBjbG9zZWQuXG4vLyAnY29udGludWUnIGlzIHJ1biB0byBjaGVjayB3aGV0aGVyIHRoZSBibG9jayBpcyBjb250aW51aW5nXG4vLyBhdCBhIGNlcnRhaW4gbGluZSBhbmQgb2Zmc2V0IChlLmcuIHdoZXRoZXIgYSBibG9jayBxdW90ZVxuLy8gY29udGFpbnMgYSBgPmAuICBJdCByZXR1cm5zIDAgZm9yIG1hdGNoZWQsIDEgZm9yIG5vdCBtYXRjaGVkLFxuLy8gYW5kIDIgZm9yIFwid2UndmUgZGVhbHQgd2l0aCB0aGlzIGxpbmUgY29tcGxldGVseSwgZ28gdG8gbmV4dC5cIlxudmFyIGJsb2NrcyA9IHtcbiAgICBkb2N1bWVudDoge1xuICAgICAgICBjb250aW51ZTogZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9LFxuICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24oKSB7IHJldHVybjsgfSxcbiAgICAgICAgY2FuQ29udGFpbjogZnVuY3Rpb24odCkgeyByZXR1cm4gKHQgIT09ICdpdGVtJyk7IH0sXG4gICAgICAgIGFjY2VwdHNMaW5lczogZmFsc2VcbiAgICB9LFxuICAgIGxpc3Q6IHtcbiAgICAgICAgY29udGludWU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfSxcbiAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uKHBhcnNlciwgYmxvY2spIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYmxvY2suX2ZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBub24tZmluYWwgbGlzdCBpdGVtIGVuZGluZyB3aXRoIGJsYW5rIGxpbmU6XG4gICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKGl0ZW0pICYmIGl0ZW0uX25leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suX2xpc3REYXRhLnRpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZWN1cnNlIGludG8gY2hpbGRyZW4gb2YgbGlzdCBpdGVtLCB0byBzZWUgaWYgdGhlcmUgYXJlXG4gICAgICAgICAgICAgICAgLy8gc3BhY2VzIGJldHdlZW4gYW55IG9mIHRoZW06XG4gICAgICAgICAgICAgICAgdmFyIHN1Yml0ZW0gPSBpdGVtLl9maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdWJpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZShzdWJpdGVtKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGl0ZW0uX25leHQgfHwgc3ViaXRlbS5fbmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLl9saXN0RGF0YS50aWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3ViaXRlbSA9IHN1Yml0ZW0uX25leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLl9uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYW5Db250YWluOiBmdW5jdGlvbih0KSB7IHJldHVybiAodCA9PT0gJ2l0ZW0nKTsgfSxcbiAgICAgICAgYWNjZXB0c0xpbmVzOiBmYWxzZVxuICAgIH0sXG4gICAgYmxvY2tfcXVvdGU6IHtcbiAgICAgICAgY29udGludWU6IGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICAgICAgdmFyIGxuID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICAgICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiZcbiAgICAgICAgICAgICAgICBwZWVrKGxuLCBwYXJzZXIubmV4dE5vbnNwYWNlKSA9PT0gQ19HUkVBVEVSVEhBTikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChpc1NwYWNlT3JUYWIocGVlayhsbiwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm47IH0sXG4gICAgICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uKHQpIHsgcmV0dXJuICh0ICE9PSAnaXRlbScpOyB9LFxuICAgICAgICBhY2NlcHRzTGluZXM6IGZhbHNlXG4gICAgfSxcbiAgICBpdGVtOiB7XG4gICAgICAgIGNvbnRpbnVlOiBmdW5jdGlvbihwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKHBhcnNlci5ibGFuaykge1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIuX2ZpcnN0Q2hpbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCbGFuayBsaW5lIGFmdGVyIGVtcHR5IGxpc3QgaXRlbVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLmluZGVudCA+PVxuICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuX2xpc3REYXRhLm1hcmtlck9mZnNldCArXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5fbGlzdERhdGEucGFkZGluZykge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KGNvbnRhaW5lci5fbGlzdERhdGEubWFya2VyT2Zmc2V0ICtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLl9saXN0RGF0YS5wYWRkaW5nLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm47IH0sXG4gICAgICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uKHQpIHsgcmV0dXJuICh0ICE9PSAnaXRlbScpOyB9LFxuICAgICAgICBhY2NlcHRzTGluZXM6IGZhbHNlXG4gICAgfSxcbiAgICBoZWFkaW5nOiB7XG4gICAgICAgIGNvbnRpbnVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGEgaGVhZGluZyBjYW4gbmV2ZXIgY29udGFpbmVyID4gMSBsaW5lLCBzbyBmYWlsIHRvIG1hdGNoOlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuOyB9LFxuICAgICAgICBjYW5Db250YWluOiBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICBhY2NlcHRzTGluZXM6IGZhbHNlXG4gICAgfSxcbiAgICB0aGVtYXRpY19icmVhazoge1xuICAgICAgICBjb250aW51ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBhIHRoZW1hdGljIGJyZWFrIGNhbiBuZXZlciBjb250YWluZXIgPiAxIGxpbmUsIHNvIGZhaWwgdG8gbWF0Y2g6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm47IH0sXG4gICAgICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgIGFjY2VwdHNMaW5lczogZmFsc2VcbiAgICB9LFxuICAgIGNvZGVfYmxvY2s6IHtcbiAgICAgICAgY29udGludWU6IGZ1bmN0aW9uKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgICAgICB2YXIgbG4gPSBwYXJzZXIuY3VycmVudExpbmU7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gcGFyc2VyLmluZGVudDtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuX2lzRmVuY2VkKSB7IC8vIGZlbmNlZFxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IChpbmRlbnQgPD0gMyAmJlxuICAgICAgICAgICAgICAgICAgICBsbi5jaGFyQXQocGFyc2VyLm5leHROb25zcGFjZSkgPT09IGNvbnRhaW5lci5fZmVuY2VDaGFyICYmXG4gICAgICAgICAgICAgICAgICAgIGxuLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpLm1hdGNoKHJlQ2xvc2luZ0NvZGVGZW5jZSkpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFswXS5sZW5ndGggPj0gY29udGFpbmVyLl9mZW5jZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbG9zaW5nIGZlbmNlIC0gd2UncmUgYXQgZW5kIG9mIGxpbmUsIHNvIHdlIGNhbiByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgcGFyc2VyLmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIG9wdGlvbmFsIHNwYWNlcyBvZiBmZW5jZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBjb250YWluZXIuX2ZlbmNlT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgaXNTcGFjZU9yVGFiKHBlZWsobG4sIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpbmRlbnRlZFxuICAgICAgICAgICAgICAgIGlmIChpbmRlbnQgPj0gQ09ERV9JTkRFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoQ09ERV9JTkRFTlQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLmJsYW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbihwYXJzZXIsIGJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoYmxvY2suX2lzRmVuY2VkKSB7IC8vIGZlbmNlZFxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IGxpbmUgYmVjb21lcyBpbmZvIHN0cmluZ1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gYmxvY2suX3N0cmluZ19jb250ZW50O1xuICAgICAgICAgICAgICAgIHZhciBuZXdsaW5lUG9zID0gY29udGVudC5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RMaW5lID0gY29udGVudC5zbGljZSgwLCBuZXdsaW5lUG9zKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdCA9IGNvbnRlbnQuc2xpY2UobmV3bGluZVBvcyArIDEpO1xuICAgICAgICAgICAgICAgIGJsb2NrLmluZm8gPSB1bmVzY2FwZVN0cmluZyhmaXJzdExpbmUudHJpbSgpKTtcbiAgICAgICAgICAgICAgICBibG9jay5fbGl0ZXJhbCA9IHJlc3Q7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpbmRlbnRlZFxuICAgICAgICAgICAgICAgIGJsb2NrLl9saXRlcmFsID0gYmxvY2suX3N0cmluZ19jb250ZW50LnJlcGxhY2UoLyhcXG4gKikrJC8sICdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLl9zdHJpbmdfY29udGVudCA9IG51bGw7IC8vIGFsbG93IEdDXG4gICAgICAgIH0sXG4gICAgICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgIGFjY2VwdHNMaW5lczogdHJ1ZVxuICAgIH0sXG4gICAgaHRtbF9ibG9jazoge1xuICAgICAgICBjb250aW51ZTogZnVuY3Rpb24ocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKHBhcnNlci5ibGFuayAmJlxuICAgICAgICAgICAgICAgICAgICAgKGNvbnRhaW5lci5faHRtbEJsb2NrVHlwZSA9PT0gNiB8fFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5faHRtbEJsb2NrVHlwZSA9PT0gNykpID8gMSA6IDApO1xuICAgICAgICB9LFxuICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24ocGFyc2VyLCBibG9jaykge1xuICAgICAgICAgICAgYmxvY2suX2xpdGVyYWwgPSBibG9jay5fc3RyaW5nX2NvbnRlbnQucmVwbGFjZSgvKFxcbiAqKSskLywgJycpO1xuICAgICAgICAgICAgYmxvY2suX3N0cmluZ19jb250ZW50ID0gbnVsbDsgLy8gYWxsb3cgR0NcbiAgICAgICAgfSxcbiAgICAgICAgY2FuQ29udGFpbjogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgYWNjZXB0c0xpbmVzOiB0cnVlXG4gICAgfSxcbiAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgY29udGludWU6IGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICAgICAgcmV0dXJuIChwYXJzZXIuYmxhbmsgPyAxIDogMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbihwYXJzZXIsIGJsb2NrKSB7XG4gICAgICAgICAgICB2YXIgcG9zO1xuICAgICAgICAgICAgdmFyIGhhc1JlZmVyZW5jZURlZnMgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gdHJ5IHBhcnNpbmcgdGhlIGJlZ2lubmluZyBhcyBsaW5rIHJlZmVyZW5jZSBkZWZpbml0aW9uczpcbiAgICAgICAgICAgIHdoaWxlIChwZWVrKGJsb2NrLl9zdHJpbmdfY29udGVudCwgMCkgPT09IENfT1BFTl9CUkFDS0VUICYmXG4gICAgICAgICAgICAgICAgICAgKHBvcyA9XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5pbmxpbmVQYXJzZXIucGFyc2VSZWZlcmVuY2UoYmxvY2suX3N0cmluZ19jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5yZWZtYXApKSkge1xuICAgICAgICAgICAgICAgIGJsb2NrLl9zdHJpbmdfY29udGVudCA9IGJsb2NrLl9zdHJpbmdfY29udGVudC5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgIGhhc1JlZmVyZW5jZURlZnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1JlZmVyZW5jZURlZnMgJiYgaXNCbGFuayhibG9jay5fc3RyaW5nX2NvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgYmxvY2sudW5saW5rKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgIGFjY2VwdHNMaW5lczogdHJ1ZVxuICAgIH1cbn07XG5cbi8vIGJsb2NrIHN0YXJ0IGZ1bmN0aW9ucy4gIFJldHVybiB2YWx1ZXM6XG4vLyAwID0gbm8gbWF0Y2hcbi8vIDEgPSBtYXRjaGVkIGNvbnRhaW5lciwga2VlcCBnb2luZ1xuLy8gMiA9IG1hdGNoZWQgbGVhZiwgbm8gbW9yZSBibG9jayBzdGFydHNcbnZhciBibG9ja1N0YXJ0cyA9IFtcbiAgICAvLyBibG9jayBxdW90ZVxuICAgIGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICAgICAgcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UpID09PSBDX0dSRUFURVJUSEFOKSB7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gb3B0aW9uYWwgZm9sbG93aW5nIHNwYWNlXG4gICAgICAgICAgICBpZiAoaXNTcGFjZU9yVGFiKHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAgICAgcGFyc2VyLmFkZENoaWxkKCdibG9ja19xdW90ZScsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBBVFggaGVhZGluZ1xuICAgIGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkubWF0Y2gocmVBVFhIZWFkaW5nTWFya2VyKSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChtYXRjaFswXS5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBhcnNlci5hZGRDaGlsZCgnaGVhZGluZycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICAgICAgY29udGFpbmVyLmxldmVsID0gbWF0Y2hbMF0udHJpbSgpLmxlbmd0aDsgLy8gbnVtYmVyIG9mICNzXG4gICAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgIyMjczpcbiAgICAgICAgICAgIGNvbnRhaW5lci5fc3RyaW5nX2NvbnRlbnQgPVxuICAgICAgICAgICAgICAgIHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIub2Zmc2V0KS5yZXBsYWNlKC9eWyBcXHRdKiMrWyBcXHRdKiQvLCAnJykucmVwbGFjZSgvWyBcXHRdKyMrWyBcXHRdKiQvLCAnJyk7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoIC0gcGFyc2VyLm9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEZlbmNlZCBjb2RlIGJsb2NrXG4gICAgZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiZcbiAgICAgICAgICAgIChtYXRjaCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZUNvZGVGZW5jZSkpKSB7XG4gICAgICAgICAgICB2YXIgZmVuY2VMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBwYXJzZXIuYWRkQ2hpbGQoJ2NvZGVfYmxvY2snLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5faXNGZW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29udGFpbmVyLl9mZW5jZUxlbmd0aCA9IGZlbmNlTGVuZ3RoO1xuICAgICAgICAgICAgY29udGFpbmVyLl9mZW5jZUNoYXIgPSBtYXRjaFswXVswXTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5fZmVuY2VPZmZzZXQgPSBwYXJzZXIuaW5kZW50O1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KGZlbmNlTGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEhUTUwgYmxvY2tcbiAgICBmdW5jdGlvbihwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICAgICAgcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UpID09PSBDX0xFU1NUSEFOKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgICAgIHZhciBibG9ja1R5cGU7XG5cbiAgICAgICAgICAgIGZvciAoYmxvY2tUeXBlID0gMTsgYmxvY2tUeXBlIDw9IDc7IGJsb2NrVHlwZSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlSHRtbEJsb2NrT3BlbltibG9ja1R5cGVdLnRlc3QocykgJiZcbiAgICAgICAgICAgICAgICAgICAgKGJsb2NrVHlwZSA8IDcgfHxcbiAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci50eXBlICE9PSAncGFyYWdyYXBoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGFkanVzdCBwYXJzZXIub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZXMgYXJlIHBhcnQgb2YgdGhlIEhUTUwgYmxvY2s6XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VyLmFkZENoaWxkKCdodG1sX2Jsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGIuX2h0bWxCbG9ja1R5cGUgPSBibG9ja1R5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgfSxcblxuICAgIC8vIFNldGV4dCBoZWFkaW5nXG4gICAgZnVuY3Rpb24ocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICAgICAgY29udGFpbmVyLnR5cGUgPT09ICdwYXJhZ3JhcGgnICYmXG4gICAgICAgICAgICAgICAgICAgKChtYXRjaCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZVNldGV4dEhlYWRpbmdMaW5lKSkpKSB7XG4gICAgICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgICAgIHZhciBoZWFkaW5nID0gbmV3IE5vZGUoJ2hlYWRpbmcnLCBjb250YWluZXIuc291cmNlcG9zKTtcbiAgICAgICAgICAgIGhlYWRpbmcubGV2ZWwgPSBtYXRjaFswXVswXSA9PT0gJz0nID8gMSA6IDI7XG4gICAgICAgICAgICBoZWFkaW5nLl9zdHJpbmdfY29udGVudCA9IGNvbnRhaW5lci5fc3RyaW5nX2NvbnRlbnQ7XG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QWZ0ZXIoaGVhZGluZyk7XG4gICAgICAgICAgICBjb250YWluZXIudW5saW5rKCk7XG4gICAgICAgICAgICBwYXJzZXIudGlwID0gaGVhZGluZztcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIHRoZW1hdGljIGJyZWFrXG4gICAgZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgICAgICByZVRoZW1hdGljQnJlYWsudGVzdChwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkpKSB7XG4gICAgICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgICAgIHBhcnNlci5hZGRDaGlsZCgndGhlbWF0aWNfYnJlYWsnLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIGxpc3QgaXRlbVxuICAgIGZ1bmN0aW9uKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBkYXRhO1xuXG4gICAgICAgIGlmICgoIXBhcnNlci5pbmRlbnRlZCB8fCBjb250YWluZXIudHlwZSA9PT0gJ2xpc3QnKVxuICAgICAgICAgICAgICAgICYmIChkYXRhID0gcGFyc2VMaXN0TWFya2VyKHBhcnNlciwgY29udGFpbmVyKSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuXG4gICAgICAgICAgICAvLyBhZGQgdGhlIGxpc3QgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAocGFyc2VyLnRpcC50eXBlICE9PSAnbGlzdCcgfHxcbiAgICAgICAgICAgICAgICAhKGxpc3RzTWF0Y2goY29udGFpbmVyLl9saXN0RGF0YSwgZGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gcGFyc2VyLmFkZENoaWxkKCdsaXN0JywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLl9saXN0RGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgbGlzdCBpdGVtXG4gICAgICAgICAgICBjb250YWluZXIgPSBwYXJzZXIuYWRkQ2hpbGQoJ2l0ZW0nLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5fbGlzdERhdGEgPSBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBpbmRlbnRlZCBjb2RlIGJsb2NrXG4gICAgZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICAgIGlmIChwYXJzZXIuaW5kZW50ZWQgJiZcbiAgICAgICAgICAgIHBhcnNlci50aXAudHlwZSAhPT0gJ3BhcmFncmFwaCcgJiZcbiAgICAgICAgICAgICFwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgICAgIC8vIGluZGVudGVkIGNvZGVcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KENPREVfSU5ERU5ULCB0cnVlKTtcbiAgICAgICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAgICAgcGFyc2VyLmFkZENoaWxkKCdjb2RlX2Jsb2NrJywgcGFyc2VyLm9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgIH1cblxuXTtcblxudmFyIGFkdmFuY2VPZmZzZXQgPSBmdW5jdGlvbihjb3VudCwgY29sdW1ucykge1xuICAgIHZhciBjdXJyZW50TGluZSA9IHRoaXMuY3VycmVudExpbmU7XG4gICAgdmFyIGNoYXJzVG9UYWIsIGNoYXJzVG9BZHZhbmNlO1xuICAgIHZhciBjO1xuICAgIHdoaWxlIChjb3VudCA+IDAgJiYgKGMgPSBjdXJyZW50TGluZVt0aGlzLm9mZnNldF0pKSB7XG4gICAgICAgIGlmIChjID09PSAnXFx0Jykge1xuICAgICAgICAgICAgY2hhcnNUb1RhYiA9IDQgLSAodGhpcy5jb2x1bW4gJSA0KTtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGNoYXJzVG9UYWIgPiBjb3VudDtcbiAgICAgICAgICAgICAgICBjaGFyc1RvQWR2YW5jZSA9IGNoYXJzVG9UYWIgPiBjb3VudCA/IGNvdW50IDogY2hhcnNUb1RhYjtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArPSBjaGFyc1RvQWR2YW5jZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgY291bnQgLT0gY2hhcnNUb0FkdmFuY2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArPSBjaGFyc1RvVGFiO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbiArPSAxOyAvLyBhc3N1bWUgYXNjaWk7IGJsb2NrIHN0YXJ0cyBhcmUgYXNjaWlcbiAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgYWR2YW5jZU5leHROb25zcGFjZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5uZXh0Tm9uc3BhY2U7XG4gICAgdGhpcy5jb2x1bW4gPSB0aGlzLm5leHROb25zcGFjZUNvbHVtbjtcbiAgICB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID0gZmFsc2U7XG59O1xuXG52YXIgZmluZE5leHROb25zcGFjZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJyZW50TGluZSA9IHRoaXMuY3VycmVudExpbmU7XG4gICAgdmFyIGkgPSB0aGlzLm9mZnNldDtcbiAgICB2YXIgY29scyA9IHRoaXMuY29sdW1uO1xuICAgIHZhciBjO1xuXG4gICAgd2hpbGUgKChjID0gY3VycmVudExpbmUuY2hhckF0KGkpKSAhPT0gJycpIHtcbiAgICAgICAgaWYgKGMgPT09ICcgJykge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29scysrO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb2xzICs9ICg0IC0gKGNvbHMgJSA0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJsYW5rID0gKGMgPT09ICdcXG4nIHx8IGMgPT09ICdcXHInIHx8IGMgPT09ICcnKTtcbiAgICB0aGlzLm5leHROb25zcGFjZSA9IGk7XG4gICAgdGhpcy5uZXh0Tm9uc3BhY2VDb2x1bW4gPSBjb2xzO1xuICAgIHRoaXMuaW5kZW50ID0gdGhpcy5uZXh0Tm9uc3BhY2VDb2x1bW4gLSB0aGlzLmNvbHVtbjtcbiAgICB0aGlzLmluZGVudGVkID0gdGhpcy5pbmRlbnQgPj0gQ09ERV9JTkRFTlQ7XG59O1xuXG4vLyBBbmFseXplIGEgbGluZSBvZiB0ZXh0IGFuZCB1cGRhdGUgdGhlIGRvY3VtZW50IGFwcHJvcHJpYXRlbHkuXG4vLyBXZSBwYXJzZSBtYXJrZG93biB0ZXh0IGJ5IGNhbGxpbmcgdGhpcyBvbiBlYWNoIGxpbmUgb2YgaW5wdXQsXG4vLyB0aGVuIGZpbmFsaXppbmcgdGhlIGRvY3VtZW50LlxudmFyIGluY29ycG9yYXRlTGluZSA9IGZ1bmN0aW9uKGxuKSB7XG4gICAgdmFyIGFsbF9tYXRjaGVkID0gdHJ1ZTtcbiAgICB2YXIgdDtcblxuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmRvYztcbiAgICB0aGlzLm9sZHRpcCA9IHRoaXMudGlwO1xuICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgdGhpcy5ibGFuayA9IGZhbHNlO1xuICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICB0aGlzLmxpbmVOdW1iZXIgKz0gMTtcblxuICAgIC8vIHJlcGxhY2UgTlVMIGNoYXJhY3RlcnMgZm9yIHNlY3VyaXR5XG4gICAgaWYgKGxuLmluZGV4T2YoJ1xcdTAwMDAnKSAhPT0gLTEpIHtcbiAgICAgICAgbG4gPSBsbi5yZXBsYWNlKC9cXDAvZywgJ1xcdUZGRkQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRMaW5lID0gbG47XG5cbiAgICAvLyBGb3IgZWFjaCBjb250YWluaW5nIGJsb2NrLCB0cnkgdG8gcGFyc2UgdGhlIGFzc29jaWF0ZWQgbGluZSBzdGFydC5cbiAgICAvLyBCYWlsIG91dCBvbiBmYWlsdXJlOiBjb250YWluZXIgd2lsbCBwb2ludCB0byB0aGUgbGFzdCBtYXRjaGluZyBibG9jay5cbiAgICAvLyBTZXQgYWxsX21hdGNoZWQgdG8gZmFsc2UgaWYgbm90IGFsbCBjb250YWluZXJzIG1hdGNoLlxuICAgIHZhciBsYXN0Q2hpbGQ7XG4gICAgd2hpbGUgKChsYXN0Q2hpbGQgPSBjb250YWluZXIuX2xhc3RDaGlsZCkgJiYgbGFzdENoaWxkLl9vcGVuKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGxhc3RDaGlsZDtcblxuICAgICAgICB0aGlzLmZpbmROZXh0Tm9uc3BhY2UoKTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuYmxvY2tzW2NvbnRhaW5lci50eXBlXS5jb250aW51ZSh0aGlzLCBjb250YWluZXIpKSB7XG4gICAgICAgIGNhc2UgMDogLy8gd2UndmUgbWF0Y2hlZCwga2VlcCBnb2luZ1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTogLy8gd2UndmUgZmFpbGVkIHRvIG1hdGNoIGEgYmxvY2tcbiAgICAgICAgICAgIGFsbF9tYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOiAvLyB3ZSd2ZSBoaXQgZW5kIG9mIGxpbmUgZm9yIGZlbmNlZCBjb2RlIGNsb3NlIGFuZCBjYW4gcmV0dXJuXG4gICAgICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gbG4ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ2NvbnRpbnVlIHJldHVybmVkIGlsbGVnYWwgdmFsdWUsIG11c3QgYmUgMCwgMSwgb3IgMic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbGxfbWF0Y2hlZCkge1xuICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLl9wYXJlbnQ7IC8vIGJhY2sgdXAgdG8gbGFzdCBtYXRjaGluZyBibG9ja1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFsbENsb3NlZCA9IChjb250YWluZXIgPT09IHRoaXMub2xkdGlwKTtcbiAgICB0aGlzLmxhc3RNYXRjaGVkQ29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgdmFyIG1hdGNoZWRMZWFmID0gY29udGFpbmVyLnR5cGUgIT09ICdwYXJhZ3JhcGgnICYmXG4gICAgICAgICAgICBibG9ja3NbY29udGFpbmVyLnR5cGVdLmFjY2VwdHNMaW5lcztcbiAgICB2YXIgc3RhcnRzID0gdGhpcy5ibG9ja1N0YXJ0cztcbiAgICB2YXIgc3RhcnRzTGVuID0gc3RhcnRzLmxlbmd0aDtcbiAgICAvLyBVbmxlc3MgbGFzdCBtYXRjaGVkIGNvbnRhaW5lciBpcyBhIGNvZGUgYmxvY2ssIHRyeSBuZXcgY29udGFpbmVyIHN0YXJ0cyxcbiAgICAvLyBhZGRpbmcgY2hpbGRyZW4gdG8gdGhlIGxhc3QgbWF0Y2hlZCBjb250YWluZXI6XG4gICAgd2hpbGUgKCFtYXRjaGVkTGVhZikge1xuXG4gICAgICAgIHRoaXMuZmluZE5leHROb25zcGFjZSgpO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgYSBsaXR0bGUgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOlxuICAgICAgICBpZiAoIXRoaXMuaW5kZW50ZWQgJiZcbiAgICAgICAgICAgICFyZU1heWJlU3BlY2lhbC50ZXN0KGxuLnNsaWNlKHRoaXMubmV4dE5vbnNwYWNlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RhcnRzTGVuKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gc3RhcnRzW2ldKHRoaXMsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAocmVzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy50aXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMudGlwO1xuICAgICAgICAgICAgICAgIG1hdGNoZWRMZWFmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT09IHN0YXJ0c0xlbikgeyAvLyBub3RoaW5nIG1hdGNoZWRcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGF0IHJlbWFpbnMgYXQgdGhlIG9mZnNldCBpcyBhIHRleHQgbGluZS4gIEFkZCB0aGUgdGV4dCB0byB0aGVcbiAgICAvLyBhcHByb3ByaWF0ZSBjb250YWluZXIuXG5cbiAgIC8vIEZpcnN0IGNoZWNrIGZvciBhIGxhenkgcGFyYWdyYXBoIGNvbnRpbnVhdGlvbjpcbiAgICBpZiAoIXRoaXMuYWxsQ2xvc2VkICYmICF0aGlzLmJsYW5rICYmXG4gICAgICAgIHRoaXMudGlwLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgIC8vIGxhenkgcGFyYWdyYXBoIGNvbnRpbnVhdGlvblxuICAgICAgICB0aGlzLmFkZExpbmUoKTtcblxuICAgIH0gZWxzZSB7IC8vIG5vdCBhIGxhenkgY29udGludWF0aW9uXG5cbiAgICAgICAgLy8gZmluYWxpemUgYW55IGJsb2NrcyBub3QgbWF0Y2hlZFxuICAgICAgICB0aGlzLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIGlmICh0aGlzLmJsYW5rICYmIGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5sYXN0Q2hpbGQuX2xhc3RMaW5lQmxhbmsgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdCA9IGNvbnRhaW5lci50eXBlO1xuXG4gICAgICAgIC8vIEJsb2NrIHF1b3RlIGxpbmVzIGFyZSBuZXZlciBibGFuayBhcyB0aGV5IHN0YXJ0IHdpdGggPlxuICAgICAgICAvLyBhbmQgd2UgZG9uJ3QgY291bnQgYmxhbmtzIGluIGZlbmNlZCBjb2RlIGZvciBwdXJwb3NlcyBvZiB0aWdodC9sb29zZVxuICAgICAgICAvLyBsaXN0cyBvciBicmVha2luZyBvdXQgb2YgbGlzdHMuICBXZSBhbHNvIGRvbid0IHNldCBfbGFzdExpbmVCbGFua1xuICAgICAgICAvLyBvbiBhbiBlbXB0eSBsaXN0IGl0ZW0sIG9yIGlmIHdlIGp1c3QgY2xvc2VkIGEgZmVuY2VkIGJsb2NrLlxuICAgICAgICB2YXIgbGFzdExpbmVCbGFuayA9IHRoaXMuYmxhbmsgJiZcbiAgICAgICAgICAgICEodCA9PT0gJ2Jsb2NrX3F1b3RlJyB8fFxuICAgICAgICAgICAgICAodCA9PT0gJ2NvZGVfYmxvY2snICYmIGNvbnRhaW5lci5faXNGZW5jZWQpIHx8XG4gICAgICAgICAgICAgICh0ID09PSAnaXRlbScgJiZcbiAgICAgICAgICAgICAgICFjb250YWluZXIuX2ZpcnN0Q2hpbGQgJiZcbiAgICAgICAgICAgICAgIGNvbnRhaW5lci5zb3VyY2Vwb3NbMF1bMF0gPT09IHRoaXMubGluZU51bWJlcikpO1xuXG4gICAgICAgIC8vIHByb3BhZ2F0ZSBsYXN0TGluZUJsYW5rIHVwIHRocm91Z2ggcGFyZW50czpcbiAgICAgICAgdmFyIGNvbnQgPSBjb250YWluZXI7XG4gICAgICAgIHdoaWxlIChjb250KSB7XG4gICAgICAgICAgICBjb250Ll9sYXN0TGluZUJsYW5rID0gbGFzdExpbmVCbGFuaztcbiAgICAgICAgICAgIGNvbnQgPSBjb250Ll9wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ibG9ja3NbdF0uYWNjZXB0c0xpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZExpbmUoKTtcbiAgICAgICAgICAgIC8vIGlmIEh0bWxCbG9jaywgY2hlY2sgZm9yIGVuZCBjb25kaXRpb25cbiAgICAgICAgICAgIGlmICh0ID09PSAnaHRtbF9ibG9jaycgJiZcbiAgICAgICAgICAgICAgICBjb250YWluZXIuX2h0bWxCbG9ja1R5cGUgPj0gMSAmJlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5faHRtbEJsb2NrVHlwZSA8PSA1ICYmXG4gICAgICAgICAgICAgICAgcmVIdG1sQmxvY2tDbG9zZVtjb250YWluZXIuX2h0bWxCbG9ja1R5cGVdLnRlc3QodGhpcy5jdXJyZW50TGluZS5zbGljZSh0aGlzLm9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShjb250YWluZXIsIHRoaXMubGluZU51bWJlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9mZnNldCA8IGxuLmxlbmd0aCAmJiAhdGhpcy5ibGFuaykge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHBhcmFncmFwaCBjb250YWluZXIgZm9yIGxpbmVcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuYWRkQ2hpbGQoJ3BhcmFncmFwaCcsIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgdGhpcy5hZGRMaW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IGxuLmxlbmd0aDtcbn07XG5cbi8vIEZpbmFsaXplIGEgYmxvY2suICBDbG9zZSBpdCBhbmQgZG8gYW55IG5lY2Vzc2FyeSBwb3N0cHJvY2Vzc2luZyxcbi8vIGUuZy4gY3JlYXRpbmcgc3RyaW5nX2NvbnRlbnQgZnJvbSBzdHJpbmdzLCBzZXR0aW5nIHRoZSAndGlnaHQnXG4vLyBvciAnbG9vc2UnIHN0YXR1cyBvZiBhIGxpc3QsIGFuZCBwYXJzaW5nIHRoZSBiZWdpbm5pbmdzXG4vLyBvZiBwYXJhZ3JhcGhzIGZvciByZWZlcmVuY2UgZGVmaW5pdGlvbnMuICBSZXNldCB0aGUgdGlwIHRvIHRoZVxuLy8gcGFyZW50IG9mIHRoZSBjbG9zZWQgYmxvY2suXG52YXIgZmluYWxpemUgPSBmdW5jdGlvbihibG9jaywgbGluZU51bWJlcikge1xuICAgIHZhciBhYm92ZSA9IGJsb2NrLl9wYXJlbnQ7XG4gICAgYmxvY2suX29wZW4gPSBmYWxzZTtcbiAgICBibG9jay5zb3VyY2Vwb3NbMV0gPSBbbGluZU51bWJlciwgdGhpcy5sYXN0TGluZUxlbmd0aF07XG5cbiAgICB0aGlzLmJsb2Nrc1tibG9jay50eXBlXS5maW5hbGl6ZSh0aGlzLCBibG9jayk7XG5cbiAgICB0aGlzLnRpcCA9IGFib3ZlO1xufTtcblxuLy8gV2FsayB0aHJvdWdoIGEgYmxvY2sgJiBjaGlsZHJlbiByZWN1cnNpdmVseSwgcGFyc2luZyBzdHJpbmcgY29udGVudFxuLy8gaW50byBpbmxpbmUgY29udGVudCB3aGVyZSBhcHByb3ByaWF0ZS5cbnZhciBwcm9jZXNzSW5saW5lcyA9IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgdmFyIG5vZGUsIGV2ZW50LCB0O1xuICAgIHZhciB3YWxrZXIgPSBibG9jay53YWxrZXIoKTtcbiAgICB0aGlzLmlubGluZVBhcnNlci5yZWZtYXAgPSB0aGlzLnJlZm1hcDtcbiAgICB0aGlzLmlubGluZVBhcnNlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICBub2RlID0gZXZlbnQubm9kZTtcbiAgICAgICAgdCA9IG5vZGUudHlwZTtcbiAgICAgICAgaWYgKCFldmVudC5lbnRlcmluZyAmJiAodCA9PT0gJ3BhcmFncmFwaCcgfHwgdCA9PT0gJ2hlYWRpbmcnKSkge1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIucGFyc2Uobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgRG9jdW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZG9jID0gbmV3IE5vZGUoJ2RvY3VtZW50JywgW1sxLCAxXSwgWzAsIDBdXSk7XG4gICAgcmV0dXJuIGRvYztcbn07XG5cbi8vIFRoZSBtYWluIHBhcnNpbmcgZnVuY3Rpb24uICBSZXR1cm5zIGEgcGFyc2VkIGRvY3VtZW50IEFTVC5cbnZhciBwYXJzZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdGhpcy5kb2MgPSBuZXcgRG9jdW1lbnQoKTtcbiAgICB0aGlzLnRpcCA9IHRoaXMuZG9jO1xuICAgIHRoaXMucmVmbWFwID0ge307XG4gICAgdGhpcy5saW5lTnVtYmVyID0gMDtcbiAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gMDtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSB0aGlzLmRvYztcbiAgICB0aGlzLmN1cnJlbnRMaW5lID0gXCJcIjtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpbWUpIHsgY29uc29sZS50aW1lKFwicHJlcGFyaW5nIGlucHV0XCIpOyB9XG4gICAgdmFyIGxpbmVzID0gaW5wdXQuc3BsaXQocmVMaW5lRW5kaW5nKTtcbiAgICB2YXIgbGVuID0gbGluZXMubGVuZ3RoO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpID09PSBDX05FV0xJTkUpIHtcbiAgICAgICAgLy8gaWdub3JlIGxhc3QgYmxhbmsgbGluZSBjcmVhdGVkIGJ5IGZpbmFsIG5ld2xpbmVcbiAgICAgICAgbGVuIC09IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudGltZSkgeyBjb25zb2xlLnRpbWVFbmQoXCJwcmVwYXJpbmcgaW5wdXRcIik7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRpbWUpIHsgY29uc29sZS50aW1lKFwiYmxvY2sgcGFyc2luZ1wiKTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5pbmNvcnBvcmF0ZUxpbmUobGluZXNbaV0pO1xuICAgIH1cbiAgICB3aGlsZSAodGhpcy50aXApIHtcbiAgICAgICAgdGhpcy5maW5hbGl6ZSh0aGlzLnRpcCwgbGVuKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aW1lKSB7IGNvbnNvbGUudGltZUVuZChcImJsb2NrIHBhcnNpbmdcIik7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRpbWUpIHsgY29uc29sZS50aW1lKFwiaW5saW5lIHBhcnNpbmdcIik7IH1cbiAgICB0aGlzLnByb2Nlc3NJbmxpbmVzKHRoaXMuZG9jKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpbWUpIHsgY29uc29sZS50aW1lRW5kKFwiaW5saW5lIHBhcnNpbmdcIik7IH1cbiAgICByZXR1cm4gdGhpcy5kb2M7XG59O1xuXG5cbi8vIFRoZSBQYXJzZXIgb2JqZWN0LlxuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpe1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvYzogbmV3IERvY3VtZW50KCksXG4gICAgICAgIGJsb2NrczogYmxvY2tzLFxuICAgICAgICBibG9ja1N0YXJ0czogYmxvY2tTdGFydHMsXG4gICAgICAgIHRpcDogdGhpcy5kb2MsXG4gICAgICAgIG9sZHRpcDogdGhpcy5kb2MsXG4gICAgICAgIGN1cnJlbnRMaW5lOiBcIlwiLFxuICAgICAgICBsaW5lTnVtYmVyOiAwLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgbmV4dE5vbnNwYWNlOiAwLFxuICAgICAgICBuZXh0Tm9uc3BhY2VDb2x1bW46IDAsXG4gICAgICAgIGluZGVudDogMCxcbiAgICAgICAgaW5kZW50ZWQ6IGZhbHNlLFxuICAgICAgICBibGFuazogZmFsc2UsXG4gICAgICAgIHBhcnRpYWxseUNvbnN1bWVkVGFiOiBmYWxzZSxcbiAgICAgICAgYWxsQ2xvc2VkOiB0cnVlLFxuICAgICAgICBsYXN0TWF0Y2hlZENvbnRhaW5lcjogdGhpcy5kb2MsXG4gICAgICAgIHJlZm1hcDoge30sXG4gICAgICAgIGxhc3RMaW5lTGVuZ3RoOiAwLFxuICAgICAgICBpbmxpbmVQYXJzZXI6IG5ldyBJbmxpbmVQYXJzZXIob3B0aW9ucyksXG4gICAgICAgIGZpbmROZXh0Tm9uc3BhY2U6IGZpbmROZXh0Tm9uc3BhY2UsXG4gICAgICAgIGFkdmFuY2VPZmZzZXQ6IGFkdmFuY2VPZmZzZXQsXG4gICAgICAgIGFkdmFuY2VOZXh0Tm9uc3BhY2U6IGFkdmFuY2VOZXh0Tm9uc3BhY2UsXG4gICAgICAgIGFkZExpbmU6IGFkZExpbmUsXG4gICAgICAgIGFkZENoaWxkOiBhZGRDaGlsZCxcbiAgICAgICAgaW5jb3Jwb3JhdGVMaW5lOiBpbmNvcnBvcmF0ZUxpbmUsXG4gICAgICAgIGZpbmFsaXplOiBmaW5hbGl6ZSxcbiAgICAgICAgcHJvY2Vzc0lubGluZXM6IHByb2Nlc3NJbmxpbmVzLFxuICAgICAgICBjbG9zZVVubWF0Y2hlZEJsb2NrczogY2xvc2VVbm1hdGNoZWRCbG9ja3MsXG4gICAgICAgIHBhcnNlOiBwYXJzZSxcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyB8fCB7fVxuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29tbW9ubWFyay9saWIvYmxvY2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgZW5jb2RlQ2FjaGUgPSB7fTtcblxuXG4vLyBDcmVhdGUgYSBsb29rdXAgYXJyYXkgd2hlcmUgYW55dGhpbmcgYnV0IGNoYXJhY3RlcnMgaW4gYGNoYXJzYCBzdHJpbmdcbi8vIGFuZCBhbHBoYW51bWVyaWMgY2hhcnMgaXMgcGVyY2VudC1lbmNvZGVkLlxuLy9cbmZ1bmN0aW9uIGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcblxuICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAvLyBhbHdheXMgYWxsb3cgdW5lbmNvZGVkIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCgnJScgKyAoJzAnICsgaS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICB2YXIgaSwgbCwgY29kZSwgbmV4dENvZGUsIGNhY2hlLFxuICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVuY29kZShzdHJpbmcsIGtlZXBFc2NhcGVkKVxuICAgIGtlZXBFc2NhcGVkICA9IGV4Y2x1ZGU7XG4gICAgZXhjbHVkZSA9IGVuY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBpZiAodHlwZW9mIGtlZXBFc2NhcGVkID09PSAndW5kZWZpbmVkJykge1xuICAgIGtlZXBFc2NhcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoa2VlcEVzY2FwZWQgJiYgY29kZSA9PT0gMHgyNSAvKiAlICovICYmIGkgKyAyIDwgbCkge1xuICAgICAgaWYgKC9eWzAtOWEtZl17Mn0kL2kudGVzdChzdHJpbmcuc2xpY2UoaSArIDEsIGkgKyAzKSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgIHJlc3VsdCArPSBjYWNoZVtjb2RlXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xuICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgaWYgKG5leHRDb2RlID49IDB4REMwMCAmJiBuZXh0Q29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9ICclRUYlQkYlQkQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZW5jb2RlLmRlZmF1bHRDaGFycyAgID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuZW5jb2RlLmNvbXBvbmVudENoYXJzID0gXCItXy4hfionKClcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21kdXJsL2VuY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4ndXNlIHN0cmljdCc7XG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG52YXIgZGVjb2RlQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSkge1xuICB2YXIgaSwgY2gsIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV07XG4gIGlmIChjYWNoZSkgeyByZXR1cm4gY2FjaGU7IH1cblxuICBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgIGNhY2hlLnB1c2goY2gpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjaCA9IGV4Y2x1ZGUuY2hhckNvZGVBdChpKTtcbiAgICBjYWNoZVtjaF0gPSAnJScgKyAoJzAnICsgY2gudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBEZWNvZGUgcGVyY2VudC1lbmNvZGVkIHN0cmluZy5cbi8vXG5mdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBleGNsdWRlKSB7XG4gIHZhciBjYWNoZTtcblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgZXhjbHVkZSA9IGRlY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBjYWNoZSA9IGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKCVbYS1mMC05XXsyfSkrL2dpLCBmdW5jdGlvbihzZXEpIHtcbiAgICB2YXIgaSwgbCwgYjEsIGIyLCBiMywgYjQsIGNocixcbiAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gc2VxLmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuICAgICAgYjEgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEsIGkgKyAzKSwgMTYpO1xuXG4gICAgICBpZiAoYjEgPCAweDgwKSB7XG4gICAgICAgIHJlc3VsdCArPSBjYWNoZVtiMV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhFMCkgPT09IDB4QzAgJiYgKGkgKyAzIDwgbCkpIHtcbiAgICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgNikgJiAweDdDMCkgfCAoYjIgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RjApID09PSAweEUwICYmIChpICsgNiA8IGwpKSB7XG4gICAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTIpICYgMHhGMDAwKSB8ICgoYjIgPDwgNikgJiAweEZDMCkgfCAoYjMgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwMCB8fCAoY2hyID49IDB4RDgwMCAmJiBjaHIgPD0gMHhERkZGKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGOCkgPT09IDB4RjAgJiYgKGkgKyA5IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMTEweHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG4gICAgICAgIGI0ID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxMCwgaSArIDEyKSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjQgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTgpICYgMHgxQzAwMDApIHwgKChiMiA8PCAxMikgJiAweDNGMDAwKSB8ICgoYjMgPDwgNikgJiAweEZDMCkgfCAoYjQgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDEwMDAwIHx8IGNociA+IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArIChjaHIgPj4gMTApLCAweERDMDAgKyAoY2hyICYgMHgzRkYpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkJztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn1cblxuXG5kZWNvZGUuZGVmYXVsdENoYXJzICAgPSAnOy8/OkAmPSskLCMnO1xuZGVjb2RlLmNvbXBvbmVudENoYXJzID0gJyc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZHVybC9kZWNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpbnZlcnNlWE1MID0gZ2V0SW52ZXJzZU9iaihyZXF1aXJlKFwiLi4vbWFwcy94bWwuanNvblwiKSksXG4gICAgeG1sUmVwbGFjZXIgPSBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZVhNTCk7XG5cbmV4cG9ydHMuWE1MID0gZ2V0SW52ZXJzZShpbnZlcnNlWE1MLCB4bWxSZXBsYWNlcik7XG5cbnZhciBpbnZlcnNlSFRNTCA9IGdldEludmVyc2VPYmoocmVxdWlyZShcIi4uL21hcHMvZW50aXRpZXMuanNvblwiKSksXG4gICAgaHRtbFJlcGxhY2VyID0gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VIVE1MKTtcblxuZXhwb3J0cy5IVE1MID0gZ2V0SW52ZXJzZShpbnZlcnNlSFRNTCwgaHRtbFJlcGxhY2VyKTtcblxuZnVuY3Rpb24gZ2V0SW52ZXJzZU9iaihvYmope1xuXHRyZXR1cm4gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uKGludmVyc2UsIG5hbWUpe1xuXHRcdGludmVyc2Vbb2JqW25hbWVdXSA9IFwiJlwiICsgbmFtZSArIFwiO1wiO1xuXHRcdHJldHVybiBpbnZlcnNlO1xuXHR9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlKXtcblx0dmFyIHNpbmdsZSA9IFtdLFxuXHQgICAgbXVsdGlwbGUgPSBbXTtcblxuXHRPYmplY3Qua2V5cyhpbnZlcnNlKS5mb3JFYWNoKGZ1bmN0aW9uKGspe1xuXHRcdGlmKGsubGVuZ3RoID09PSAxKXtcblx0XHRcdHNpbmdsZS5wdXNoKFwiXFxcXFwiICsgayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG11bHRpcGxlLnB1c2goayk7XG5cdFx0fVxuXHR9KTtcblxuXHQvL1RPRE8gYWRkIHJhbmdlc1xuXHRtdWx0aXBsZS51bnNoaWZ0KFwiW1wiICsgc2luZ2xlLmpvaW4oXCJcIikgKyBcIl1cIik7XG5cblx0cmV0dXJuIG5ldyBSZWdFeHAobXVsdGlwbGUuam9pbihcInxcIiksIFwiZ1wiKTtcbn1cblxudmFyIHJlX25vbkFTQ0lJID0gL1teXFwwLVxceDdGXS9nLFxuICAgIHJlX2FzdHJhbFN5bWJvbHMgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xuXG5mdW5jdGlvbiBzaW5nbGVDaGFyUmVwbGFjZXIoYyl7XG5cdHJldHVybiBcIiYjeFwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCI7XCI7XG59XG5cbmZ1bmN0aW9uIGFzdHJhbFJlcGxhY2VyKGMpe1xuXHQvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuXHR2YXIgaGlnaCA9IGMuY2hhckNvZGVBdCgwKTtcblx0dmFyIGxvdyAgPSBjLmNoYXJDb2RlQXQoMSk7XG5cdHZhciBjb2RlUG9pbnQgPSAoaGlnaCAtIDB4RDgwMCkgKiAweDQwMCArIGxvdyAtIDB4REMwMCArIDB4MTAwMDA7XG5cdHJldHVybiBcIiYjeFwiICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCI7XCI7XG59XG5cbmZ1bmN0aW9uIGdldEludmVyc2UoaW52ZXJzZSwgcmUpe1xuXHRmdW5jdGlvbiBmdW5jKG5hbWUpe1xuXHRcdHJldHVybiBpbnZlcnNlW25hbWVdO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGRhdGEpe1xuXHRcdHJldHVybiBkYXRhXG5cdFx0XHRcdC5yZXBsYWNlKHJlLCBmdW5jKVxuXHRcdFx0XHQucmVwbGFjZShyZV9hc3RyYWxTeW1ib2xzLCBhc3RyYWxSZXBsYWNlcilcblx0XHRcdFx0LnJlcGxhY2UocmVfbm9uQVNDSUksIHNpbmdsZUNoYXJSZXBsYWNlcik7XG5cdH07XG59XG5cbnZhciByZV94bWxDaGFycyA9IGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlWE1MKTtcblxuZnVuY3Rpb24gZXNjYXBlWE1MKGRhdGEpe1xuXHRyZXR1cm4gZGF0YVxuXHRcdFx0LnJlcGxhY2UocmVfeG1sQ2hhcnMsIHNpbmdsZUNoYXJSZXBsYWNlcilcblx0XHRcdC5yZXBsYWNlKHJlX2FzdHJhbFN5bWJvbHMsIGFzdHJhbFJlcGxhY2VyKVxuXHRcdFx0LnJlcGxhY2UocmVfbm9uQVNDSUksIHNpbmdsZUNoYXJSZXBsYWNlcik7XG59XG5cbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlWE1MO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZW50aXRpZXMvbGliL2VuY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVudGl0eU1hcCA9IHJlcXVpcmUoXCIuLi9tYXBzL2VudGl0aWVzLmpzb25cIiksXG4gICAgbGVnYWN5TWFwID0gcmVxdWlyZShcIi4uL21hcHMvbGVnYWN5Lmpzb25cIiksXG4gICAgeG1sTWFwICAgID0gcmVxdWlyZShcIi4uL21hcHMveG1sLmpzb25cIiksXG4gICAgZGVjb2RlQ29kZVBvaW50ID0gcmVxdWlyZShcIi4vZGVjb2RlX2NvZGVwb2ludC5qc1wiKTtcblxudmFyIGRlY29kZVhNTFN0cmljdCAgPSBnZXRTdHJpY3REZWNvZGVyKHhtbE1hcCksXG4gICAgZGVjb2RlSFRNTFN0cmljdCA9IGdldFN0cmljdERlY29kZXIoZW50aXR5TWFwKTtcblxuZnVuY3Rpb24gZ2V0U3RyaWN0RGVjb2RlcihtYXApe1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1hcCkuam9pbihcInxcIiksXG5cdCAgICByZXBsYWNlID0gZ2V0UmVwbGFjZXIobWFwKTtcblxuXHRrZXlzICs9IFwifCNbeFhdW1xcXFxkYS1mQS1GXSt8I1xcXFxkK1wiO1xuXG5cdHZhciByZSA9IG5ldyBSZWdFeHAoXCImKD86XCIgKyBrZXlzICsgXCIpO1wiLCBcImdcIik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHN0cil7XG5cdFx0cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocmUsIHJlcGxhY2UpO1xuXHR9O1xufVxuXG52YXIgZGVjb2RlSFRNTCA9IChmdW5jdGlvbigpe1xuXHR2YXIgbGVnYWN5ID0gT2JqZWN0LmtleXMobGVnYWN5TWFwKVxuXHRcdC5zb3J0KHNvcnRlcik7XG5cblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbnRpdHlNYXApXG5cdFx0LnNvcnQoc29ydGVyKTtcblxuXHRmb3IodmFyIGkgPSAwLCBqID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspe1xuXHRcdGlmKGxlZ2FjeVtqXSA9PT0ga2V5c1tpXSl7XG5cdFx0XHRrZXlzW2ldICs9IFwiOz9cIjtcblx0XHRcdGorKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0a2V5c1tpXSArPSBcIjtcIjtcblx0XHR9XG5cdH1cblxuXHR2YXIgcmUgPSBuZXcgUmVnRXhwKFwiJig/OlwiICsga2V5cy5qb2luKFwifFwiKSArIFwifCNbeFhdW1xcXFxkYS1mQS1GXSs7P3wjXFxcXGQrOz8pXCIsIFwiZ1wiKSxcblx0ICAgIHJlcGxhY2UgPSBnZXRSZXBsYWNlcihlbnRpdHlNYXApO1xuXG5cdGZ1bmN0aW9uIHJlcGxhY2VyKHN0cil7XG5cdFx0aWYoc3RyLnN1YnN0cigtMSkgIT09IFwiO1wiKSBzdHIgKz0gXCI7XCI7XG5cdFx0cmV0dXJuIHJlcGxhY2Uoc3RyKTtcblx0fVxuXG5cdC8vVE9ETyBjb25zaWRlciBjcmVhdGluZyBhIG1lcmdlZCBtYXBcblx0cmV0dXJuIGZ1bmN0aW9uKHN0cil7XG5cdFx0cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocmUsIHJlcGxhY2VyKTtcblx0fTtcbn0oKSk7XG5cbmZ1bmN0aW9uIHNvcnRlcihhLCBiKXtcblx0cmV0dXJuIGEgPCBiID8gMSA6IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRSZXBsYWNlcihtYXApe1xuXHRyZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShzdHIpe1xuXHRcdGlmKHN0ci5jaGFyQXQoMSkgPT09IFwiI1wiKXtcblx0XHRcdGlmKHN0ci5jaGFyQXQoMikgPT09IFwiWFwiIHx8IHN0ci5jaGFyQXQoMikgPT09IFwieFwiKXtcblx0XHRcdFx0cmV0dXJuIGRlY29kZUNvZGVQb2ludChwYXJzZUludChzdHIuc3Vic3RyKDMpLCAxNikpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRlY29kZUNvZGVQb2ludChwYXJzZUludChzdHIuc3Vic3RyKDIpLCAxMCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWFwW3N0ci5zbGljZSgxLCAtMSldO1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0WE1MOiBkZWNvZGVYTUxTdHJpY3QsXG5cdEhUTUw6IGRlY29kZUhUTUwsXG5cdEhUTUxTdHJpY3Q6IGRlY29kZUhUTUxTdHJpY3Rcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZW50aXRpZXMvbGliL2RlY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJBYWN1dGVcIjpcIsOBXCIsXCJhYWN1dGVcIjpcIsOhXCIsXCJBY2lyY1wiOlwiw4JcIixcImFjaXJjXCI6XCLDolwiLFwiYWN1dGVcIjpcIsK0XCIsXCJBRWxpZ1wiOlwiw4ZcIixcImFlbGlnXCI6XCLDplwiLFwiQWdyYXZlXCI6XCLDgFwiLFwiYWdyYXZlXCI6XCLDoFwiLFwiYW1wXCI6XCImXCIsXCJBTVBcIjpcIiZcIixcIkFyaW5nXCI6XCLDhVwiLFwiYXJpbmdcIjpcIsOlXCIsXCJBdGlsZGVcIjpcIsODXCIsXCJhdGlsZGVcIjpcIsOjXCIsXCJBdW1sXCI6XCLDhFwiLFwiYXVtbFwiOlwiw6RcIixcImJydmJhclwiOlwiwqZcIixcIkNjZWRpbFwiOlwiw4dcIixcImNjZWRpbFwiOlwiw6dcIixcImNlZGlsXCI6XCLCuFwiLFwiY2VudFwiOlwiwqJcIixcImNvcHlcIjpcIsKpXCIsXCJDT1BZXCI6XCLCqVwiLFwiY3VycmVuXCI6XCLCpFwiLFwiZGVnXCI6XCLCsFwiLFwiZGl2aWRlXCI6XCLDt1wiLFwiRWFjdXRlXCI6XCLDiVwiLFwiZWFjdXRlXCI6XCLDqVwiLFwiRWNpcmNcIjpcIsOKXCIsXCJlY2lyY1wiOlwiw6pcIixcIkVncmF2ZVwiOlwiw4hcIixcImVncmF2ZVwiOlwiw6hcIixcIkVUSFwiOlwiw5BcIixcImV0aFwiOlwiw7BcIixcIkV1bWxcIjpcIsOLXCIsXCJldW1sXCI6XCLDq1wiLFwiZnJhYzEyXCI6XCLCvVwiLFwiZnJhYzE0XCI6XCLCvFwiLFwiZnJhYzM0XCI6XCLCvlwiLFwiZ3RcIjpcIj5cIixcIkdUXCI6XCI+XCIsXCJJYWN1dGVcIjpcIsONXCIsXCJpYWN1dGVcIjpcIsOtXCIsXCJJY2lyY1wiOlwiw45cIixcImljaXJjXCI6XCLDrlwiLFwiaWV4Y2xcIjpcIsKhXCIsXCJJZ3JhdmVcIjpcIsOMXCIsXCJpZ3JhdmVcIjpcIsOsXCIsXCJpcXVlc3RcIjpcIsK/XCIsXCJJdW1sXCI6XCLDj1wiLFwiaXVtbFwiOlwiw69cIixcImxhcXVvXCI6XCLCq1wiLFwibHRcIjpcIjxcIixcIkxUXCI6XCI8XCIsXCJtYWNyXCI6XCLCr1wiLFwibWljcm9cIjpcIsK1XCIsXCJtaWRkb3RcIjpcIsK3XCIsXCJuYnNwXCI6XCLCoFwiLFwibm90XCI6XCLCrFwiLFwiTnRpbGRlXCI6XCLDkVwiLFwibnRpbGRlXCI6XCLDsVwiLFwiT2FjdXRlXCI6XCLDk1wiLFwib2FjdXRlXCI6XCLDs1wiLFwiT2NpcmNcIjpcIsOUXCIsXCJvY2lyY1wiOlwiw7RcIixcIk9ncmF2ZVwiOlwiw5JcIixcIm9ncmF2ZVwiOlwiw7JcIixcIm9yZGZcIjpcIsKqXCIsXCJvcmRtXCI6XCLCulwiLFwiT3NsYXNoXCI6XCLDmFwiLFwib3NsYXNoXCI6XCLDuFwiLFwiT3RpbGRlXCI6XCLDlVwiLFwib3RpbGRlXCI6XCLDtVwiLFwiT3VtbFwiOlwiw5ZcIixcIm91bWxcIjpcIsO2XCIsXCJwYXJhXCI6XCLCtlwiLFwicGx1c21uXCI6XCLCsVwiLFwicG91bmRcIjpcIsKjXCIsXCJxdW90XCI6XCJcXFwiXCIsXCJRVU9UXCI6XCJcXFwiXCIsXCJyYXF1b1wiOlwiwrtcIixcInJlZ1wiOlwiwq5cIixcIlJFR1wiOlwiwq5cIixcInNlY3RcIjpcIsKnXCIsXCJzaHlcIjpcIsKtXCIsXCJzdXAxXCI6XCLCuVwiLFwic3VwMlwiOlwiwrJcIixcInN1cDNcIjpcIsKzXCIsXCJzemxpZ1wiOlwiw59cIixcIlRIT1JOXCI6XCLDnlwiLFwidGhvcm5cIjpcIsO+XCIsXCJ0aW1lc1wiOlwiw5dcIixcIlVhY3V0ZVwiOlwiw5pcIixcInVhY3V0ZVwiOlwiw7pcIixcIlVjaXJjXCI6XCLDm1wiLFwidWNpcmNcIjpcIsO7XCIsXCJVZ3JhdmVcIjpcIsOZXCIsXCJ1Z3JhdmVcIjpcIsO5XCIsXCJ1bWxcIjpcIsKoXCIsXCJVdW1sXCI6XCLDnFwiLFwidXVtbFwiOlwiw7xcIixcIllhY3V0ZVwiOlwiw51cIixcInlhY3V0ZVwiOlwiw71cIixcInllblwiOlwiwqVcIixcInl1bWxcIjpcIsO/XCJ9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZW50aXRpZXMvbWFwcy9sZWdhY3kuanNvblxuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlY29kZU1hcCA9IHJlcXVpcmUoXCIuLi9tYXBzL2RlY29kZS5qc29uXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZUNvZGVQb2ludDtcblxuLy8gbW9kaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9oZS9ibG9iL21hc3Rlci9zcmMvaGUuanMjTDk0LUwxMTlcbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludChjb2RlUG9pbnQpe1xuXG5cdGlmKChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHx8IGNvZGVQb2ludCA+IDB4MTBGRkZGKXtcblx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdH1cblxuXHRpZihjb2RlUG9pbnQgaW4gZGVjb2RlTWFwKXtcblx0XHRjb2RlUG9pbnQgPSBkZWNvZGVNYXBbY29kZVBvaW50XTtcblx0fVxuXG5cdHZhciBvdXRwdXQgPSBcIlwiO1xuXG5cdGlmKGNvZGVQb2ludCA+IDB4RkZGRil7XG5cdFx0Y29kZVBvaW50IC09IDB4MTAwMDA7XG5cdFx0b3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcblx0fVxuXG5cdG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZGVjb2RlX2NvZGVwb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCIwXCI6NjU1MzMsXCIxMjhcIjo4MzY0LFwiMTMwXCI6ODIxOCxcIjEzMVwiOjQwMixcIjEzMlwiOjgyMjIsXCIxMzNcIjo4MjMwLFwiMTM0XCI6ODIyNCxcIjEzNVwiOjgyMjUsXCIxMzZcIjo3MTAsXCIxMzdcIjo4MjQwLFwiMTM4XCI6MzUyLFwiMTM5XCI6ODI0OSxcIjE0MFwiOjMzOCxcIjE0MlwiOjM4MSxcIjE0NVwiOjgyMTYsXCIxNDZcIjo4MjE3LFwiMTQ3XCI6ODIyMCxcIjE0OFwiOjgyMjEsXCIxNDlcIjo4MjI2LFwiMTUwXCI6ODIxMSxcIjE1MVwiOjgyMTIsXCIxNTJcIjo3MzIsXCIxNTNcIjo4NDgyLFwiMTU0XCI6MzUzLFwiMTU1XCI6ODI1MCxcIjE1NlwiOjMzOSxcIjE1OFwiOjM4MixcIjE1OVwiOjM3Nn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbnRpdGllcy9tYXBzL2RlY29kZS5qc29uXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXJlZmVyZW5jZScpO1xuXG52YXIgbm9ybWFsaXplVVJJID0gY29tbW9uLm5vcm1hbGl6ZVVSSTtcbnZhciB1bmVzY2FwZVN0cmluZyA9IGNvbW1vbi51bmVzY2FwZVN0cmluZztcbnZhciBmcm9tQ29kZVBvaW50ID0gcmVxdWlyZSgnLi9mcm9tLWNvZGUtcG9pbnQuanMnKTtcbnZhciBkZWNvZGVIVE1MID0gcmVxdWlyZSgnZW50aXRpZXMnKS5kZWNvZGVIVE1MO1xucmVxdWlyZSgnc3RyaW5nLnByb3RvdHlwZS5yZXBlYXQnKTsgLy8gUG9seWZpbGwgZm9yIFN0cmluZy5wcm90b3R5cGUucmVwZWF0XG5cbi8vIENvbnN0YW50cyBmb3IgY2hhcmFjdGVyIGNvZGVzOlxuXG52YXIgQ19ORVdMSU5FID0gMTA7XG52YXIgQ19BU1RFUklTSyA9IDQyO1xudmFyIENfVU5ERVJTQ09SRSA9IDk1O1xudmFyIENfQkFDS1RJQ0sgPSA5NjtcbnZhciBDX09QRU5fQlJBQ0tFVCA9IDkxO1xudmFyIENfQ0xPU0VfQlJBQ0tFVCA9IDkzO1xudmFyIENfTEVTU1RIQU4gPSA2MDtcbnZhciBDX0JBTkcgPSAzMztcbnZhciBDX0JBQ0tTTEFTSCA9IDkyO1xudmFyIENfQU1QRVJTQU5EID0gMzg7XG52YXIgQ19PUEVOX1BBUkVOID0gNDA7XG52YXIgQ19DTE9TRV9QQVJFTiA9IDQxO1xudmFyIENfQ09MT04gPSA1ODtcbnZhciBDX1NJTkdMRVFVT1RFID0gMzk7XG52YXIgQ19ET1VCTEVRVU9URSA9IDM0O1xuXG4vLyBTb21lIHJlZ2V4cHMgdXNlZCBpbiBpbmxpbmUgcGFyc2VyOlxuXG52YXIgRVNDQVBBQkxFID0gY29tbW9uLkVTQ0FQQUJMRTtcbnZhciBFU0NBUEVEX0NIQVIgPSAnXFxcXFxcXFwnICsgRVNDQVBBQkxFO1xuXG52YXIgRU5USVRZID0gY29tbW9uLkVOVElUWTtcbnZhciByZUh0bWxUYWcgPSBjb21tb24ucmVIdG1sVGFnO1xuXG52YXIgcmVQdW5jdHVhdGlvbiA9IG5ldyBSZWdFeHAoL1shXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXl9ge3x9flxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNDJcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOVxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwNVtcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REYzQy1cXHVERjNFXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XXxcXHVEODJGXFx1REM5RnxcXHVEODM2W1xcdURFODctXFx1REU4Ql0vKTtcblxudmFyIHJlTGlua1RpdGxlID0gbmV3IFJlZ0V4cChcbiAgICAnXig/OlwiKCcgKyBFU0NBUEVEX0NIQVIgKyAnfFteXCJcXFxceDAwXSkqXCInICtcbiAgICAgICAgJ3wnICtcbiAgICAgICAgJ1xcJygnICsgRVNDQVBFRF9DSEFSICsgJ3xbXlxcJ1xcXFx4MDBdKSpcXCcnICtcbiAgICAgICAgJ3wnICtcbiAgICAgICAgJ1xcXFwoKCcgKyBFU0NBUEVEX0NIQVIgKyAnfFteKVxcXFx4MDBdKSpcXFxcKSknKTtcblxudmFyIHJlTGlua0Rlc3RpbmF0aW9uQnJhY2VzID0gbmV3IFJlZ0V4cChcbiAgICAnXig/Ols8XSg/OlteIDw+XFxcXHRcXFxcblxcXFxcXFxcXFxcXHgwMF0nICsgJ3wnICsgRVNDQVBFRF9DSEFSICsgJ3wnICsgJ1xcXFxcXFxcKSpbPl0pJyk7XG5cbnZhciByZUVzY2FwYWJsZSA9IG5ldyBSZWdFeHAoJ14nICsgRVNDQVBBQkxFKTtcblxudmFyIHJlRW50aXR5SGVyZSA9IG5ldyBSZWdFeHAoJ14nICsgRU5USVRZLCAnaScpO1xuXG52YXIgcmVUaWNrcyA9IC9gKy87XG5cbnZhciByZVRpY2tzSGVyZSA9IC9eYCsvO1xuXG52YXIgcmVFbGxpcHNlcyA9IC9cXC5cXC5cXC4vZztcblxudmFyIHJlRGFzaCA9IC8tLSsvZztcblxudmFyIHJlRW1haWxBdXRvbGluayA9IC9ePChbYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqKT4vO1xuXG52YXIgcmVBdXRvbGluayA9IC9ePFtBLVphLXpdW0EtWmEtejAtOS4rLV17MSwzMX06W148PlxceDAwLVxceDIwXSo+L2k7XG5cbnZhciByZVNwbmwgPSAvXiAqKD86XFxuICopPy87XG5cbnZhciByZVdoaXRlc3BhY2VDaGFyID0gL15bIFxcdFxcblxceDBiXFx4MGNcXHgwZF0vO1xuXG52YXIgcmVXaGl0ZXNwYWNlID0gL1sgXFx0XFxuXFx4MGJcXHgwY1xceDBkXSsvZztcblxudmFyIHJlVW5pY29kZVdoaXRlc3BhY2VDaGFyID0gL15cXHMvO1xuXG52YXIgcmVGaW5hbFNwYWNlID0gLyAqJC87XG5cbnZhciByZUluaXRpYWxTcGFjZSA9IC9eICovO1xuXG52YXIgcmVTcGFjZUF0RW5kT2ZMaW5lID0gL14gKig/OlxcbnwkKS87XG5cbnZhciByZUxpbmtMYWJlbCA9IG5ldyBSZWdFeHAoJ15cXFxcWyg/OlteXFxcXFxcXFxcXFxcW1xcXFxdXXwnICsgRVNDQVBFRF9DSEFSICtcbiAgJ3xcXFxcXFxcXCl7MCwxMDAwfVxcXFxdJyk7XG5cbi8vIE1hdGNoZXMgYSBzdHJpbmcgb2Ygbm9uLXNwZWNpYWwgY2hhcmFjdGVycy5cbnZhciByZU1haW4gPSAvXlteXFxuYFxcW1xcXVxcXFwhPCYqXydcIl0rL207XG5cbnZhciB0ZXh0ID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBub2RlID0gbmV3IE5vZGUoJ3RleHQnKTtcbiAgICBub2RlLl9saXRlcmFsID0gcztcbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbi8vIElOTElORSBQQVJTRVJcblxuLy8gVGhlc2UgYXJlIG1ldGhvZHMgb2YgYW4gSW5saW5lUGFyc2VyIG9iamVjdCwgZGVmaW5lZCBiZWxvdy5cbi8vIEFuIElubGluZVBhcnNlciBrZWVwcyB0cmFjayBvZiBhIHN1YmplY3QgKGEgc3RyaW5nIHRvIGJlXG4vLyBwYXJzZWQpIGFuZCBhIHBvc2l0aW9uIGluIHRoYXQgc3ViamVjdC5cblxuLy8gSWYgcmUgbWF0Y2hlcyBhdCBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBzdWJqZWN0LCBhZHZhbmNlXG4vLyBwb3NpdGlvbiBpbiBzdWJqZWN0IGFuZCByZXR1cm4gdGhlIG1hdGNoOyBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG52YXIgbWF0Y2ggPSBmdW5jdGlvbihyZSkge1xuICAgIHZhciBtID0gcmUuZXhlYyh0aGlzLnN1YmplY3Quc2xpY2UodGhpcy5wb3MpKTtcbiAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBvcyArPSBtLmluZGV4ICsgbVswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBtWzBdO1xuICAgIH1cbn07XG5cbi8vIFJldHVybnMgdGhlIGNvZGUgZm9yIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIGN1cnJlbnQgc3ViamVjdCBwb3NpdGlvbiwgb3IgLTFcbi8vIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMuXG52YXIgcGVlayA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3ViamVjdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufTtcblxuLy8gUGFyc2UgemVybyBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBhdCBtb3N0IG9uZSBuZXdsaW5lXG52YXIgc3BubCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWF0Y2gocmVTcG5sKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEFsbCBvZiB0aGUgcGFyc2VycyBiZWxvdyB0cnkgdG8gbWF0Y2ggc29tZXRoaW5nIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXG4vLyBpbiB0aGUgc3ViamVjdC4gIElmIHRoZXkgc3VjY2VlZCBpbiBtYXRjaGluZyBhbnl0aGluZywgdGhleVxuLy8gcmV0dXJuIHRoZSBpbmxpbmUgbWF0Y2hlZCwgYWR2YW5jaW5nIHRoZSBzdWJqZWN0LlxuXG4vLyBBdHRlbXB0IHRvIHBhcnNlIGJhY2t0aWNrcywgYWRkaW5nIGVpdGhlciBhIGJhY2t0aWNrIGNvZGUgc3BhbiBvciBhXG4vLyBsaXRlcmFsIHNlcXVlbmNlIG9mIGJhY2t0aWNrcy5cbnZhciBwYXJzZUJhY2t0aWNrcyA9IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgdmFyIHRpY2tzID0gdGhpcy5tYXRjaChyZVRpY2tzSGVyZSk7XG4gICAgaWYgKHRpY2tzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGFmdGVyT3BlblRpY2tzID0gdGhpcy5wb3M7XG4gICAgdmFyIG1hdGNoZWQ7XG4gICAgdmFyIG5vZGU7XG4gICAgd2hpbGUgKChtYXRjaGVkID0gdGhpcy5tYXRjaChyZVRpY2tzKSkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG1hdGNoZWQgPT09IHRpY2tzKSB7XG4gICAgICAgICAgICBub2RlID0gbmV3IE5vZGUoJ2NvZGUnKTtcbiAgICAgICAgICAgIG5vZGUuX2xpdGVyYWwgPSB0aGlzLnN1YmplY3Quc2xpY2UoYWZ0ZXJPcGVuVGlja3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgLSB0aWNrcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKCkucmVwbGFjZShyZVdoaXRlc3BhY2UsICcgJyk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlIGdvdCBoZXJlLCB3ZSBkaWRuJ3QgbWF0Y2ggYSBjbG9zaW5nIGJhY2t0aWNrIHNlcXVlbmNlLlxuICAgIHRoaXMucG9zID0gYWZ0ZXJPcGVuVGlja3M7XG4gICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCh0aWNrcykpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8gUGFyc2UgYSBiYWNrc2xhc2gtZXNjYXBlZCBzcGVjaWFsIGNoYXJhY3RlciwgYWRkaW5nIGVpdGhlciB0aGUgZXNjYXBlZFxuLy8gY2hhcmFjdGVyLCBhIGhhcmQgbGluZSBicmVhayAoaWYgdGhlIGJhY2tzbGFzaCBpcyBmb2xsb3dlZCBieSBhIG5ld2xpbmUpLFxuLy8gb3IgYSBsaXRlcmFsIGJhY2tzbGFzaCB0byB0aGUgYmxvY2sncyBjaGlsZHJlbi4gIEFzc3VtZXMgY3VycmVudCBjaGFyYWN0ZXJcbi8vIGlzIGEgYmFja3NsYXNoLlxudmFyIHBhcnNlQmFja3NsYXNoID0gZnVuY3Rpb24oYmxvY2spIHtcbiAgICB2YXIgc3ViaiA9IHRoaXMuc3ViamVjdDtcbiAgICB2YXIgbm9kZTtcbiAgICB0aGlzLnBvcyArPSAxO1xuICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19ORVdMSU5FKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIG5vZGUgPSBuZXcgTm9kZSgnbGluZWJyZWFrJyk7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAocmVFc2NhcGFibGUudGVzdChzdWJqLmNoYXJBdCh0aGlzLnBvcykpKSB7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQoc3Viai5jaGFyQXQodGhpcy5wb3MpKSk7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCgnXFxcXCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBBdHRlbXB0IHRvIHBhcnNlIGFuIGF1dG9saW5rIChVUkwgb3IgZW1haWwgaW4gcG9pbnR5IGJyYWNrZXRzKS5cbnZhciBwYXJzZUF1dG9saW5rID0gZnVuY3Rpb24oYmxvY2spIHtcbiAgICB2YXIgbTtcbiAgICB2YXIgZGVzdDtcbiAgICB2YXIgbm9kZTtcbiAgICBpZiAoKG0gPSB0aGlzLm1hdGNoKHJlRW1haWxBdXRvbGluaykpKSB7XG4gICAgICAgIGRlc3QgPSBtLnNsaWNlKDEsIG0ubGVuZ3RoIC0gMSk7XG4gICAgICAgIG5vZGUgPSBuZXcgTm9kZSgnbGluaycpO1xuICAgICAgICBub2RlLl9kZXN0aW5hdGlvbiA9IG5vcm1hbGl6ZVVSSSgnbWFpbHRvOicgKyBkZXN0KTtcbiAgICAgICAgbm9kZS5fdGl0bGUgPSAnJztcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0ZXh0KGRlc3QpKTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoKG0gPSB0aGlzLm1hdGNoKHJlQXV0b2xpbmspKSkge1xuICAgICAgICBkZXN0ID0gbS5zbGljZSgxLCBtLmxlbmd0aCAtIDEpO1xuICAgICAgICBub2RlID0gbmV3IE5vZGUoJ2xpbmsnKTtcbiAgICAgICAgbm9kZS5fZGVzdGluYXRpb24gPSBub3JtYWxpemVVUkkoZGVzdCk7XG4gICAgICAgIG5vZGUuX3RpdGxlID0gJyc7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dChkZXN0KSk7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuLy8gQXR0ZW1wdCB0byBwYXJzZSBhIHJhdyBIVE1MIHRhZy5cbnZhciBwYXJzZUh0bWxUYWcgPSBmdW5jdGlvbihibG9jaykge1xuICAgIHZhciBtID0gdGhpcy5tYXRjaChyZUh0bWxUYWcpO1xuICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKCdodG1sX2lubGluZScpO1xuICAgICAgICBub2RlLl9saXRlcmFsID0gbTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5cbi8vIFNjYW4gYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHdpdGggY29kZSBjYywgYW5kIHJldHVybiBpbmZvcm1hdGlvbiBhYm91dFxuLy8gdGhlIG51bWJlciBvZiBkZWxpbWl0ZXJzIGFuZCB3aGV0aGVyIHRoZXkgYXJlIHBvc2l0aW9uZWQgc3VjaCB0aGF0XG4vLyB0aGV5IGNhbiBvcGVuIGFuZC9vciBjbG9zZSBlbXBoYXNpcyBvciBzdHJvbmcgZW1waGFzaXMuICBBIHV0aWxpdHlcbi8vIGZ1bmN0aW9uIGZvciBzdHJvbmcvZW1waCBwYXJzaW5nLlxudmFyIHNjYW5EZWxpbXMgPSBmdW5jdGlvbihjYykge1xuICAgIHZhciBudW1kZWxpbXMgPSAwO1xuICAgIHZhciBjaGFyX2JlZm9yZSwgY2hhcl9hZnRlciwgY2NfYWZ0ZXI7XG4gICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgdmFyIGxlZnRfZmxhbmtpbmcsIHJpZ2h0X2ZsYW5raW5nLCBjYW5fb3BlbiwgY2FuX2Nsb3NlO1xuICAgIHZhciBhZnRlcl9pc193aGl0ZXNwYWNlLCBhZnRlcl9pc19wdW5jdHVhdGlvbiwgYmVmb3JlX2lzX3doaXRlc3BhY2UsIGJlZm9yZV9pc19wdW5jdHVhdGlvbjtcblxuICAgIGlmIChjYyA9PT0gQ19TSU5HTEVRVU9URSB8fCBjYyA9PT0gQ19ET1VCTEVRVU9URSkge1xuICAgICAgICBudW1kZWxpbXMrKztcbiAgICAgICAgdGhpcy5wb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09IGNjKSB7XG4gICAgICAgICAgICBudW1kZWxpbXMrKztcbiAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobnVtZGVsaW1zID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNoYXJfYmVmb3JlID0gc3RhcnRwb3MgPT09IDAgPyAnXFxuJyA6IHRoaXMuc3ViamVjdC5jaGFyQXQoc3RhcnRwb3MgLSAxKTtcblxuICAgIGNjX2FmdGVyID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKGNjX2FmdGVyID09PSAtMSkge1xuICAgICAgICBjaGFyX2FmdGVyID0gJ1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hhcl9hZnRlciA9IGZyb21Db2RlUG9pbnQoY2NfYWZ0ZXIpO1xuICAgIH1cblxuICAgIGFmdGVyX2lzX3doaXRlc3BhY2UgPSByZVVuaWNvZGVXaGl0ZXNwYWNlQ2hhci50ZXN0KGNoYXJfYWZ0ZXIpO1xuICAgIGFmdGVyX2lzX3B1bmN0dWF0aW9uID0gcmVQdW5jdHVhdGlvbi50ZXN0KGNoYXJfYWZ0ZXIpO1xuICAgIGJlZm9yZV9pc193aGl0ZXNwYWNlID0gcmVVbmljb2RlV2hpdGVzcGFjZUNoYXIudGVzdChjaGFyX2JlZm9yZSk7XG4gICAgYmVmb3JlX2lzX3B1bmN0dWF0aW9uID0gcmVQdW5jdHVhdGlvbi50ZXN0KGNoYXJfYmVmb3JlKTtcblxuICAgIGxlZnRfZmxhbmtpbmcgPSAhYWZ0ZXJfaXNfd2hpdGVzcGFjZSAmJlxuICAgICAgICAgICAgKCFhZnRlcl9pc19wdW5jdHVhdGlvbiB8fCBiZWZvcmVfaXNfd2hpdGVzcGFjZSB8fCBiZWZvcmVfaXNfcHVuY3R1YXRpb24pO1xuICAgIHJpZ2h0X2ZsYW5raW5nID0gIWJlZm9yZV9pc193aGl0ZXNwYWNlICYmXG4gICAgICAgICAgICAoIWJlZm9yZV9pc19wdW5jdHVhdGlvbiB8fCBhZnRlcl9pc193aGl0ZXNwYWNlIHx8IGFmdGVyX2lzX3B1bmN0dWF0aW9uKTtcbiAgICBpZiAoY2MgPT09IENfVU5ERVJTQ09SRSkge1xuICAgICAgICBjYW5fb3BlbiA9IGxlZnRfZmxhbmtpbmcgJiZcbiAgICAgICAgICAgICghcmlnaHRfZmxhbmtpbmcgfHwgYmVmb3JlX2lzX3B1bmN0dWF0aW9uKTtcbiAgICAgICAgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmcgJiZcbiAgICAgICAgICAgICghbGVmdF9mbGFua2luZyB8fCBhZnRlcl9pc19wdW5jdHVhdGlvbik7XG4gICAgfSBlbHNlIGlmIChjYyA9PT0gQ19TSU5HTEVRVU9URSB8fCBjYyA9PT0gQ19ET1VCTEVRVU9URSkge1xuICAgICAgICBjYW5fb3BlbiA9IGxlZnRfZmxhbmtpbmcgJiYgIXJpZ2h0X2ZsYW5raW5nO1xuICAgICAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYW5fb3BlbiA9IGxlZnRfZmxhbmtpbmc7XG4gICAgICAgIGNhbl9jbG9zZSA9IHJpZ2h0X2ZsYW5raW5nO1xuICAgIH1cbiAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgIHJldHVybiB7IG51bWRlbGltczogbnVtZGVsaW1zLFxuICAgICAgICAgICAgIGNhbl9vcGVuOiBjYW5fb3BlbixcbiAgICAgICAgICAgICBjYW5fY2xvc2U6IGNhbl9jbG9zZSB9O1xufTtcblxuLy8gSGFuZGxlIGEgZGVsaW1pdGVyIG1hcmtlciBmb3IgZW1waGFzaXMgb3IgYSBxdW90ZS5cbnZhciBoYW5kbGVEZWxpbSA9IGZ1bmN0aW9uKGNjLCBibG9jaykge1xuICAgIHZhciByZXMgPSB0aGlzLnNjYW5EZWxpbXMoY2MpO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG51bWRlbGltcyA9IHJlcy5udW1kZWxpbXM7XG4gICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgdmFyIGNvbnRlbnRzO1xuXG4gICAgdGhpcy5wb3MgKz0gbnVtZGVsaW1zO1xuICAgIGlmIChjYyA9PT0gQ19TSU5HTEVRVU9URSkge1xuICAgICAgICBjb250ZW50cyA9IFwiXFx1MjAxOVwiO1xuICAgIH0gZWxzZSBpZiAoY2MgPT09IENfRE9VQkxFUVVPVEUpIHtcbiAgICAgICAgY29udGVudHMgPSBcIlxcdTIwMUNcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50cyA9IHRoaXMuc3ViamVjdC5zbGljZShzdGFydHBvcywgdGhpcy5wb3MpO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IHRleHQoY29udGVudHMpO1xuICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuXG4gICAgLy8gQWRkIGVudHJ5IHRvIHN0YWNrIGZvciB0aGlzIG9wZW5lclxuICAgIHRoaXMuZGVsaW1pdGVycyA9IHsgY2M6IGNjLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtZGVsaW1zOiBudW1kZWxpbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnZGVsaW1zOiBudW1kZWxpbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXM6IHRoaXMuZGVsaW1pdGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5fb3BlbjogcmVzLmNhbl9vcGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuX2Nsb3NlOiByZXMuY2FuX2Nsb3NlIH07XG4gICAgaWYgKHRoaXMuZGVsaW1pdGVycy5wcmV2aW91cyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRlbGltaXRlcnMucHJldmlvdXMubmV4dCA9IHRoaXMuZGVsaW1pdGVycztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxufTtcblxudmFyIHJlbW92ZURlbGltaXRlciA9IGZ1bmN0aW9uKGRlbGltKSB7XG4gICAgaWYgKGRlbGltLnByZXZpb3VzICE9PSBudWxsKSB7XG4gICAgICAgIGRlbGltLnByZXZpb3VzLm5leHQgPSBkZWxpbS5uZXh0O1xuICAgIH1cbiAgICBpZiAoZGVsaW0ubmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAvLyB0b3Agb2Ygc3RhY2tcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gZGVsaW0ucHJldmlvdXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVsaW0ubmV4dC5wcmV2aW91cyA9IGRlbGltLnByZXZpb3VzO1xuICAgIH1cbn07XG5cbnZhciByZW1vdmVEZWxpbWl0ZXJzQmV0d2VlbiA9IGZ1bmN0aW9uKGJvdHRvbSwgdG9wKSB7XG4gICAgaWYgKGJvdHRvbS5uZXh0ICE9PSB0b3ApIHtcbiAgICAgICAgYm90dG9tLm5leHQgPSB0b3A7XG4gICAgICAgIHRvcC5wcmV2aW91cyA9IGJvdHRvbTtcbiAgICB9XG59O1xuXG52YXIgcHJvY2Vzc0VtcGhhc2lzID0gZnVuY3Rpb24oc3RhY2tfYm90dG9tKSB7XG4gICAgdmFyIG9wZW5lciwgY2xvc2VyLCBvbGRfY2xvc2VyO1xuICAgIHZhciBvcGVuZXJfaW5sLCBjbG9zZXJfaW5sO1xuICAgIHZhciB0ZW1wc3RhY2s7XG4gICAgdmFyIHVzZV9kZWxpbXM7XG4gICAgdmFyIHRtcCwgbmV4dDtcbiAgICB2YXIgb3BlbmVyX2ZvdW5kO1xuICAgIHZhciBvcGVuZXJzX2JvdHRvbSA9IFtdO1xuICAgIHZhciBvZGRfbWF0Y2ggPSBmYWxzZTtcblxuICAgIG9wZW5lcnNfYm90dG9tW0NfVU5ERVJTQ09SRV0gPSBzdGFja19ib3R0b207XG4gICAgb3BlbmVyc19ib3R0b21bQ19BU1RFUklTS10gPSBzdGFja19ib3R0b207XG4gICAgb3BlbmVyc19ib3R0b21bQ19TSU5HTEVRVU9URV0gPSBzdGFja19ib3R0b207XG4gICAgb3BlbmVyc19ib3R0b21bQ19ET1VCTEVRVU9URV0gPSBzdGFja19ib3R0b207XG5cbiAgICAvLyBmaW5kIGZpcnN0IGNsb3NlciBhYm92ZSBzdGFja19ib3R0b206XG4gICAgY2xvc2VyID0gdGhpcy5kZWxpbWl0ZXJzO1xuICAgIHdoaWxlIChjbG9zZXIgIT09IG51bGwgJiYgY2xvc2VyLnByZXZpb3VzICE9PSBzdGFja19ib3R0b20pIHtcbiAgICAgICAgY2xvc2VyID0gY2xvc2VyLnByZXZpb3VzO1xuICAgIH1cbiAgICAvLyBtb3ZlIGZvcndhcmQsIGxvb2tpbmcgZm9yIGNsb3NlcnMsIGFuZCBoYW5kbGluZyBlYWNoXG4gICAgd2hpbGUgKGNsb3NlciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2xvc2VyY2MgPSBjbG9zZXIuY2M7XG4gICAgICAgIGlmICghY2xvc2VyLmNhbl9jbG9zZSkge1xuICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmb3VuZCBlbXBoYXNpcyBjbG9zZXIuIG5vdyBsb29rIGJhY2sgZm9yIGZpcnN0IG1hdGNoaW5nIG9wZW5lcjpcbiAgICAgICAgICAgIG9wZW5lciA9IGNsb3Nlci5wcmV2aW91cztcbiAgICAgICAgICAgIG9wZW5lcl9mb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKG9wZW5lciAhPT0gbnVsbCAmJiBvcGVuZXIgIT09IHN0YWNrX2JvdHRvbSAmJlxuICAgICAgICAgICAgICAgICAgIG9wZW5lciAhPT0gb3BlbmVyc19ib3R0b21bY2xvc2VyY2NdKSB7XG4gICAgICAgICAgICAgICAgb2RkX21hdGNoID0gKGNsb3Nlci5jYW5fb3BlbiB8fCBvcGVuZXIuY2FuX2Nsb3NlKSAmJlxuICAgICAgICAgICAgICAgICAgICAob3BlbmVyLm9yaWdkZWxpbXMgKyBjbG9zZXIub3JpZ2RlbGltcykgJSAzID09PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvcGVuZXIuY2MgPT09IGNsb3Nlci5jYyAmJiBvcGVuZXIuY2FuX29wZW4gJiYgIW9kZF9tYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBvcGVuZXJfZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3BlbmVyID0gb3BlbmVyLnByZXZpb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2xkX2Nsb3NlciA9IGNsb3NlcjtcblxuICAgICAgICAgICAgaWYgKGNsb3NlcmNjID09PSBDX0FTVEVSSVNLIHx8IGNsb3NlcmNjID09PSBDX1VOREVSU0NPUkUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wZW5lcl9mb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXIgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgYWN0dWFsIG51bWJlciBvZiBkZWxpbWl0ZXJzIHVzZWQgZnJvbSBjbG9zZXJcbiAgICAgICAgICAgICAgICAgICAgdXNlX2RlbGltcyA9XG4gICAgICAgICAgICAgICAgICAgICAgKGNsb3Nlci5udW1kZWxpbXMgPj0gMiAmJiBvcGVuZXIubnVtZGVsaW1zID49IDIpID8gMiA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyX2lubCA9IG9wZW5lci5ub2RlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXJfaW5sID0gY2xvc2VyLm5vZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHVzZWQgZGVsaW1pdGVycyBmcm9tIHN0YWNrIGVsdHMgYW5kIGlubGluZXNcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyLm51bWRlbGltcyAtPSB1c2VfZGVsaW1zO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXIubnVtZGVsaW1zIC09IHVzZV9kZWxpbXM7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lcl9pbmwuX2xpdGVyYWwgPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyX2lubC5fbGl0ZXJhbC5zbGljZSgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJfaW5sLl9saXRlcmFsLmxlbmd0aCAtIHVzZV9kZWxpbXMpO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXJfaW5sLl9saXRlcmFsID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlcl9pbmwuX2xpdGVyYWwuc2xpY2UoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyX2lubC5fbGl0ZXJhbC5sZW5ndGggLSB1c2VfZGVsaW1zKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBidWlsZCBjb250ZW50cyBmb3IgbmV3IGVtcGggZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgZW1waCA9IG5ldyBOb2RlKHVzZV9kZWxpbXMgPT09IDEgPyAnZW1waCcgOiAnc3Ryb25nJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdG1wID0gb3BlbmVyX2lubC5fbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRtcCAmJiB0bXAgIT09IGNsb3Nlcl9pbmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB0bXAuX25leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBoLmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyX2lubC5pbnNlcnRBZnRlcihlbXBoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZWx0cyBiZXR3ZWVuIG9wZW5lciBhbmQgY2xvc2VyIGluIGRlbGltaXRlcnMgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRGVsaW1pdGVyc0JldHdlZW4ob3BlbmVyLCBjbG9zZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG9wZW5lciBoYXMgMCBkZWxpbXMsIHJlbW92ZSBpdCBhbmQgdGhlIGlubGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyLm51bWRlbGltcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyX2lubC51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyKG9wZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VyLm51bWRlbGltcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyX2lubC51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBzdGFjayA9IGNsb3Nlci5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXIoY2xvc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlciA9IHRlbXBzdGFjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsb3NlcmNjID09PSBDX1NJTkdMRVFVT1RFKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VyLm5vZGUuX2xpdGVyYWwgPSBcIlxcdTIwMTlcIjtcbiAgICAgICAgICAgICAgICBpZiAob3BlbmVyX2ZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lci5ub2RlLl9saXRlcmFsID0gXCJcXHUyMDE4XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5uZXh0O1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsb3NlcmNjID09PSBDX0RPVUJMRVFVT1RFKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VyLm5vZGUuX2xpdGVyYWwgPSBcIlxcdTIwMURcIjtcbiAgICAgICAgICAgICAgICBpZiAob3BlbmVyX2ZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lci5ub2RlLmxpdGVyYWwgPSBcIlxcdTIwMUNcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3BlbmVyX2ZvdW5kICYmICFvZGRfbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgZm9yIGZ1dHVyZSBzZWFyY2hlcyBmb3Igb3BlbmVyczpcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBkbyB0aGlzIHdpdGggb2RkX21hdGNoIGJlY2F1c2UgYSAqKlxuICAgICAgICAgICAgICAgIC8vIHRoYXQgZG9lc24ndCBtYXRjaCBhbiBlYXJsaWVyICogbWlnaHQgdHVybiBpbnRvXG4gICAgICAgICAgICAgICAgLy8gYW4gb3BlbmVyLCBhbmQgdGhlICogbWlnaHQgYmUgbWF0Y2hlZCBieSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAvLyBlbHNlLlxuICAgICAgICAgICAgICAgIG9wZW5lcnNfYm90dG9tW2Nsb3NlcmNjXSA9IG9sZF9jbG9zZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRfY2xvc2VyLmNhbl9vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiByZW1vdmUgYSBjbG9zZXIgdGhhdCBjYW4ndCBiZSBhbiBvcGVuZXIsXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uY2Ugd2UndmUgc2VlbiB0aGVyZSdzIG5vIG1hdGNoaW5nIG9wZW5lcjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXIob2xkX2Nsb3Nlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYWxsIGRlbGltaXRlcnNcbiAgICB3aGlsZSAodGhpcy5kZWxpbWl0ZXJzICE9PSBudWxsICYmIHRoaXMuZGVsaW1pdGVycyAhPT0gc3RhY2tfYm90dG9tKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyKHRoaXMuZGVsaW1pdGVycyk7XG4gICAgfVxufTtcblxuLy8gQXR0ZW1wdCB0byBwYXJzZSBsaW5rIHRpdGxlIChzYW5zIHF1b3RlcyksIHJldHVybmluZyB0aGUgc3RyaW5nXG4vLyBvciBudWxsIGlmIG5vIG1hdGNoLlxudmFyIHBhcnNlTGlua1RpdGxlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRpdGxlID0gdGhpcy5tYXRjaChyZUxpbmtUaXRsZSk7XG4gICAgaWYgKHRpdGxlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNob3Agb2ZmIHF1b3RlcyBmcm9tIHRpdGxlIGFuZCB1bmVzY2FwZTpcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlU3RyaW5nKHRpdGxlLnN1YnN0cigxLCB0aXRsZS5sZW5ndGggLSAyKSk7XG4gICAgfVxufTtcblxuLy8gQXR0ZW1wdCB0byBwYXJzZSBsaW5rIGRlc3RpbmF0aW9uLCByZXR1cm5pbmcgdGhlIHN0cmluZyBvclxuLy8gbnVsbCBpZiBubyBtYXRjaC5cbnZhciBwYXJzZUxpbmtEZXN0aW5hdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXMgPSB0aGlzLm1hdGNoKHJlTGlua0Rlc3RpbmF0aW9uQnJhY2VzKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE8gaGFuZHJvbGxlZCBwYXJzZXI7IHJlcyBzaG91bGQgYmUgbnVsbCBvciB0aGUgc3RyaW5nXG4gICAgICAgIHZhciBzYXZlcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHZhciBvcGVucGFyZW5zID0gMDtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHdoaWxlICgoYyA9IHRoaXMucGVlaygpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChjID09PSBDX0JBQ0tTTEFTSCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVlaygpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gQ19PUEVOX1BBUkVOKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICBvcGVucGFyZW5zICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IENfQ0xPU0VfUEFSRU4pIHtcbiAgICAgICAgICAgICAgICBpZiAob3BlbnBhcmVucyA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgb3BlbnBhcmVucyAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVXaGl0ZXNwYWNlQ2hhci5leGVjKGZyb21Db2RlUG9pbnQoYykpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gdGhpcy5zdWJqZWN0LnN1YnN0cihzYXZlcG9zLCB0aGlzLnBvcyAtIHNhdmVwb3MpO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplVVJJKHVuZXNjYXBlU3RyaW5nKHJlcykpO1xuICAgIH0gZWxzZSB7ICAvLyBjaG9wIG9mZiBzdXJyb3VuZGluZyA8Li4+OlxuICAgICAgICByZXR1cm4gbm9ybWFsaXplVVJJKHVuZXNjYXBlU3RyaW5nKHJlcy5zdWJzdHIoMSwgcmVzLmxlbmd0aCAtIDIpKSk7XG4gICAgfVxufTtcblxuLy8gQXR0ZW1wdCB0byBwYXJzZSBhIGxpbmsgbGFiZWwsIHJldHVybmluZyBudW1iZXIgb2YgY2hhcmFjdGVycyBwYXJzZWQuXG52YXIgcGFyc2VMaW5rTGFiZWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbSA9IHRoaXMubWF0Y2gocmVMaW5rTGFiZWwpO1xuICAgIC8vIE5vdGU6ICBvdXIgcmVnZXggd2lsbCBhbGxvdyBzb21ldGhpbmcgb2YgZm9ybSBbLi5cXF07XG4gICAgLy8gd2UgZGlzYWxsb3cgaXQgaGVyZSByYXRoZXIgdGhhbiB1c2luZyBsb29rYWhlYWQgaW4gdGhlIHJlZ2V4OlxuICAgIGlmIChtID09PSBudWxsIHx8IG0ubGVuZ3RoID4gMTAwMSB8fCAvW15cXFxcXVxcXFxcXF0kLy5leGVjKG0pKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtLmxlbmd0aDtcbiAgICB9XG59O1xuXG4vLyBBZGQgb3BlbiBicmFja2V0IHRvIGRlbGltaXRlciBzdGFjayBhbmQgYWRkIGEgdGV4dCBub2RlIHRvIGJsb2NrJ3MgY2hpbGRyZW4uXG52YXIgcGFyc2VPcGVuQnJhY2tldCA9IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gMTtcblxuICAgIHZhciBub2RlID0gdGV4dCgnWycpO1xuICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuXG4gICAgLy8gQWRkIGVudHJ5IHRvIHN0YWNrIGZvciB0aGlzIG9wZW5lclxuICAgIHRoaXMuYWRkQnJhY2tldChub2RlLCBzdGFydHBvcywgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8gSUYgbmV4dCBjaGFyYWN0ZXIgaXMgWywgYW5kICEgZGVsaW1pdGVyIHRvIGRlbGltaXRlciBzdGFjayBhbmRcbi8vIGFkZCBhIHRleHQgbm9kZSB0byBibG9jaydzIGNoaWxkcmVuLiAgT3RoZXJ3aXNlIGp1c3QgYWRkIGEgdGV4dCBub2RlLlxudmFyIHBhcnNlQmFuZyA9IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gMTtcbiAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfT1BFTl9CUkFDS0VUKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0ZXh0KCchWycpO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcblxuICAgICAgICAvLyBBZGQgZW50cnkgdG8gc3RhY2sgZm9yIHRoaXMgb3BlbmVyXG4gICAgICAgIHRoaXMuYWRkQnJhY2tldChub2RlLCBzdGFydHBvcyArIDEsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQoJyEnKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8gVHJ5IHRvIG1hdGNoIGNsb3NlIGJyYWNrZXQgYWdhaW5zdCBhbiBvcGVuaW5nIGluIHRoZSBkZWxpbWl0ZXJcbi8vIHN0YWNrLiAgQWRkIGVpdGhlciBhIGxpbmsgb3IgaW1hZ2UsIG9yIGEgcGxhaW4gWyBjaGFyYWN0ZXIsXG4vLyB0byBibG9jaydzIGNoaWxkcmVuLiAgSWYgdGhlcmUgaXMgYSBtYXRjaGluZyBkZWxpbWl0ZXIsXG4vLyByZW1vdmUgaXQgZnJvbSB0aGUgZGVsaW1pdGVyIHN0YWNrLlxudmFyIHBhcnNlQ2xvc2VCcmFja2V0ID0gZnVuY3Rpb24oYmxvY2spIHtcbiAgICB2YXIgc3RhcnRwb3M7XG4gICAgdmFyIGlzX2ltYWdlO1xuICAgIHZhciBkZXN0O1xuICAgIHZhciB0aXRsZTtcbiAgICB2YXIgbWF0Y2hlZCA9IGZhbHNlO1xuICAgIHZhciByZWZsYWJlbDtcbiAgICB2YXIgb3BlbmVyO1xuXG4gICAgdGhpcy5wb3MgKz0gMTtcbiAgICBzdGFydHBvcyA9IHRoaXMucG9zO1xuXG4gICAgLy8gZ2V0IGxhc3QgWyBvciAhW1xuICAgIG9wZW5lciA9IHRoaXMuYnJhY2tldHM7XG5cbiAgICBpZiAob3BlbmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIG5vIG1hdGNoZWQgb3BlbmVyLCBqdXN0IHJldHVybiBhIGxpdGVyYWxcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCgnXScpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFvcGVuZXIuYWN0aXZlKSB7XG4gICAgICAgIC8vIG5vIG1hdGNoZWQgb3BlbmVyLCBqdXN0IHJldHVybiBhIGxpdGVyYWxcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCgnXScpKTtcbiAgICAgICAgLy8gdGFrZSBvcGVuZXIgb2ZmIGJyYWNrZXRzIHN0YWNrXG4gICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgb3BlbiBpcyBhIHBvdGVudGlhbCBvcGVuZXJcbiAgICBpc19pbWFnZSA9IG9wZW5lci5pbWFnZTtcblxuICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgbGluay9pbWFnZVxuXG4gICAgdmFyIHNhdmVwb3MgPSB0aGlzLnBvcztcblxuICAgIC8vIElubGluZSBsaW5rP1xuICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19PUEVOX1BBUkVOKSB7XG4gICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgIGlmICh0aGlzLnNwbmwoKSAmJlxuICAgICAgICAgICAgKChkZXN0ID0gdGhpcy5wYXJzZUxpbmtEZXN0aW5hdGlvbigpKSAhPT0gbnVsbCkgJiZcbiAgICAgICAgICAgIHRoaXMuc3BubCgpICYmXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlcmUncyBhIHNwYWNlIGJlZm9yZSB0aGUgdGl0bGU6XG4gICAgICAgICAgICAocmVXaGl0ZXNwYWNlQ2hhci50ZXN0KHRoaXMuc3ViamVjdC5jaGFyQXQodGhpcy5wb3MgLSAxKSkgJiZcbiAgICAgICAgICAgICAodGl0bGUgPSB0aGlzLnBhcnNlTGlua1RpdGxlKCkpIHx8IHRydWUpICYmXG4gICAgICAgICAgICB0aGlzLnNwbmwoKSAmJlxuICAgICAgICAgICAgdGhpcy5wZWVrKCkgPT09IENfQ0xPU0VfUEFSRU4pIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gc2F2ZXBvcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbWF0Y2hlZCkge1xuXG4gICAgICAgIC8vIE5leHQsIHNlZSBpZiB0aGVyZSdzIGEgbGluayBsYWJlbFxuICAgICAgICB2YXIgYmVmb3JlbGFiZWwgPSB0aGlzLnBvcztcbiAgICAgICAgdmFyIG4gPSB0aGlzLnBhcnNlTGlua0xhYmVsKCk7XG4gICAgICAgIGlmIChuID4gMikge1xuICAgICAgICAgICAgcmVmbGFiZWwgPSB0aGlzLnN1YmplY3Quc2xpY2UoYmVmb3JlbGFiZWwsIGJlZm9yZWxhYmVsICsgbik7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wZW5lci5icmFja2V0QWZ0ZXIpIHtcbiAgICAgICAgICAgIC8vIEVtcHR5IG9yIG1pc3Npbmcgc2Vjb25kIGxhYmVsIG1lYW5zIHRvIHVzZSB0aGUgZmlyc3QgbGFiZWwgYXMgdGhlIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIC8vIFRoZSByZWZlcmVuY2UgbXVzdCBub3QgY29udGFpbiBhIGJyYWNrZXQuIElmIHdlIGtub3cgdGhlcmUncyBhIGJyYWNrZXQsIHdlIGRvbid0IGV2ZW4gYm90aGVyIGNoZWNraW5nIGl0LlxuICAgICAgICAgICAgcmVmbGFiZWwgPSB0aGlzLnN1YmplY3Quc2xpY2Uob3BlbmVyLmluZGV4LCBzdGFydHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIC8vIElmIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rLCByZXdpbmQgYmVmb3JlIHNwYWNlcyB3ZSBza2lwcGVkLlxuICAgICAgICAgICAgdGhpcy5wb3MgPSBzYXZlcG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZmxhYmVsKSB7XG4gICAgICAgICAgICAvLyBsb29rdXAgcmF3bGFiZWwgaW4gcmVmbWFwXG4gICAgICAgICAgICB2YXIgbGluayA9IHRoaXMucmVmbWFwW25vcm1hbGl6ZVJlZmVyZW5jZShyZWZsYWJlbCldO1xuICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICBkZXN0ID0gbGluay5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGxpbmsudGl0bGU7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKGlzX2ltYWdlID8gJ2ltYWdlJyA6ICdsaW5rJyk7XG4gICAgICAgIG5vZGUuX2Rlc3RpbmF0aW9uID0gZGVzdDtcbiAgICAgICAgbm9kZS5fdGl0bGUgPSB0aXRsZSB8fCAnJztcblxuICAgICAgICB2YXIgdG1wLCBuZXh0O1xuICAgICAgICB0bXAgPSBvcGVuZXIubm9kZS5fbmV4dDtcbiAgICAgICAgd2hpbGUgKHRtcCkge1xuICAgICAgICAgICAgbmV4dCA9IHRtcC5fbmV4dDtcbiAgICAgICAgICAgIHRtcC51bmxpbmsoKTtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodG1wKTtcbiAgICAgICAgICAgIHRtcCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0VtcGhhc2lzKG9wZW5lci5wcmV2aW91c0RlbGltaXRlcik7XG4gICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpO1xuICAgICAgICBvcGVuZXIubm9kZS51bmxpbmsoKTtcblxuICAgICAgICAvLyBXZSByZW1vdmUgdGhpcyBicmFja2V0IGFuZCBwcm9jZXNzRW1waGFzaXMgd2lsbCByZW1vdmUgbGF0ZXIgZGVsaW1pdGVycy5cbiAgICAgICAgLy8gTm93LCBmb3IgYSBsaW5rLCB3ZSBhbHNvIGRlYWN0aXZhdGUgZWFybGllciBsaW5rIG9wZW5lcnMuXG4gICAgICAgIC8vIChubyBsaW5rcyBpbiBsaW5rcylcbiAgICAgICAgaWYgKCFpc19pbWFnZSkge1xuICAgICAgICAgIG9wZW5lciA9IHRoaXMuYnJhY2tldHM7XG4gICAgICAgICAgd2hpbGUgKG9wZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFvcGVuZXIuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBvcGVuZXIuYWN0aXZlID0gZmFsc2U7IC8vIGRlYWN0aXZhdGUgdGhpcyBvcGVuZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW5lciA9IG9wZW5lci5wcmV2aW91cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSB7IC8vIG5vIG1hdGNoXG5cbiAgICAgICAgdGhpcy5yZW1vdmVCcmFja2V0KCk7ICAvLyByZW1vdmUgdGhpcyBvcGVuZXIgZnJvbSBzdGFja1xuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0KCddJykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbn07XG5cbnZhciBhZGRCcmFja2V0ID0gZnVuY3Rpb24obm9kZSwgaW5kZXgsIGltYWdlKSB7XG4gICAgaWYgKHRoaXMuYnJhY2tldHMgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5icmFja2V0cy5icmFja2V0QWZ0ZXIgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmJyYWNrZXRzID0geyBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzOiB0aGlzLmJyYWNrZXRzLFxuICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRGVsaW1pdGVyOiB0aGlzLmRlbGltaXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IHRydWUgfTtcbn07XG5cbnZhciByZW1vdmVCcmFja2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5icmFja2V0cyA9IHRoaXMuYnJhY2tldHMucHJldmlvdXM7XG59O1xuXG4vLyBBdHRlbXB0IHRvIHBhcnNlIGFuIGVudGl0eS5cbnZhciBwYXJzZUVudGl0eSA9IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKChtID0gdGhpcy5tYXRjaChyZUVudGl0eUhlcmUpKSkge1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0KGRlY29kZUhUTUwobSkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbi8vIFBhcnNlIGEgcnVuIG9mIG9yZGluYXJ5IGNoYXJhY3RlcnMsIG9yIGEgc2luZ2xlIGNoYXJhY3RlciB3aXRoXG4vLyBhIHNwZWNpYWwgbWVhbmluZyBpbiBtYXJrZG93biwgYXMgYSBwbGFpbiBzdHJpbmcuXG52YXIgcGFyc2VTdHJpbmcgPSBmdW5jdGlvbihibG9jaykge1xuICAgIHZhciBtO1xuICAgIGlmICgobSA9IHRoaXMubWF0Y2gocmVNYWluKSkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydCkge1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dChcbiAgICAgICAgICAgICAgICBtLnJlcGxhY2UocmVFbGxpcHNlcywgXCJcXHUyMDI2XCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJlRGFzaCwgZnVuY3Rpb24oY2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFycy5sZW5ndGggJSAzID09PSAwKSB7IC8vIElmIGRpdmlzaWJsZSBieSAzLCB1c2UgYWxsIGVtIGRhc2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtQ291bnQgPSBjaGFycy5sZW5ndGggLyAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFycy5sZW5ndGggJSAyID09PSAwKSB7IC8vIElmIGRpdmlzaWJsZSBieSAyLCB1c2UgYWxsIGVuIGRhc2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuQ291bnQgPSBjaGFycy5sZW5ndGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFycy5sZW5ndGggJSAzID09PSAyKSB7IC8vIElmIDIgZXh0cmEgZGFzaGVzLCB1c2UgZW4gZGFzaCBmb3IgbGFzdCAyOyBlbSBkYXNoZXMgZm9yIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbkNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbUNvdW50ID0gKGNoYXJzLmxlbmd0aCAtIDIpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIFVzZSBlbiBkYXNoZXMgZm9yIGxhc3QgNCBoeXBoZW5zOyBlbSBkYXNoZXMgZm9yIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbkNvdW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbUNvdW50ID0gKGNoYXJzLmxlbmd0aCAtIDQpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdTIwMTRcIi5yZXBlYXQoZW1Db3VudCkgKyBcIlxcdTIwMTNcIi5yZXBlYXQoZW5Db3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0KG0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuLy8gUGFyc2UgYSBuZXdsaW5lLiAgSWYgaXQgd2FzIHByZWNlZGVkIGJ5IHR3byBzcGFjZXMsIHJldHVybiBhIGhhcmRcbi8vIGxpbmUgYnJlYWs7IG90aGVyd2lzZSBhIHNvZnQgbGluZSBicmVhay5cbnZhciBwYXJzZU5ld2xpbmUgPSBmdW5jdGlvbihibG9jaykge1xuICAgIHRoaXMucG9zICs9IDE7IC8vIGFzc3VtZSB3ZSdyZSBhdCBhIFxcblxuICAgIC8vIGNoZWNrIHByZXZpb3VzIG5vZGUgZm9yIHRyYWlsaW5nIHNwYWNlc1xuICAgIHZhciBsYXN0YyA9IGJsb2NrLl9sYXN0Q2hpbGQ7XG4gICAgaWYgKGxhc3RjICYmIGxhc3RjLnR5cGUgPT09ICd0ZXh0JyAmJiBsYXN0Yy5fbGl0ZXJhbFtsYXN0Yy5fbGl0ZXJhbC5sZW5ndGggLSAxXSA9PT0gJyAnKSB7XG4gICAgICAgIHZhciBoYXJkYnJlYWsgPSBsYXN0Yy5fbGl0ZXJhbFtsYXN0Yy5fbGl0ZXJhbC5sZW5ndGggLSAyXSA9PT0gJyAnO1xuICAgICAgICBsYXN0Yy5fbGl0ZXJhbCA9IGxhc3RjLl9saXRlcmFsLnJlcGxhY2UocmVGaW5hbFNwYWNlLCAnJyk7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5ldyBOb2RlKGhhcmRicmVhayA/ICdsaW5lYnJlYWsnIDogJ3NvZnRicmVhaycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZChuZXcgTm9kZSgnc29mdGJyZWFrJykpO1xuICAgIH1cbiAgICB0aGlzLm1hdGNoKHJlSW5pdGlhbFNwYWNlKTsgLy8gZ29iYmxlIGxlYWRpbmcgc3BhY2VzIGluIG5leHQgbGluZVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8gQXR0ZW1wdCB0byBwYXJzZSBhIGxpbmsgcmVmZXJlbmNlLCBtb2RpZnlpbmcgcmVmbWFwLlxudmFyIHBhcnNlUmVmZXJlbmNlID0gZnVuY3Rpb24ocywgcmVmbWFwKSB7XG4gICAgdGhpcy5zdWJqZWN0ID0gcztcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdmFyIHJhd2xhYmVsO1xuICAgIHZhciBkZXN0O1xuICAgIHZhciB0aXRsZTtcbiAgICB2YXIgbWF0Y2hDaGFycztcbiAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcblxuICAgIC8vIGxhYmVsOlxuICAgIG1hdGNoQ2hhcnMgPSB0aGlzLnBhcnNlTGlua0xhYmVsKCk7XG4gICAgaWYgKG1hdGNoQ2hhcnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmF3bGFiZWwgPSB0aGlzLnN1YmplY3Quc3Vic3RyKDAsIG1hdGNoQ2hhcnMpO1xuICAgIH1cblxuICAgIC8vIGNvbG9uOlxuICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19DT0xPTikge1xuICAgICAgICB0aGlzLnBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vICBsaW5rIHVybFxuICAgIHRoaXMuc3BubCgpO1xuXG4gICAgZGVzdCA9IHRoaXMucGFyc2VMaW5rRGVzdGluYXRpb24oKTtcbiAgICBpZiAoZGVzdCA9PT0gbnVsbCB8fCBkZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JldGl0bGUgPSB0aGlzLnBvcztcbiAgICB0aGlzLnNwbmwoKTtcbiAgICB0aXRsZSA9IHRoaXMucGFyc2VMaW5rVGl0bGUoKTtcbiAgICBpZiAodGl0bGUgPT09IG51bGwpIHtcbiAgICAgICAgdGl0bGUgPSAnJztcbiAgICAgICAgLy8gcmV3aW5kIGJlZm9yZSBzcGFjZXNcbiAgICAgICAgdGhpcy5wb3MgPSBiZWZvcmV0aXRsZTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UncmUgYXQgbGluZSBlbmQ6XG4gICAgdmFyIGF0TGluZUVuZCA9IHRydWU7XG4gICAgaWYgKHRoaXMubWF0Y2gocmVTcGFjZUF0RW5kT2ZMaW5lKSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAodGl0bGUgPT09ICcnKSB7XG4gICAgICAgICAgICBhdExpbmVFbmQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoZSBwb3RlbnRpYWwgdGl0bGUgd2UgZm91bmQgaXMgbm90IGF0IHRoZSBsaW5lIGVuZCxcbiAgICAgICAgICAgIC8vIGJ1dCBpdCBjb3VsZCBzdGlsbCBiZSBhIGxlZ2FsIGxpbmsgcmVmZXJlbmNlIGlmIHdlXG4gICAgICAgICAgICAvLyBkaXNjYXJkIHRoZSB0aXRsZVxuICAgICAgICAgICAgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIC8vIHJld2luZCBiZWZvcmUgc3BhY2VzXG4gICAgICAgICAgICB0aGlzLnBvcyA9IGJlZm9yZXRpdGxlO1xuICAgICAgICAgICAgLy8gYW5kIGluc3RlYWQgY2hlY2sgaWYgdGhlIGxpbmsgVVJMIGlzIGF0IHRoZSBsaW5lIGVuZFxuICAgICAgICAgICAgYXRMaW5lRW5kID0gdGhpcy5tYXRjaChyZVNwYWNlQXRFbmRPZkxpbmUpICE9PSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhdExpbmVFbmQpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIG5vcm1sYWJlbCA9IG5vcm1hbGl6ZVJlZmVyZW5jZShyYXdsYWJlbCk7XG4gICAgaWYgKG5vcm1sYWJlbCA9PT0gJycpIHtcbiAgICAgICAgLy8gbGFiZWwgbXVzdCBjb250YWluIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKCFyZWZtYXBbbm9ybWxhYmVsXSkge1xuICAgICAgICByZWZtYXBbbm9ybWxhYmVsXSA9IHsgZGVzdGluYXRpb246IGRlc3QsIHRpdGxlOiB0aXRsZSB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb3MgLSBzdGFydHBvcztcbn07XG5cbi8vIFBhcnNlIHRoZSBuZXh0IGlubGluZSBlbGVtZW50IGluIHN1YmplY3QsIGFkdmFuY2luZyBzdWJqZWN0IHBvc2l0aW9uLlxuLy8gT24gc3VjY2VzcywgYWRkIHRoZSByZXN1bHQgdG8gYmxvY2sncyBjaGlsZHJlbiBhbmQgcmV0dXJuIHRydWUuXG4vLyBPbiBmYWlsdXJlLCByZXR1cm4gZmFsc2UuXG52YXIgcGFyc2VJbmxpbmUgPSBmdW5jdGlvbihibG9jaykge1xuICAgIHZhciByZXMgPSBmYWxzZTtcbiAgICB2YXIgYyA9IHRoaXMucGVlaygpO1xuICAgIGlmIChjID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSBDX05FV0xJTkU6XG4gICAgICAgIHJlcyA9IHRoaXMucGFyc2VOZXdsaW5lKGJsb2NrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBDX0JBQ0tTTEFTSDpcbiAgICAgICAgcmVzID0gdGhpcy5wYXJzZUJhY2tzbGFzaChibG9jayk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ19CQUNLVElDSzpcbiAgICAgICAgcmVzID0gdGhpcy5wYXJzZUJhY2t0aWNrcyhibG9jayk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ19BU1RFUklTSzpcbiAgICBjYXNlIENfVU5ERVJTQ09SRTpcbiAgICAgICAgcmVzID0gdGhpcy5oYW5kbGVEZWxpbShjLCBibG9jayk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ19TSU5HTEVRVU9URTpcbiAgICBjYXNlIENfRE9VQkxFUVVPVEU6XG4gICAgICAgIHJlcyA9IHRoaXMub3B0aW9ucy5zbWFydCAmJiB0aGlzLmhhbmRsZURlbGltKGMsIGJsb2NrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBDX09QRU5fQlJBQ0tFVDpcbiAgICAgICAgcmVzID0gdGhpcy5wYXJzZU9wZW5CcmFja2V0KGJsb2NrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBDX0JBTkc6XG4gICAgICAgIHJlcyA9IHRoaXMucGFyc2VCYW5nKGJsb2NrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBDX0NMT1NFX0JSQUNLRVQ6XG4gICAgICAgIHJlcyA9IHRoaXMucGFyc2VDbG9zZUJyYWNrZXQoYmxvY2spO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIENfTEVTU1RIQU46XG4gICAgICAgIHJlcyA9IHRoaXMucGFyc2VBdXRvbGluayhibG9jaykgfHwgdGhpcy5wYXJzZUh0bWxUYWcoYmxvY2spO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIENfQU1QRVJTQU5EOlxuICAgICAgICByZXMgPSB0aGlzLnBhcnNlRW50aXR5KGJsb2NrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmVzID0gdGhpcy5wYXJzZVN0cmluZyhibG9jayk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIXJlcykge1xuICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0KGZyb21Db2RlUG9pbnQoYykpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFBhcnNlIHN0cmluZyBjb250ZW50IGluIGJsb2NrIGludG8gaW5saW5lIGNoaWxkcmVuLFxuLy8gdXNpbmcgcmVmbWFwIHRvIHJlc29sdmUgcmVmZXJlbmNlcy5cbnZhciBwYXJzZUlubGluZXMgPSBmdW5jdGlvbihibG9jaykge1xuICAgIHRoaXMuc3ViamVjdCA9IGJsb2NrLl9zdHJpbmdfY29udGVudC50cmltKCk7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuZGVsaW1pdGVycyA9IG51bGw7XG4gICAgdGhpcy5icmFja2V0cyA9IG51bGw7XG4gICAgd2hpbGUgKHRoaXMucGFyc2VJbmxpbmUoYmxvY2spKSB7XG4gICAgfVxuICAgIGJsb2NrLl9zdHJpbmdfY29udGVudCA9IG51bGw7IC8vIGFsbG93IHJhdyBzdHJpbmcgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICB0aGlzLnByb2Nlc3NFbXBoYXNpcyhudWxsKTtcbn07XG5cbi8vIFRoZSBJbmxpbmVQYXJzZXIgb2JqZWN0LlxuZnVuY3Rpb24gSW5saW5lUGFyc2VyKG9wdGlvbnMpe1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YmplY3Q6ICcnLFxuICAgICAgICBkZWxpbWl0ZXJzOiBudWxsLCAgLy8gdXNlZCBieSBoYW5kbGVEZWxpbSBtZXRob2RcbiAgICAgICAgYnJhY2tldHM6IG51bGwsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgcmVmbWFwOiB7fSxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBwZWVrOiBwZWVrLFxuICAgICAgICBzcG5sOiBzcG5sLFxuICAgICAgICBwYXJzZUJhY2t0aWNrczogcGFyc2VCYWNrdGlja3MsXG4gICAgICAgIHBhcnNlQmFja3NsYXNoOiBwYXJzZUJhY2tzbGFzaCxcbiAgICAgICAgcGFyc2VBdXRvbGluazogcGFyc2VBdXRvbGluayxcbiAgICAgICAgcGFyc2VIdG1sVGFnOiBwYXJzZUh0bWxUYWcsXG4gICAgICAgIHNjYW5EZWxpbXM6IHNjYW5EZWxpbXMsXG4gICAgICAgIGhhbmRsZURlbGltOiBoYW5kbGVEZWxpbSxcbiAgICAgICAgcGFyc2VMaW5rVGl0bGU6IHBhcnNlTGlua1RpdGxlLFxuICAgICAgICBwYXJzZUxpbmtEZXN0aW5hdGlvbjogcGFyc2VMaW5rRGVzdGluYXRpb24sXG4gICAgICAgIHBhcnNlTGlua0xhYmVsOiBwYXJzZUxpbmtMYWJlbCxcbiAgICAgICAgcGFyc2VPcGVuQnJhY2tldDogcGFyc2VPcGVuQnJhY2tldCxcbiAgICAgICAgcGFyc2VCYW5nOiBwYXJzZUJhbmcsXG4gICAgICAgIHBhcnNlQ2xvc2VCcmFja2V0OiBwYXJzZUNsb3NlQnJhY2tldCxcbiAgICAgICAgYWRkQnJhY2tldDogYWRkQnJhY2tldCxcbiAgICAgICAgcmVtb3ZlQnJhY2tldDogcmVtb3ZlQnJhY2tldCxcbiAgICAgICAgcGFyc2VFbnRpdHk6IHBhcnNlRW50aXR5LFxuICAgICAgICBwYXJzZVN0cmluZzogcGFyc2VTdHJpbmcsXG4gICAgICAgIHBhcnNlTmV3bGluZTogcGFyc2VOZXdsaW5lLFxuICAgICAgICBwYXJzZVJlZmVyZW5jZTogcGFyc2VSZWZlcmVuY2UsXG4gICAgICAgIHBhcnNlSW5saW5lOiBwYXJzZUlubGluZSxcbiAgICAgICAgcHJvY2Vzc0VtcGhhc2lzOiBwcm9jZXNzRW1waGFzaXMsXG4gICAgICAgIHJlbW92ZURlbGltaXRlcjogcmVtb3ZlRGVsaW1pdGVyLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9LFxuICAgICAgICBwYXJzZTogcGFyc2VJbmxpbmVzXG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbmxpbmVQYXJzZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb21tb25tYXJrL2xpYi9pbmxpbmVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogVGhlIGJ1bGsgb2YgdGhpcyBjb2RlIGRlcml2ZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZG1vc2Nyb3AvZm9sZC1jYXNlXG5CdXQgaW4gYWRkaXRpb24gdG8gY2FzZS1mb2xkaW5nLCB3ZSBhbHNvIG5vcm1hbGl6ZSB3aGl0ZXNwYWNlLlxuXG5mb2xkLWNhc2UgaXMgQ29weXJpZ2h0IE1hdGhpYXMgQnluZW5zIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvPlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG5PRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuLyplc2xpbnQtZGlzYWJsZSAga2V5LXNwYWNpbmcsIGNvbW1hLXNwYWNpbmcgKi9cblxudmFyIHJlZ2V4ID0gL1sgXFx0XFxyXFxuXSt8W0EtWlxceEI1XFx4QzAtXFx4RDZcXHhEOC1cXHhERlxcdTAxMDBcXHUwMTAyXFx1MDEwNFxcdTAxMDZcXHUwMTA4XFx1MDEwQVxcdTAxMENcXHUwMTBFXFx1MDExMFxcdTAxMTJcXHUwMTE0XFx1MDExNlxcdTAxMThcXHUwMTFBXFx1MDExQ1xcdTAxMUVcXHUwMTIwXFx1MDEyMlxcdTAxMjRcXHUwMTI2XFx1MDEyOFxcdTAxMkFcXHUwMTJDXFx1MDEyRVxcdTAxMzBcXHUwMTMyXFx1MDEzNFxcdTAxMzZcXHUwMTM5XFx1MDEzQlxcdTAxM0RcXHUwMTNGXFx1MDE0MVxcdTAxNDNcXHUwMTQ1XFx1MDE0N1xcdTAxNDlcXHUwMTRBXFx1MDE0Q1xcdTAxNEVcXHUwMTUwXFx1MDE1MlxcdTAxNTRcXHUwMTU2XFx1MDE1OFxcdTAxNUFcXHUwMTVDXFx1MDE1RVxcdTAxNjBcXHUwMTYyXFx1MDE2NFxcdTAxNjZcXHUwMTY4XFx1MDE2QVxcdTAxNkNcXHUwMTZFXFx1MDE3MFxcdTAxNzJcXHUwMTc0XFx1MDE3NlxcdTAxNzhcXHUwMTc5XFx1MDE3QlxcdTAxN0RcXHUwMTdGXFx1MDE4MVxcdTAxODJcXHUwMTg0XFx1MDE4NlxcdTAxODdcXHUwMTg5LVxcdTAxOEJcXHUwMThFLVxcdTAxOTFcXHUwMTkzXFx1MDE5NFxcdTAxOTYtXFx1MDE5OFxcdTAxOUNcXHUwMTlEXFx1MDE5RlxcdTAxQTBcXHUwMUEyXFx1MDFBNFxcdTAxQTZcXHUwMUE3XFx1MDFBOVxcdTAxQUNcXHUwMUFFXFx1MDFBRlxcdTAxQjEtXFx1MDFCM1xcdTAxQjVcXHUwMUI3XFx1MDFCOFxcdTAxQkNcXHUwMUM0XFx1MDFDNVxcdTAxQzdcXHUwMUM4XFx1MDFDQVxcdTAxQ0JcXHUwMUNEXFx1MDFDRlxcdTAxRDFcXHUwMUQzXFx1MDFENVxcdTAxRDdcXHUwMUQ5XFx1MDFEQlxcdTAxREVcXHUwMUUwXFx1MDFFMlxcdTAxRTRcXHUwMUU2XFx1MDFFOFxcdTAxRUFcXHUwMUVDXFx1MDFFRVxcdTAxRjAtXFx1MDFGMlxcdTAxRjRcXHUwMUY2LVxcdTAxRjhcXHUwMUZBXFx1MDFGQ1xcdTAxRkVcXHUwMjAwXFx1MDIwMlxcdTAyMDRcXHUwMjA2XFx1MDIwOFxcdTAyMEFcXHUwMjBDXFx1MDIwRVxcdTAyMTBcXHUwMjEyXFx1MDIxNFxcdTAyMTZcXHUwMjE4XFx1MDIxQVxcdTAyMUNcXHUwMjFFXFx1MDIyMFxcdTAyMjJcXHUwMjI0XFx1MDIyNlxcdTAyMjhcXHUwMjJBXFx1MDIyQ1xcdTAyMkVcXHUwMjMwXFx1MDIzMlxcdTAyM0FcXHUwMjNCXFx1MDIzRFxcdTAyM0VcXHUwMjQxXFx1MDI0My1cXHUwMjQ2XFx1MDI0OFxcdTAyNEFcXHUwMjRDXFx1MDI0RVxcdTAzNDVcXHUwMzcwXFx1MDM3MlxcdTAzNzZcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzQUJcXHUwM0IwXFx1MDNDMlxcdTAzQ0YtXFx1MDNEMVxcdTAzRDVcXHUwM0Q2XFx1MDNEOFxcdTAzREFcXHUwM0RDXFx1MDNERVxcdTAzRTBcXHUwM0UyXFx1MDNFNFxcdTAzRTZcXHUwM0U4XFx1MDNFQVxcdTAzRUNcXHUwM0VFXFx1MDNGMFxcdTAzRjFcXHUwM0Y0XFx1MDNGNVxcdTAzRjdcXHUwM0Y5XFx1MDNGQVxcdTAzRkQtXFx1MDQyRlxcdTA0NjBcXHUwNDYyXFx1MDQ2NFxcdTA0NjZcXHUwNDY4XFx1MDQ2QVxcdTA0NkNcXHUwNDZFXFx1MDQ3MFxcdTA0NzJcXHUwNDc0XFx1MDQ3NlxcdTA0NzhcXHUwNDdBXFx1MDQ3Q1xcdTA0N0VcXHUwNDgwXFx1MDQ4QVxcdTA0OENcXHUwNDhFXFx1MDQ5MFxcdTA0OTJcXHUwNDk0XFx1MDQ5NlxcdTA0OThcXHUwNDlBXFx1MDQ5Q1xcdTA0OUVcXHUwNEEwXFx1MDRBMlxcdTA0QTRcXHUwNEE2XFx1MDRBOFxcdTA0QUFcXHUwNEFDXFx1MDRBRVxcdTA0QjBcXHUwNEIyXFx1MDRCNFxcdTA0QjZcXHUwNEI4XFx1MDRCQVxcdTA0QkNcXHUwNEJFXFx1MDRDMFxcdTA0QzFcXHUwNEMzXFx1MDRDNVxcdTA0QzdcXHUwNEM5XFx1MDRDQlxcdTA0Q0RcXHUwNEQwXFx1MDREMlxcdTA0RDRcXHUwNEQ2XFx1MDREOFxcdTA0REFcXHUwNERDXFx1MDRERVxcdTA0RTBcXHUwNEUyXFx1MDRFNFxcdTA0RTZcXHUwNEU4XFx1MDRFQVxcdTA0RUNcXHUwNEVFXFx1MDRGMFxcdTA0RjJcXHUwNEY0XFx1MDRGNlxcdTA0RjhcXHUwNEZBXFx1MDRGQ1xcdTA0RkVcXHUwNTAwXFx1MDUwMlxcdTA1MDRcXHUwNTA2XFx1MDUwOFxcdTA1MEFcXHUwNTBDXFx1MDUwRVxcdTA1MTBcXHUwNTEyXFx1MDUxNFxcdTA1MTZcXHUwNTE4XFx1MDUxQVxcdTA1MUNcXHUwNTFFXFx1MDUyMFxcdTA1MjJcXHUwNTI0XFx1MDUyNlxcdTA1MjhcXHUwNTJBXFx1MDUyQ1xcdTA1MkVcXHUwNTMxLVxcdTA1NTZcXHUwNTg3XFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxRTAwXFx1MUUwMlxcdTFFMDRcXHUxRTA2XFx1MUUwOFxcdTFFMEFcXHUxRTBDXFx1MUUwRVxcdTFFMTBcXHUxRTEyXFx1MUUxNFxcdTFFMTZcXHUxRTE4XFx1MUUxQVxcdTFFMUNcXHUxRTFFXFx1MUUyMFxcdTFFMjJcXHUxRTI0XFx1MUUyNlxcdTFFMjhcXHUxRTJBXFx1MUUyQ1xcdTFFMkVcXHUxRTMwXFx1MUUzMlxcdTFFMzRcXHUxRTM2XFx1MUUzOFxcdTFFM0FcXHUxRTNDXFx1MUUzRVxcdTFFNDBcXHUxRTQyXFx1MUU0NFxcdTFFNDZcXHUxRTQ4XFx1MUU0QVxcdTFFNENcXHUxRTRFXFx1MUU1MFxcdTFFNTJcXHUxRTU0XFx1MUU1NlxcdTFFNThcXHUxRTVBXFx1MUU1Q1xcdTFFNUVcXHUxRTYwXFx1MUU2MlxcdTFFNjRcXHUxRTY2XFx1MUU2OFxcdTFFNkFcXHUxRTZDXFx1MUU2RVxcdTFFNzBcXHUxRTcyXFx1MUU3NFxcdTFFNzZcXHUxRTc4XFx1MUU3QVxcdTFFN0NcXHUxRTdFXFx1MUU4MFxcdTFFODJcXHUxRTg0XFx1MUU4NlxcdTFFODhcXHUxRThBXFx1MUU4Q1xcdTFFOEVcXHUxRTkwXFx1MUU5MlxcdTFFOTRcXHUxRTk2LVxcdTFFOUJcXHUxRTlFXFx1MUVBMFxcdTFFQTJcXHUxRUE0XFx1MUVBNlxcdTFFQThcXHUxRUFBXFx1MUVBQ1xcdTFFQUVcXHUxRUIwXFx1MUVCMlxcdTFFQjRcXHUxRUI2XFx1MUVCOFxcdTFFQkFcXHUxRUJDXFx1MUVCRVxcdTFFQzBcXHUxRUMyXFx1MUVDNFxcdTFFQzZcXHUxRUM4XFx1MUVDQVxcdTFFQ0NcXHUxRUNFXFx1MUVEMFxcdTFFRDJcXHUxRUQ0XFx1MUVENlxcdTFFRDhcXHUxRURBXFx1MUVEQ1xcdTFFREVcXHUxRUUwXFx1MUVFMlxcdTFFRTRcXHUxRUU2XFx1MUVFOFxcdTFFRUFcXHUxRUVDXFx1MUVFRVxcdTFFRjBcXHUxRUYyXFx1MUVGNFxcdTFFRjZcXHUxRUY4XFx1MUVGQVxcdTFFRkNcXHUxRUZFXFx1MUYwOC1cXHUxRjBGXFx1MUYxOC1cXHUxRjFEXFx1MUYyOC1cXHUxRjJGXFx1MUYzOC1cXHUxRjNGXFx1MUY0OC1cXHUxRjREXFx1MUY1MFxcdTFGNTJcXHUxRjU0XFx1MUY1NlxcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUZcXHUxRjY4LVxcdTFGNkZcXHUxRjgwLVxcdTFGQUZcXHUxRkIyLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMlxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUyLVxcdTFGRTRcXHUxRkU2LVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMTI2XFx1MjEyQVxcdTIxMkJcXHUyMTMyXFx1MjE2MC1cXHUyMTZGXFx1MjE4M1xcdTI0QjYtXFx1MjRDRlxcdTJDMDAtXFx1MkMyRVxcdTJDNjBcXHUyQzYyLVxcdTJDNjRcXHUyQzY3XFx1MkM2OVxcdTJDNkJcXHUyQzZELVxcdTJDNzBcXHUyQzcyXFx1MkM3NVxcdTJDN0UtXFx1MkM4MFxcdTJDODJcXHUyQzg0XFx1MkM4NlxcdTJDODhcXHUyQzhBXFx1MkM4Q1xcdTJDOEVcXHUyQzkwXFx1MkM5MlxcdTJDOTRcXHUyQzk2XFx1MkM5OFxcdTJDOUFcXHUyQzlDXFx1MkM5RVxcdTJDQTBcXHUyQ0EyXFx1MkNBNFxcdTJDQTZcXHUyQ0E4XFx1MkNBQVxcdTJDQUNcXHUyQ0FFXFx1MkNCMFxcdTJDQjJcXHUyQ0I0XFx1MkNCNlxcdTJDQjhcXHUyQ0JBXFx1MkNCQ1xcdTJDQkVcXHUyQ0MwXFx1MkNDMlxcdTJDQzRcXHUyQ0M2XFx1MkNDOFxcdTJDQ0FcXHUyQ0NDXFx1MkNDRVxcdTJDRDBcXHUyQ0QyXFx1MkNENFxcdTJDRDZcXHUyQ0Q4XFx1MkNEQVxcdTJDRENcXHUyQ0RFXFx1MkNFMFxcdTJDRTJcXHUyQ0VCXFx1MkNFRFxcdTJDRjJcXHVBNjQwXFx1QTY0MlxcdUE2NDRcXHVBNjQ2XFx1QTY0OFxcdUE2NEFcXHVBNjRDXFx1QTY0RVxcdUE2NTBcXHVBNjUyXFx1QTY1NFxcdUE2NTZcXHVBNjU4XFx1QTY1QVxcdUE2NUNcXHVBNjVFXFx1QTY2MFxcdUE2NjJcXHVBNjY0XFx1QTY2NlxcdUE2NjhcXHVBNjZBXFx1QTY2Q1xcdUE2ODBcXHVBNjgyXFx1QTY4NFxcdUE2ODZcXHVBNjg4XFx1QTY4QVxcdUE2OENcXHVBNjhFXFx1QTY5MFxcdUE2OTJcXHVBNjk0XFx1QTY5NlxcdUE2OThcXHVBNjlBXFx1QTcyMlxcdUE3MjRcXHVBNzI2XFx1QTcyOFxcdUE3MkFcXHVBNzJDXFx1QTcyRVxcdUE3MzJcXHVBNzM0XFx1QTczNlxcdUE3MzhcXHVBNzNBXFx1QTczQ1xcdUE3M0VcXHVBNzQwXFx1QTc0MlxcdUE3NDRcXHVBNzQ2XFx1QTc0OFxcdUE3NEFcXHVBNzRDXFx1QTc0RVxcdUE3NTBcXHVBNzUyXFx1QTc1NFxcdUE3NTZcXHVBNzU4XFx1QTc1QVxcdUE3NUNcXHVBNzVFXFx1QTc2MFxcdUE3NjJcXHVBNzY0XFx1QTc2NlxcdUE3NjhcXHVBNzZBXFx1QTc2Q1xcdUE3NkVcXHVBNzc5XFx1QTc3QlxcdUE3N0RcXHVBNzdFXFx1QTc4MFxcdUE3ODJcXHVBNzg0XFx1QTc4NlxcdUE3OEJcXHVBNzhEXFx1QTc5MFxcdUE3OTJcXHVBNzk2XFx1QTc5OFxcdUE3OUFcXHVBNzlDXFx1QTc5RVxcdUE3QTBcXHVBN0EyXFx1QTdBNFxcdUE3QTZcXHVBN0E4XFx1QTdBQS1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGRjIxLVxcdUZGM0FdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzI3XXxcXHVEODA2W1xcdURDQTAtXFx1RENCRl0vZztcblxudmFyIG1hcCA9IHsnQSc6J2EnLCdCJzonYicsJ0MnOidjJywnRCc6J2QnLCdFJzonZScsJ0YnOidmJywnRyc6J2cnLCdIJzonaCcsJ0knOidpJywnSic6J2onLCdLJzonaycsJ0wnOidsJywnTSc6J20nLCdOJzonbicsJ08nOidvJywnUCc6J3AnLCdRJzoncScsJ1InOidyJywnUyc6J3MnLCdUJzondCcsJ1UnOid1JywnVic6J3YnLCdXJzondycsJ1gnOid4JywnWSc6J3knLCdaJzoneicsJ1xceEI1JzonXFx1MDNCQycsJ1xceEMwJzonXFx4RTAnLCdcXHhDMSc6J1xceEUxJywnXFx4QzInOidcXHhFMicsJ1xceEMzJzonXFx4RTMnLCdcXHhDNCc6J1xceEU0JywnXFx4QzUnOidcXHhFNScsJ1xceEM2JzonXFx4RTYnLCdcXHhDNyc6J1xceEU3JywnXFx4QzgnOidcXHhFOCcsJ1xceEM5JzonXFx4RTknLCdcXHhDQSc6J1xceEVBJywnXFx4Q0InOidcXHhFQicsJ1xceENDJzonXFx4RUMnLCdcXHhDRCc6J1xceEVEJywnXFx4Q0UnOidcXHhFRScsJ1xceENGJzonXFx4RUYnLCdcXHhEMCc6J1xceEYwJywnXFx4RDEnOidcXHhGMScsJ1xceEQyJzonXFx4RjInLCdcXHhEMyc6J1xceEYzJywnXFx4RDQnOidcXHhGNCcsJ1xceEQ1JzonXFx4RjUnLCdcXHhENic6J1xceEY2JywnXFx4RDgnOidcXHhGOCcsJ1xceEQ5JzonXFx4RjknLCdcXHhEQSc6J1xceEZBJywnXFx4REInOidcXHhGQicsJ1xceERDJzonXFx4RkMnLCdcXHhERCc6J1xceEZEJywnXFx4REUnOidcXHhGRScsJ1xcdTAxMDAnOidcXHUwMTAxJywnXFx1MDEwMic6J1xcdTAxMDMnLCdcXHUwMTA0JzonXFx1MDEwNScsJ1xcdTAxMDYnOidcXHUwMTA3JywnXFx1MDEwOCc6J1xcdTAxMDknLCdcXHUwMTBBJzonXFx1MDEwQicsJ1xcdTAxMEMnOidcXHUwMTBEJywnXFx1MDEwRSc6J1xcdTAxMEYnLCdcXHUwMTEwJzonXFx1MDExMScsJ1xcdTAxMTInOidcXHUwMTEzJywnXFx1MDExNCc6J1xcdTAxMTUnLCdcXHUwMTE2JzonXFx1MDExNycsJ1xcdTAxMTgnOidcXHUwMTE5JywnXFx1MDExQSc6J1xcdTAxMUInLCdcXHUwMTFDJzonXFx1MDExRCcsJ1xcdTAxMUUnOidcXHUwMTFGJywnXFx1MDEyMCc6J1xcdTAxMjEnLCdcXHUwMTIyJzonXFx1MDEyMycsJ1xcdTAxMjQnOidcXHUwMTI1JywnXFx1MDEyNic6J1xcdTAxMjcnLCdcXHUwMTI4JzonXFx1MDEyOScsJ1xcdTAxMkEnOidcXHUwMTJCJywnXFx1MDEyQyc6J1xcdTAxMkQnLCdcXHUwMTJFJzonXFx1MDEyRicsJ1xcdTAxMzInOidcXHUwMTMzJywnXFx1MDEzNCc6J1xcdTAxMzUnLCdcXHUwMTM2JzonXFx1MDEzNycsJ1xcdTAxMzknOidcXHUwMTNBJywnXFx1MDEzQic6J1xcdTAxM0MnLCdcXHUwMTNEJzonXFx1MDEzRScsJ1xcdTAxM0YnOidcXHUwMTQwJywnXFx1MDE0MSc6J1xcdTAxNDInLCdcXHUwMTQzJzonXFx1MDE0NCcsJ1xcdTAxNDUnOidcXHUwMTQ2JywnXFx1MDE0Nyc6J1xcdTAxNDgnLCdcXHUwMTRBJzonXFx1MDE0QicsJ1xcdTAxNEMnOidcXHUwMTREJywnXFx1MDE0RSc6J1xcdTAxNEYnLCdcXHUwMTUwJzonXFx1MDE1MScsJ1xcdTAxNTInOidcXHUwMTUzJywnXFx1MDE1NCc6J1xcdTAxNTUnLCdcXHUwMTU2JzonXFx1MDE1NycsJ1xcdTAxNTgnOidcXHUwMTU5JywnXFx1MDE1QSc6J1xcdTAxNUInLCdcXHUwMTVDJzonXFx1MDE1RCcsJ1xcdTAxNUUnOidcXHUwMTVGJywnXFx1MDE2MCc6J1xcdTAxNjEnLCdcXHUwMTYyJzonXFx1MDE2MycsJ1xcdTAxNjQnOidcXHUwMTY1JywnXFx1MDE2Nic6J1xcdTAxNjcnLCdcXHUwMTY4JzonXFx1MDE2OScsJ1xcdTAxNkEnOidcXHUwMTZCJywnXFx1MDE2Qyc6J1xcdTAxNkQnLCdcXHUwMTZFJzonXFx1MDE2RicsJ1xcdTAxNzAnOidcXHUwMTcxJywnXFx1MDE3Mic6J1xcdTAxNzMnLCdcXHUwMTc0JzonXFx1MDE3NScsJ1xcdTAxNzYnOidcXHUwMTc3JywnXFx1MDE3OCc6J1xceEZGJywnXFx1MDE3OSc6J1xcdTAxN0EnLCdcXHUwMTdCJzonXFx1MDE3QycsJ1xcdTAxN0QnOidcXHUwMTdFJywnXFx1MDE3Ric6J3MnLCdcXHUwMTgxJzonXFx1MDI1MycsJ1xcdTAxODInOidcXHUwMTgzJywnXFx1MDE4NCc6J1xcdTAxODUnLCdcXHUwMTg2JzonXFx1MDI1NCcsJ1xcdTAxODcnOidcXHUwMTg4JywnXFx1MDE4OSc6J1xcdTAyNTYnLCdcXHUwMThBJzonXFx1MDI1NycsJ1xcdTAxOEInOidcXHUwMThDJywnXFx1MDE4RSc6J1xcdTAxREQnLCdcXHUwMThGJzonXFx1MDI1OScsJ1xcdTAxOTAnOidcXHUwMjVCJywnXFx1MDE5MSc6J1xcdTAxOTInLCdcXHUwMTkzJzonXFx1MDI2MCcsJ1xcdTAxOTQnOidcXHUwMjYzJywnXFx1MDE5Nic6J1xcdTAyNjknLCdcXHUwMTk3JzonXFx1MDI2OCcsJ1xcdTAxOTgnOidcXHUwMTk5JywnXFx1MDE5Qyc6J1xcdTAyNkYnLCdcXHUwMTlEJzonXFx1MDI3MicsJ1xcdTAxOUYnOidcXHUwMjc1JywnXFx1MDFBMCc6J1xcdTAxQTEnLCdcXHUwMUEyJzonXFx1MDFBMycsJ1xcdTAxQTQnOidcXHUwMUE1JywnXFx1MDFBNic6J1xcdTAyODAnLCdcXHUwMUE3JzonXFx1MDFBOCcsJ1xcdTAxQTknOidcXHUwMjgzJywnXFx1MDFBQyc6J1xcdTAxQUQnLCdcXHUwMUFFJzonXFx1MDI4OCcsJ1xcdTAxQUYnOidcXHUwMUIwJywnXFx1MDFCMSc6J1xcdTAyOEEnLCdcXHUwMUIyJzonXFx1MDI4QicsJ1xcdTAxQjMnOidcXHUwMUI0JywnXFx1MDFCNSc6J1xcdTAxQjYnLCdcXHUwMUI3JzonXFx1MDI5MicsJ1xcdTAxQjgnOidcXHUwMUI5JywnXFx1MDFCQyc6J1xcdTAxQkQnLCdcXHUwMUM0JzonXFx1MDFDNicsJ1xcdTAxQzUnOidcXHUwMUM2JywnXFx1MDFDNyc6J1xcdTAxQzknLCdcXHUwMUM4JzonXFx1MDFDOScsJ1xcdTAxQ0EnOidcXHUwMUNDJywnXFx1MDFDQic6J1xcdTAxQ0MnLCdcXHUwMUNEJzonXFx1MDFDRScsJ1xcdTAxQ0YnOidcXHUwMUQwJywnXFx1MDFEMSc6J1xcdTAxRDInLCdcXHUwMUQzJzonXFx1MDFENCcsJ1xcdTAxRDUnOidcXHUwMUQ2JywnXFx1MDFENyc6J1xcdTAxRDgnLCdcXHUwMUQ5JzonXFx1MDFEQScsJ1xcdTAxREInOidcXHUwMURDJywnXFx1MDFERSc6J1xcdTAxREYnLCdcXHUwMUUwJzonXFx1MDFFMScsJ1xcdTAxRTInOidcXHUwMUUzJywnXFx1MDFFNCc6J1xcdTAxRTUnLCdcXHUwMUU2JzonXFx1MDFFNycsJ1xcdTAxRTgnOidcXHUwMUU5JywnXFx1MDFFQSc6J1xcdTAxRUInLCdcXHUwMUVDJzonXFx1MDFFRCcsJ1xcdTAxRUUnOidcXHUwMUVGJywnXFx1MDFGMSc6J1xcdTAxRjMnLCdcXHUwMUYyJzonXFx1MDFGMycsJ1xcdTAxRjQnOidcXHUwMUY1JywnXFx1MDFGNic6J1xcdTAxOTUnLCdcXHUwMUY3JzonXFx1MDFCRicsJ1xcdTAxRjgnOidcXHUwMUY5JywnXFx1MDFGQSc6J1xcdTAxRkInLCdcXHUwMUZDJzonXFx1MDFGRCcsJ1xcdTAxRkUnOidcXHUwMUZGJywnXFx1MDIwMCc6J1xcdTAyMDEnLCdcXHUwMjAyJzonXFx1MDIwMycsJ1xcdTAyMDQnOidcXHUwMjA1JywnXFx1MDIwNic6J1xcdTAyMDcnLCdcXHUwMjA4JzonXFx1MDIwOScsJ1xcdTAyMEEnOidcXHUwMjBCJywnXFx1MDIwQyc6J1xcdTAyMEQnLCdcXHUwMjBFJzonXFx1MDIwRicsJ1xcdTAyMTAnOidcXHUwMjExJywnXFx1MDIxMic6J1xcdTAyMTMnLCdcXHUwMjE0JzonXFx1MDIxNScsJ1xcdTAyMTYnOidcXHUwMjE3JywnXFx1MDIxOCc6J1xcdTAyMTknLCdcXHUwMjFBJzonXFx1MDIxQicsJ1xcdTAyMUMnOidcXHUwMjFEJywnXFx1MDIxRSc6J1xcdTAyMUYnLCdcXHUwMjIwJzonXFx1MDE5RScsJ1xcdTAyMjInOidcXHUwMjIzJywnXFx1MDIyNCc6J1xcdTAyMjUnLCdcXHUwMjI2JzonXFx1MDIyNycsJ1xcdTAyMjgnOidcXHUwMjI5JywnXFx1MDIyQSc6J1xcdTAyMkInLCdcXHUwMjJDJzonXFx1MDIyRCcsJ1xcdTAyMkUnOidcXHUwMjJGJywnXFx1MDIzMCc6J1xcdTAyMzEnLCdcXHUwMjMyJzonXFx1MDIzMycsJ1xcdTAyM0EnOidcXHUyQzY1JywnXFx1MDIzQic6J1xcdTAyM0MnLCdcXHUwMjNEJzonXFx1MDE5QScsJ1xcdTAyM0UnOidcXHUyQzY2JywnXFx1MDI0MSc6J1xcdTAyNDInLCdcXHUwMjQzJzonXFx1MDE4MCcsJ1xcdTAyNDQnOidcXHUwMjg5JywnXFx1MDI0NSc6J1xcdTAyOEMnLCdcXHUwMjQ2JzonXFx1MDI0NycsJ1xcdTAyNDgnOidcXHUwMjQ5JywnXFx1MDI0QSc6J1xcdTAyNEInLCdcXHUwMjRDJzonXFx1MDI0RCcsJ1xcdTAyNEUnOidcXHUwMjRGJywnXFx1MDM0NSc6J1xcdTAzQjknLCdcXHUwMzcwJzonXFx1MDM3MScsJ1xcdTAzNzInOidcXHUwMzczJywnXFx1MDM3Nic6J1xcdTAzNzcnLCdcXHUwMzdGJzonXFx1MDNGMycsJ1xcdTAzODYnOidcXHUwM0FDJywnXFx1MDM4OCc6J1xcdTAzQUQnLCdcXHUwMzg5JzonXFx1MDNBRScsJ1xcdTAzOEEnOidcXHUwM0FGJywnXFx1MDM4Qyc6J1xcdTAzQ0MnLCdcXHUwMzhFJzonXFx1MDNDRCcsJ1xcdTAzOEYnOidcXHUwM0NFJywnXFx1MDM5MSc6J1xcdTAzQjEnLCdcXHUwMzkyJzonXFx1MDNCMicsJ1xcdTAzOTMnOidcXHUwM0IzJywnXFx1MDM5NCc6J1xcdTAzQjQnLCdcXHUwMzk1JzonXFx1MDNCNScsJ1xcdTAzOTYnOidcXHUwM0I2JywnXFx1MDM5Nyc6J1xcdTAzQjcnLCdcXHUwMzk4JzonXFx1MDNCOCcsJ1xcdTAzOTknOidcXHUwM0I5JywnXFx1MDM5QSc6J1xcdTAzQkEnLCdcXHUwMzlCJzonXFx1MDNCQicsJ1xcdTAzOUMnOidcXHUwM0JDJywnXFx1MDM5RCc6J1xcdTAzQkQnLCdcXHUwMzlFJzonXFx1MDNCRScsJ1xcdTAzOUYnOidcXHUwM0JGJywnXFx1MDNBMCc6J1xcdTAzQzAnLCdcXHUwM0ExJzonXFx1MDNDMScsJ1xcdTAzQTMnOidcXHUwM0MzJywnXFx1MDNBNCc6J1xcdTAzQzQnLCdcXHUwM0E1JzonXFx1MDNDNScsJ1xcdTAzQTYnOidcXHUwM0M2JywnXFx1MDNBNyc6J1xcdTAzQzcnLCdcXHUwM0E4JzonXFx1MDNDOCcsJ1xcdTAzQTknOidcXHUwM0M5JywnXFx1MDNBQSc6J1xcdTAzQ0EnLCdcXHUwM0FCJzonXFx1MDNDQicsJ1xcdTAzQzInOidcXHUwM0MzJywnXFx1MDNDRic6J1xcdTAzRDcnLCdcXHUwM0QwJzonXFx1MDNCMicsJ1xcdTAzRDEnOidcXHUwM0I4JywnXFx1MDNENSc6J1xcdTAzQzYnLCdcXHUwM0Q2JzonXFx1MDNDMCcsJ1xcdTAzRDgnOidcXHUwM0Q5JywnXFx1MDNEQSc6J1xcdTAzREInLCdcXHUwM0RDJzonXFx1MDNERCcsJ1xcdTAzREUnOidcXHUwM0RGJywnXFx1MDNFMCc6J1xcdTAzRTEnLCdcXHUwM0UyJzonXFx1MDNFMycsJ1xcdTAzRTQnOidcXHUwM0U1JywnXFx1MDNFNic6J1xcdTAzRTcnLCdcXHUwM0U4JzonXFx1MDNFOScsJ1xcdTAzRUEnOidcXHUwM0VCJywnXFx1MDNFQyc6J1xcdTAzRUQnLCdcXHUwM0VFJzonXFx1MDNFRicsJ1xcdTAzRjAnOidcXHUwM0JBJywnXFx1MDNGMSc6J1xcdTAzQzEnLCdcXHUwM0Y0JzonXFx1MDNCOCcsJ1xcdTAzRjUnOidcXHUwM0I1JywnXFx1MDNGNyc6J1xcdTAzRjgnLCdcXHUwM0Y5JzonXFx1MDNGMicsJ1xcdTAzRkEnOidcXHUwM0ZCJywnXFx1MDNGRCc6J1xcdTAzN0InLCdcXHUwM0ZFJzonXFx1MDM3QycsJ1xcdTAzRkYnOidcXHUwMzdEJywnXFx1MDQwMCc6J1xcdTA0NTAnLCdcXHUwNDAxJzonXFx1MDQ1MScsJ1xcdTA0MDInOidcXHUwNDUyJywnXFx1MDQwMyc6J1xcdTA0NTMnLCdcXHUwNDA0JzonXFx1MDQ1NCcsJ1xcdTA0MDUnOidcXHUwNDU1JywnXFx1MDQwNic6J1xcdTA0NTYnLCdcXHUwNDA3JzonXFx1MDQ1NycsJ1xcdTA0MDgnOidcXHUwNDU4JywnXFx1MDQwOSc6J1xcdTA0NTknLCdcXHUwNDBBJzonXFx1MDQ1QScsJ1xcdTA0MEInOidcXHUwNDVCJywnXFx1MDQwQyc6J1xcdTA0NUMnLCdcXHUwNDBEJzonXFx1MDQ1RCcsJ1xcdTA0MEUnOidcXHUwNDVFJywnXFx1MDQwRic6J1xcdTA0NUYnLCdcXHUwNDEwJzonXFx1MDQzMCcsJ1xcdTA0MTEnOidcXHUwNDMxJywnXFx1MDQxMic6J1xcdTA0MzInLCdcXHUwNDEzJzonXFx1MDQzMycsJ1xcdTA0MTQnOidcXHUwNDM0JywnXFx1MDQxNSc6J1xcdTA0MzUnLCdcXHUwNDE2JzonXFx1MDQzNicsJ1xcdTA0MTcnOidcXHUwNDM3JywnXFx1MDQxOCc6J1xcdTA0MzgnLCdcXHUwNDE5JzonXFx1MDQzOScsJ1xcdTA0MUEnOidcXHUwNDNBJywnXFx1MDQxQic6J1xcdTA0M0InLCdcXHUwNDFDJzonXFx1MDQzQycsJ1xcdTA0MUQnOidcXHUwNDNEJywnXFx1MDQxRSc6J1xcdTA0M0UnLCdcXHUwNDFGJzonXFx1MDQzRicsJ1xcdTA0MjAnOidcXHUwNDQwJywnXFx1MDQyMSc6J1xcdTA0NDEnLCdcXHUwNDIyJzonXFx1MDQ0MicsJ1xcdTA0MjMnOidcXHUwNDQzJywnXFx1MDQyNCc6J1xcdTA0NDQnLCdcXHUwNDI1JzonXFx1MDQ0NScsJ1xcdTA0MjYnOidcXHUwNDQ2JywnXFx1MDQyNyc6J1xcdTA0NDcnLCdcXHUwNDI4JzonXFx1MDQ0OCcsJ1xcdTA0MjknOidcXHUwNDQ5JywnXFx1MDQyQSc6J1xcdTA0NEEnLCdcXHUwNDJCJzonXFx1MDQ0QicsJ1xcdTA0MkMnOidcXHUwNDRDJywnXFx1MDQyRCc6J1xcdTA0NEQnLCdcXHUwNDJFJzonXFx1MDQ0RScsJ1xcdTA0MkYnOidcXHUwNDRGJywnXFx1MDQ2MCc6J1xcdTA0NjEnLCdcXHUwNDYyJzonXFx1MDQ2MycsJ1xcdTA0NjQnOidcXHUwNDY1JywnXFx1MDQ2Nic6J1xcdTA0NjcnLCdcXHUwNDY4JzonXFx1MDQ2OScsJ1xcdTA0NkEnOidcXHUwNDZCJywnXFx1MDQ2Qyc6J1xcdTA0NkQnLCdcXHUwNDZFJzonXFx1MDQ2RicsJ1xcdTA0NzAnOidcXHUwNDcxJywnXFx1MDQ3Mic6J1xcdTA0NzMnLCdcXHUwNDc0JzonXFx1MDQ3NScsJ1xcdTA0NzYnOidcXHUwNDc3JywnXFx1MDQ3OCc6J1xcdTA0NzknLCdcXHUwNDdBJzonXFx1MDQ3QicsJ1xcdTA0N0MnOidcXHUwNDdEJywnXFx1MDQ3RSc6J1xcdTA0N0YnLCdcXHUwNDgwJzonXFx1MDQ4MScsJ1xcdTA0OEEnOidcXHUwNDhCJywnXFx1MDQ4Qyc6J1xcdTA0OEQnLCdcXHUwNDhFJzonXFx1MDQ4RicsJ1xcdTA0OTAnOidcXHUwNDkxJywnXFx1MDQ5Mic6J1xcdTA0OTMnLCdcXHUwNDk0JzonXFx1MDQ5NScsJ1xcdTA0OTYnOidcXHUwNDk3JywnXFx1MDQ5OCc6J1xcdTA0OTknLCdcXHUwNDlBJzonXFx1MDQ5QicsJ1xcdTA0OUMnOidcXHUwNDlEJywnXFx1MDQ5RSc6J1xcdTA0OUYnLCdcXHUwNEEwJzonXFx1MDRBMScsJ1xcdTA0QTInOidcXHUwNEEzJywnXFx1MDRBNCc6J1xcdTA0QTUnLCdcXHUwNEE2JzonXFx1MDRBNycsJ1xcdTA0QTgnOidcXHUwNEE5JywnXFx1MDRBQSc6J1xcdTA0QUInLCdcXHUwNEFDJzonXFx1MDRBRCcsJ1xcdTA0QUUnOidcXHUwNEFGJywnXFx1MDRCMCc6J1xcdTA0QjEnLCdcXHUwNEIyJzonXFx1MDRCMycsJ1xcdTA0QjQnOidcXHUwNEI1JywnXFx1MDRCNic6J1xcdTA0QjcnLCdcXHUwNEI4JzonXFx1MDRCOScsJ1xcdTA0QkEnOidcXHUwNEJCJywnXFx1MDRCQyc6J1xcdTA0QkQnLCdcXHUwNEJFJzonXFx1MDRCRicsJ1xcdTA0QzAnOidcXHUwNENGJywnXFx1MDRDMSc6J1xcdTA0QzInLCdcXHUwNEMzJzonXFx1MDRDNCcsJ1xcdTA0QzUnOidcXHUwNEM2JywnXFx1MDRDNyc6J1xcdTA0QzgnLCdcXHUwNEM5JzonXFx1MDRDQScsJ1xcdTA0Q0InOidcXHUwNENDJywnXFx1MDRDRCc6J1xcdTA0Q0UnLCdcXHUwNEQwJzonXFx1MDREMScsJ1xcdTA0RDInOidcXHUwNEQzJywnXFx1MDRENCc6J1xcdTA0RDUnLCdcXHUwNEQ2JzonXFx1MDRENycsJ1xcdTA0RDgnOidcXHUwNEQ5JywnXFx1MDREQSc6J1xcdTA0REInLCdcXHUwNERDJzonXFx1MDRERCcsJ1xcdTA0REUnOidcXHUwNERGJywnXFx1MDRFMCc6J1xcdTA0RTEnLCdcXHUwNEUyJzonXFx1MDRFMycsJ1xcdTA0RTQnOidcXHUwNEU1JywnXFx1MDRFNic6J1xcdTA0RTcnLCdcXHUwNEU4JzonXFx1MDRFOScsJ1xcdTA0RUEnOidcXHUwNEVCJywnXFx1MDRFQyc6J1xcdTA0RUQnLCdcXHUwNEVFJzonXFx1MDRFRicsJ1xcdTA0RjAnOidcXHUwNEYxJywnXFx1MDRGMic6J1xcdTA0RjMnLCdcXHUwNEY0JzonXFx1MDRGNScsJ1xcdTA0RjYnOidcXHUwNEY3JywnXFx1MDRGOCc6J1xcdTA0RjknLCdcXHUwNEZBJzonXFx1MDRGQicsJ1xcdTA0RkMnOidcXHUwNEZEJywnXFx1MDRGRSc6J1xcdTA0RkYnLCdcXHUwNTAwJzonXFx1MDUwMScsJ1xcdTA1MDInOidcXHUwNTAzJywnXFx1MDUwNCc6J1xcdTA1MDUnLCdcXHUwNTA2JzonXFx1MDUwNycsJ1xcdTA1MDgnOidcXHUwNTA5JywnXFx1MDUwQSc6J1xcdTA1MEInLCdcXHUwNTBDJzonXFx1MDUwRCcsJ1xcdTA1MEUnOidcXHUwNTBGJywnXFx1MDUxMCc6J1xcdTA1MTEnLCdcXHUwNTEyJzonXFx1MDUxMycsJ1xcdTA1MTQnOidcXHUwNTE1JywnXFx1MDUxNic6J1xcdTA1MTcnLCdcXHUwNTE4JzonXFx1MDUxOScsJ1xcdTA1MUEnOidcXHUwNTFCJywnXFx1MDUxQyc6J1xcdTA1MUQnLCdcXHUwNTFFJzonXFx1MDUxRicsJ1xcdTA1MjAnOidcXHUwNTIxJywnXFx1MDUyMic6J1xcdTA1MjMnLCdcXHUwNTI0JzonXFx1MDUyNScsJ1xcdTA1MjYnOidcXHUwNTI3JywnXFx1MDUyOCc6J1xcdTA1MjknLCdcXHUwNTJBJzonXFx1MDUyQicsJ1xcdTA1MkMnOidcXHUwNTJEJywnXFx1MDUyRSc6J1xcdTA1MkYnLCdcXHUwNTMxJzonXFx1MDU2MScsJ1xcdTA1MzInOidcXHUwNTYyJywnXFx1MDUzMyc6J1xcdTA1NjMnLCdcXHUwNTM0JzonXFx1MDU2NCcsJ1xcdTA1MzUnOidcXHUwNTY1JywnXFx1MDUzNic6J1xcdTA1NjYnLCdcXHUwNTM3JzonXFx1MDU2NycsJ1xcdTA1MzgnOidcXHUwNTY4JywnXFx1MDUzOSc6J1xcdTA1NjknLCdcXHUwNTNBJzonXFx1MDU2QScsJ1xcdTA1M0InOidcXHUwNTZCJywnXFx1MDUzQyc6J1xcdTA1NkMnLCdcXHUwNTNEJzonXFx1MDU2RCcsJ1xcdTA1M0UnOidcXHUwNTZFJywnXFx1MDUzRic6J1xcdTA1NkYnLCdcXHUwNTQwJzonXFx1MDU3MCcsJ1xcdTA1NDEnOidcXHUwNTcxJywnXFx1MDU0Mic6J1xcdTA1NzInLCdcXHUwNTQzJzonXFx1MDU3MycsJ1xcdTA1NDQnOidcXHUwNTc0JywnXFx1MDU0NSc6J1xcdTA1NzUnLCdcXHUwNTQ2JzonXFx1MDU3NicsJ1xcdTA1NDcnOidcXHUwNTc3JywnXFx1MDU0OCc6J1xcdTA1NzgnLCdcXHUwNTQ5JzonXFx1MDU3OScsJ1xcdTA1NEEnOidcXHUwNTdBJywnXFx1MDU0Qic6J1xcdTA1N0InLCdcXHUwNTRDJzonXFx1MDU3QycsJ1xcdTA1NEQnOidcXHUwNTdEJywnXFx1MDU0RSc6J1xcdTA1N0UnLCdcXHUwNTRGJzonXFx1MDU3RicsJ1xcdTA1NTAnOidcXHUwNTgwJywnXFx1MDU1MSc6J1xcdTA1ODEnLCdcXHUwNTUyJzonXFx1MDU4MicsJ1xcdTA1NTMnOidcXHUwNTgzJywnXFx1MDU1NCc6J1xcdTA1ODQnLCdcXHUwNTU1JzonXFx1MDU4NScsJ1xcdTA1NTYnOidcXHUwNTg2JywnXFx1MTBBMCc6J1xcdTJEMDAnLCdcXHUxMEExJzonXFx1MkQwMScsJ1xcdTEwQTInOidcXHUyRDAyJywnXFx1MTBBMyc6J1xcdTJEMDMnLCdcXHUxMEE0JzonXFx1MkQwNCcsJ1xcdTEwQTUnOidcXHUyRDA1JywnXFx1MTBBNic6J1xcdTJEMDYnLCdcXHUxMEE3JzonXFx1MkQwNycsJ1xcdTEwQTgnOidcXHUyRDA4JywnXFx1MTBBOSc6J1xcdTJEMDknLCdcXHUxMEFBJzonXFx1MkQwQScsJ1xcdTEwQUInOidcXHUyRDBCJywnXFx1MTBBQyc6J1xcdTJEMEMnLCdcXHUxMEFEJzonXFx1MkQwRCcsJ1xcdTEwQUUnOidcXHUyRDBFJywnXFx1MTBBRic6J1xcdTJEMEYnLCdcXHUxMEIwJzonXFx1MkQxMCcsJ1xcdTEwQjEnOidcXHUyRDExJywnXFx1MTBCMic6J1xcdTJEMTInLCdcXHUxMEIzJzonXFx1MkQxMycsJ1xcdTEwQjQnOidcXHUyRDE0JywnXFx1MTBCNSc6J1xcdTJEMTUnLCdcXHUxMEI2JzonXFx1MkQxNicsJ1xcdTEwQjcnOidcXHUyRDE3JywnXFx1MTBCOCc6J1xcdTJEMTgnLCdcXHUxMEI5JzonXFx1MkQxOScsJ1xcdTEwQkEnOidcXHUyRDFBJywnXFx1MTBCQic6J1xcdTJEMUInLCdcXHUxMEJDJzonXFx1MkQxQycsJ1xcdTEwQkQnOidcXHUyRDFEJywnXFx1MTBCRSc6J1xcdTJEMUUnLCdcXHUxMEJGJzonXFx1MkQxRicsJ1xcdTEwQzAnOidcXHUyRDIwJywnXFx1MTBDMSc6J1xcdTJEMjEnLCdcXHUxMEMyJzonXFx1MkQyMicsJ1xcdTEwQzMnOidcXHUyRDIzJywnXFx1MTBDNCc6J1xcdTJEMjQnLCdcXHUxMEM1JzonXFx1MkQyNScsJ1xcdTEwQzcnOidcXHUyRDI3JywnXFx1MTBDRCc6J1xcdTJEMkQnLCdcXHUxRTAwJzonXFx1MUUwMScsJ1xcdTFFMDInOidcXHUxRTAzJywnXFx1MUUwNCc6J1xcdTFFMDUnLCdcXHUxRTA2JzonXFx1MUUwNycsJ1xcdTFFMDgnOidcXHUxRTA5JywnXFx1MUUwQSc6J1xcdTFFMEInLCdcXHUxRTBDJzonXFx1MUUwRCcsJ1xcdTFFMEUnOidcXHUxRTBGJywnXFx1MUUxMCc6J1xcdTFFMTEnLCdcXHUxRTEyJzonXFx1MUUxMycsJ1xcdTFFMTQnOidcXHUxRTE1JywnXFx1MUUxNic6J1xcdTFFMTcnLCdcXHUxRTE4JzonXFx1MUUxOScsJ1xcdTFFMUEnOidcXHUxRTFCJywnXFx1MUUxQyc6J1xcdTFFMUQnLCdcXHUxRTFFJzonXFx1MUUxRicsJ1xcdTFFMjAnOidcXHUxRTIxJywnXFx1MUUyMic6J1xcdTFFMjMnLCdcXHUxRTI0JzonXFx1MUUyNScsJ1xcdTFFMjYnOidcXHUxRTI3JywnXFx1MUUyOCc6J1xcdTFFMjknLCdcXHUxRTJBJzonXFx1MUUyQicsJ1xcdTFFMkMnOidcXHUxRTJEJywnXFx1MUUyRSc6J1xcdTFFMkYnLCdcXHUxRTMwJzonXFx1MUUzMScsJ1xcdTFFMzInOidcXHUxRTMzJywnXFx1MUUzNCc6J1xcdTFFMzUnLCdcXHUxRTM2JzonXFx1MUUzNycsJ1xcdTFFMzgnOidcXHUxRTM5JywnXFx1MUUzQSc6J1xcdTFFM0InLCdcXHUxRTNDJzonXFx1MUUzRCcsJ1xcdTFFM0UnOidcXHUxRTNGJywnXFx1MUU0MCc6J1xcdTFFNDEnLCdcXHUxRTQyJzonXFx1MUU0MycsJ1xcdTFFNDQnOidcXHUxRTQ1JywnXFx1MUU0Nic6J1xcdTFFNDcnLCdcXHUxRTQ4JzonXFx1MUU0OScsJ1xcdTFFNEEnOidcXHUxRTRCJywnXFx1MUU0Qyc6J1xcdTFFNEQnLCdcXHUxRTRFJzonXFx1MUU0RicsJ1xcdTFFNTAnOidcXHUxRTUxJywnXFx1MUU1Mic6J1xcdTFFNTMnLCdcXHUxRTU0JzonXFx1MUU1NScsJ1xcdTFFNTYnOidcXHUxRTU3JywnXFx1MUU1OCc6J1xcdTFFNTknLCdcXHUxRTVBJzonXFx1MUU1QicsJ1xcdTFFNUMnOidcXHUxRTVEJywnXFx1MUU1RSc6J1xcdTFFNUYnLCdcXHUxRTYwJzonXFx1MUU2MScsJ1xcdTFFNjInOidcXHUxRTYzJywnXFx1MUU2NCc6J1xcdTFFNjUnLCdcXHUxRTY2JzonXFx1MUU2NycsJ1xcdTFFNjgnOidcXHUxRTY5JywnXFx1MUU2QSc6J1xcdTFFNkInLCdcXHUxRTZDJzonXFx1MUU2RCcsJ1xcdTFFNkUnOidcXHUxRTZGJywnXFx1MUU3MCc6J1xcdTFFNzEnLCdcXHUxRTcyJzonXFx1MUU3MycsJ1xcdTFFNzQnOidcXHUxRTc1JywnXFx1MUU3Nic6J1xcdTFFNzcnLCdcXHUxRTc4JzonXFx1MUU3OScsJ1xcdTFFN0EnOidcXHUxRTdCJywnXFx1MUU3Qyc6J1xcdTFFN0QnLCdcXHUxRTdFJzonXFx1MUU3RicsJ1xcdTFFODAnOidcXHUxRTgxJywnXFx1MUU4Mic6J1xcdTFFODMnLCdcXHUxRTg0JzonXFx1MUU4NScsJ1xcdTFFODYnOidcXHUxRTg3JywnXFx1MUU4OCc6J1xcdTFFODknLCdcXHUxRThBJzonXFx1MUU4QicsJ1xcdTFFOEMnOidcXHUxRThEJywnXFx1MUU4RSc6J1xcdTFFOEYnLCdcXHUxRTkwJzonXFx1MUU5MScsJ1xcdTFFOTInOidcXHUxRTkzJywnXFx1MUU5NCc6J1xcdTFFOTUnLCdcXHUxRTlCJzonXFx1MUU2MScsJ1xcdTFFQTAnOidcXHUxRUExJywnXFx1MUVBMic6J1xcdTFFQTMnLCdcXHUxRUE0JzonXFx1MUVBNScsJ1xcdTFFQTYnOidcXHUxRUE3JywnXFx1MUVBOCc6J1xcdTFFQTknLCdcXHUxRUFBJzonXFx1MUVBQicsJ1xcdTFFQUMnOidcXHUxRUFEJywnXFx1MUVBRSc6J1xcdTFFQUYnLCdcXHUxRUIwJzonXFx1MUVCMScsJ1xcdTFFQjInOidcXHUxRUIzJywnXFx1MUVCNCc6J1xcdTFFQjUnLCdcXHUxRUI2JzonXFx1MUVCNycsJ1xcdTFFQjgnOidcXHUxRUI5JywnXFx1MUVCQSc6J1xcdTFFQkInLCdcXHUxRUJDJzonXFx1MUVCRCcsJ1xcdTFFQkUnOidcXHUxRUJGJywnXFx1MUVDMCc6J1xcdTFFQzEnLCdcXHUxRUMyJzonXFx1MUVDMycsJ1xcdTFFQzQnOidcXHUxRUM1JywnXFx1MUVDNic6J1xcdTFFQzcnLCdcXHUxRUM4JzonXFx1MUVDOScsJ1xcdTFFQ0EnOidcXHUxRUNCJywnXFx1MUVDQyc6J1xcdTFFQ0QnLCdcXHUxRUNFJzonXFx1MUVDRicsJ1xcdTFFRDAnOidcXHUxRUQxJywnXFx1MUVEMic6J1xcdTFFRDMnLCdcXHUxRUQ0JzonXFx1MUVENScsJ1xcdTFFRDYnOidcXHUxRUQ3JywnXFx1MUVEOCc6J1xcdTFFRDknLCdcXHUxRURBJzonXFx1MUVEQicsJ1xcdTFFREMnOidcXHUxRUREJywnXFx1MUVERSc6J1xcdTFFREYnLCdcXHUxRUUwJzonXFx1MUVFMScsJ1xcdTFFRTInOidcXHUxRUUzJywnXFx1MUVFNCc6J1xcdTFFRTUnLCdcXHUxRUU2JzonXFx1MUVFNycsJ1xcdTFFRTgnOidcXHUxRUU5JywnXFx1MUVFQSc6J1xcdTFFRUInLCdcXHUxRUVDJzonXFx1MUVFRCcsJ1xcdTFFRUUnOidcXHUxRUVGJywnXFx1MUVGMCc6J1xcdTFFRjEnLCdcXHUxRUYyJzonXFx1MUVGMycsJ1xcdTFFRjQnOidcXHUxRUY1JywnXFx1MUVGNic6J1xcdTFFRjcnLCdcXHUxRUY4JzonXFx1MUVGOScsJ1xcdTFFRkEnOidcXHUxRUZCJywnXFx1MUVGQyc6J1xcdTFFRkQnLCdcXHUxRUZFJzonXFx1MUVGRicsJ1xcdTFGMDgnOidcXHUxRjAwJywnXFx1MUYwOSc6J1xcdTFGMDEnLCdcXHUxRjBBJzonXFx1MUYwMicsJ1xcdTFGMEInOidcXHUxRjAzJywnXFx1MUYwQyc6J1xcdTFGMDQnLCdcXHUxRjBEJzonXFx1MUYwNScsJ1xcdTFGMEUnOidcXHUxRjA2JywnXFx1MUYwRic6J1xcdTFGMDcnLCdcXHUxRjE4JzonXFx1MUYxMCcsJ1xcdTFGMTknOidcXHUxRjExJywnXFx1MUYxQSc6J1xcdTFGMTInLCdcXHUxRjFCJzonXFx1MUYxMycsJ1xcdTFGMUMnOidcXHUxRjE0JywnXFx1MUYxRCc6J1xcdTFGMTUnLCdcXHUxRjI4JzonXFx1MUYyMCcsJ1xcdTFGMjknOidcXHUxRjIxJywnXFx1MUYyQSc6J1xcdTFGMjInLCdcXHUxRjJCJzonXFx1MUYyMycsJ1xcdTFGMkMnOidcXHUxRjI0JywnXFx1MUYyRCc6J1xcdTFGMjUnLCdcXHUxRjJFJzonXFx1MUYyNicsJ1xcdTFGMkYnOidcXHUxRjI3JywnXFx1MUYzOCc6J1xcdTFGMzAnLCdcXHUxRjM5JzonXFx1MUYzMScsJ1xcdTFGM0EnOidcXHUxRjMyJywnXFx1MUYzQic6J1xcdTFGMzMnLCdcXHUxRjNDJzonXFx1MUYzNCcsJ1xcdTFGM0QnOidcXHUxRjM1JywnXFx1MUYzRSc6J1xcdTFGMzYnLCdcXHUxRjNGJzonXFx1MUYzNycsJ1xcdTFGNDgnOidcXHUxRjQwJywnXFx1MUY0OSc6J1xcdTFGNDEnLCdcXHUxRjRBJzonXFx1MUY0MicsJ1xcdTFGNEInOidcXHUxRjQzJywnXFx1MUY0Qyc6J1xcdTFGNDQnLCdcXHUxRjREJzonXFx1MUY0NScsJ1xcdTFGNTknOidcXHUxRjUxJywnXFx1MUY1Qic6J1xcdTFGNTMnLCdcXHUxRjVEJzonXFx1MUY1NScsJ1xcdTFGNUYnOidcXHUxRjU3JywnXFx1MUY2OCc6J1xcdTFGNjAnLCdcXHUxRjY5JzonXFx1MUY2MScsJ1xcdTFGNkEnOidcXHUxRjYyJywnXFx1MUY2Qic6J1xcdTFGNjMnLCdcXHUxRjZDJzonXFx1MUY2NCcsJ1xcdTFGNkQnOidcXHUxRjY1JywnXFx1MUY2RSc6J1xcdTFGNjYnLCdcXHUxRjZGJzonXFx1MUY2NycsJ1xcdTFGQjgnOidcXHUxRkIwJywnXFx1MUZCOSc6J1xcdTFGQjEnLCdcXHUxRkJBJzonXFx1MUY3MCcsJ1xcdTFGQkInOidcXHUxRjcxJywnXFx1MUZCRSc6J1xcdTAzQjknLCdcXHUxRkM4JzonXFx1MUY3MicsJ1xcdTFGQzknOidcXHUxRjczJywnXFx1MUZDQSc6J1xcdTFGNzQnLCdcXHUxRkNCJzonXFx1MUY3NScsJ1xcdTFGRDgnOidcXHUxRkQwJywnXFx1MUZEOSc6J1xcdTFGRDEnLCdcXHUxRkRBJzonXFx1MUY3NicsJ1xcdTFGREInOidcXHUxRjc3JywnXFx1MUZFOCc6J1xcdTFGRTAnLCdcXHUxRkU5JzonXFx1MUZFMScsJ1xcdTFGRUEnOidcXHUxRjdBJywnXFx1MUZFQic6J1xcdTFGN0InLCdcXHUxRkVDJzonXFx1MUZFNScsJ1xcdTFGRjgnOidcXHUxRjc4JywnXFx1MUZGOSc6J1xcdTFGNzknLCdcXHUxRkZBJzonXFx1MUY3QycsJ1xcdTFGRkInOidcXHUxRjdEJywnXFx1MjEyNic6J1xcdTAzQzknLCdcXHUyMTJBJzonaycsJ1xcdTIxMkInOidcXHhFNScsJ1xcdTIxMzInOidcXHUyMTRFJywnXFx1MjE2MCc6J1xcdTIxNzAnLCdcXHUyMTYxJzonXFx1MjE3MScsJ1xcdTIxNjInOidcXHUyMTcyJywnXFx1MjE2Myc6J1xcdTIxNzMnLCdcXHUyMTY0JzonXFx1MjE3NCcsJ1xcdTIxNjUnOidcXHUyMTc1JywnXFx1MjE2Nic6J1xcdTIxNzYnLCdcXHUyMTY3JzonXFx1MjE3NycsJ1xcdTIxNjgnOidcXHUyMTc4JywnXFx1MjE2OSc6J1xcdTIxNzknLCdcXHUyMTZBJzonXFx1MjE3QScsJ1xcdTIxNkInOidcXHUyMTdCJywnXFx1MjE2Qyc6J1xcdTIxN0MnLCdcXHUyMTZEJzonXFx1MjE3RCcsJ1xcdTIxNkUnOidcXHUyMTdFJywnXFx1MjE2Ric6J1xcdTIxN0YnLCdcXHUyMTgzJzonXFx1MjE4NCcsJ1xcdTI0QjYnOidcXHUyNEQwJywnXFx1MjRCNyc6J1xcdTI0RDEnLCdcXHUyNEI4JzonXFx1MjREMicsJ1xcdTI0QjknOidcXHUyNEQzJywnXFx1MjRCQSc6J1xcdTI0RDQnLCdcXHUyNEJCJzonXFx1MjRENScsJ1xcdTI0QkMnOidcXHUyNEQ2JywnXFx1MjRCRCc6J1xcdTI0RDcnLCdcXHUyNEJFJzonXFx1MjREOCcsJ1xcdTI0QkYnOidcXHUyNEQ5JywnXFx1MjRDMCc6J1xcdTI0REEnLCdcXHUyNEMxJzonXFx1MjREQicsJ1xcdTI0QzInOidcXHUyNERDJywnXFx1MjRDMyc6J1xcdTI0REQnLCdcXHUyNEM0JzonXFx1MjRERScsJ1xcdTI0QzUnOidcXHUyNERGJywnXFx1MjRDNic6J1xcdTI0RTAnLCdcXHUyNEM3JzonXFx1MjRFMScsJ1xcdTI0QzgnOidcXHUyNEUyJywnXFx1MjRDOSc6J1xcdTI0RTMnLCdcXHUyNENBJzonXFx1MjRFNCcsJ1xcdTI0Q0InOidcXHUyNEU1JywnXFx1MjRDQyc6J1xcdTI0RTYnLCdcXHUyNENEJzonXFx1MjRFNycsJ1xcdTI0Q0UnOidcXHUyNEU4JywnXFx1MjRDRic6J1xcdTI0RTknLCdcXHUyQzAwJzonXFx1MkMzMCcsJ1xcdTJDMDEnOidcXHUyQzMxJywnXFx1MkMwMic6J1xcdTJDMzInLCdcXHUyQzAzJzonXFx1MkMzMycsJ1xcdTJDMDQnOidcXHUyQzM0JywnXFx1MkMwNSc6J1xcdTJDMzUnLCdcXHUyQzA2JzonXFx1MkMzNicsJ1xcdTJDMDcnOidcXHUyQzM3JywnXFx1MkMwOCc6J1xcdTJDMzgnLCdcXHUyQzA5JzonXFx1MkMzOScsJ1xcdTJDMEEnOidcXHUyQzNBJywnXFx1MkMwQic6J1xcdTJDM0InLCdcXHUyQzBDJzonXFx1MkMzQycsJ1xcdTJDMEQnOidcXHUyQzNEJywnXFx1MkMwRSc6J1xcdTJDM0UnLCdcXHUyQzBGJzonXFx1MkMzRicsJ1xcdTJDMTAnOidcXHUyQzQwJywnXFx1MkMxMSc6J1xcdTJDNDEnLCdcXHUyQzEyJzonXFx1MkM0MicsJ1xcdTJDMTMnOidcXHUyQzQzJywnXFx1MkMxNCc6J1xcdTJDNDQnLCdcXHUyQzE1JzonXFx1MkM0NScsJ1xcdTJDMTYnOidcXHUyQzQ2JywnXFx1MkMxNyc6J1xcdTJDNDcnLCdcXHUyQzE4JzonXFx1MkM0OCcsJ1xcdTJDMTknOidcXHUyQzQ5JywnXFx1MkMxQSc6J1xcdTJDNEEnLCdcXHUyQzFCJzonXFx1MkM0QicsJ1xcdTJDMUMnOidcXHUyQzRDJywnXFx1MkMxRCc6J1xcdTJDNEQnLCdcXHUyQzFFJzonXFx1MkM0RScsJ1xcdTJDMUYnOidcXHUyQzRGJywnXFx1MkMyMCc6J1xcdTJDNTAnLCdcXHUyQzIxJzonXFx1MkM1MScsJ1xcdTJDMjInOidcXHUyQzUyJywnXFx1MkMyMyc6J1xcdTJDNTMnLCdcXHUyQzI0JzonXFx1MkM1NCcsJ1xcdTJDMjUnOidcXHUyQzU1JywnXFx1MkMyNic6J1xcdTJDNTYnLCdcXHUyQzI3JzonXFx1MkM1NycsJ1xcdTJDMjgnOidcXHUyQzU4JywnXFx1MkMyOSc6J1xcdTJDNTknLCdcXHUyQzJBJzonXFx1MkM1QScsJ1xcdTJDMkInOidcXHUyQzVCJywnXFx1MkMyQyc6J1xcdTJDNUMnLCdcXHUyQzJEJzonXFx1MkM1RCcsJ1xcdTJDMkUnOidcXHUyQzVFJywnXFx1MkM2MCc6J1xcdTJDNjEnLCdcXHUyQzYyJzonXFx1MDI2QicsJ1xcdTJDNjMnOidcXHUxRDdEJywnXFx1MkM2NCc6J1xcdTAyN0QnLCdcXHUyQzY3JzonXFx1MkM2OCcsJ1xcdTJDNjknOidcXHUyQzZBJywnXFx1MkM2Qic6J1xcdTJDNkMnLCdcXHUyQzZEJzonXFx1MDI1MScsJ1xcdTJDNkUnOidcXHUwMjcxJywnXFx1MkM2Ric6J1xcdTAyNTAnLCdcXHUyQzcwJzonXFx1MDI1MicsJ1xcdTJDNzInOidcXHUyQzczJywnXFx1MkM3NSc6J1xcdTJDNzYnLCdcXHUyQzdFJzonXFx1MDIzRicsJ1xcdTJDN0YnOidcXHUwMjQwJywnXFx1MkM4MCc6J1xcdTJDODEnLCdcXHUyQzgyJzonXFx1MkM4MycsJ1xcdTJDODQnOidcXHUyQzg1JywnXFx1MkM4Nic6J1xcdTJDODcnLCdcXHUyQzg4JzonXFx1MkM4OScsJ1xcdTJDOEEnOidcXHUyQzhCJywnXFx1MkM4Qyc6J1xcdTJDOEQnLCdcXHUyQzhFJzonXFx1MkM4RicsJ1xcdTJDOTAnOidcXHUyQzkxJywnXFx1MkM5Mic6J1xcdTJDOTMnLCdcXHUyQzk0JzonXFx1MkM5NScsJ1xcdTJDOTYnOidcXHUyQzk3JywnXFx1MkM5OCc6J1xcdTJDOTknLCdcXHUyQzlBJzonXFx1MkM5QicsJ1xcdTJDOUMnOidcXHUyQzlEJywnXFx1MkM5RSc6J1xcdTJDOUYnLCdcXHUyQ0EwJzonXFx1MkNBMScsJ1xcdTJDQTInOidcXHUyQ0EzJywnXFx1MkNBNCc6J1xcdTJDQTUnLCdcXHUyQ0E2JzonXFx1MkNBNycsJ1xcdTJDQTgnOidcXHUyQ0E5JywnXFx1MkNBQSc6J1xcdTJDQUInLCdcXHUyQ0FDJzonXFx1MkNBRCcsJ1xcdTJDQUUnOidcXHUyQ0FGJywnXFx1MkNCMCc6J1xcdTJDQjEnLCdcXHUyQ0IyJzonXFx1MkNCMycsJ1xcdTJDQjQnOidcXHUyQ0I1JywnXFx1MkNCNic6J1xcdTJDQjcnLCdcXHUyQ0I4JzonXFx1MkNCOScsJ1xcdTJDQkEnOidcXHUyQ0JCJywnXFx1MkNCQyc6J1xcdTJDQkQnLCdcXHUyQ0JFJzonXFx1MkNCRicsJ1xcdTJDQzAnOidcXHUyQ0MxJywnXFx1MkNDMic6J1xcdTJDQzMnLCdcXHUyQ0M0JzonXFx1MkNDNScsJ1xcdTJDQzYnOidcXHUyQ0M3JywnXFx1MkNDOCc6J1xcdTJDQzknLCdcXHUyQ0NBJzonXFx1MkNDQicsJ1xcdTJDQ0MnOidcXHUyQ0NEJywnXFx1MkNDRSc6J1xcdTJDQ0YnLCdcXHUyQ0QwJzonXFx1MkNEMScsJ1xcdTJDRDInOidcXHUyQ0QzJywnXFx1MkNENCc6J1xcdTJDRDUnLCdcXHUyQ0Q2JzonXFx1MkNENycsJ1xcdTJDRDgnOidcXHUyQ0Q5JywnXFx1MkNEQSc6J1xcdTJDREInLCdcXHUyQ0RDJzonXFx1MkNERCcsJ1xcdTJDREUnOidcXHUyQ0RGJywnXFx1MkNFMCc6J1xcdTJDRTEnLCdcXHUyQ0UyJzonXFx1MkNFMycsJ1xcdTJDRUInOidcXHUyQ0VDJywnXFx1MkNFRCc6J1xcdTJDRUUnLCdcXHUyQ0YyJzonXFx1MkNGMycsJ1xcdUE2NDAnOidcXHVBNjQxJywnXFx1QTY0Mic6J1xcdUE2NDMnLCdcXHVBNjQ0JzonXFx1QTY0NScsJ1xcdUE2NDYnOidcXHVBNjQ3JywnXFx1QTY0OCc6J1xcdUE2NDknLCdcXHVBNjRBJzonXFx1QTY0QicsJ1xcdUE2NEMnOidcXHVBNjREJywnXFx1QTY0RSc6J1xcdUE2NEYnLCdcXHVBNjUwJzonXFx1QTY1MScsJ1xcdUE2NTInOidcXHVBNjUzJywnXFx1QTY1NCc6J1xcdUE2NTUnLCdcXHVBNjU2JzonXFx1QTY1NycsJ1xcdUE2NTgnOidcXHVBNjU5JywnXFx1QTY1QSc6J1xcdUE2NUInLCdcXHVBNjVDJzonXFx1QTY1RCcsJ1xcdUE2NUUnOidcXHVBNjVGJywnXFx1QTY2MCc6J1xcdUE2NjEnLCdcXHVBNjYyJzonXFx1QTY2MycsJ1xcdUE2NjQnOidcXHVBNjY1JywnXFx1QTY2Nic6J1xcdUE2NjcnLCdcXHVBNjY4JzonXFx1QTY2OScsJ1xcdUE2NkEnOidcXHVBNjZCJywnXFx1QTY2Qyc6J1xcdUE2NkQnLCdcXHVBNjgwJzonXFx1QTY4MScsJ1xcdUE2ODInOidcXHVBNjgzJywnXFx1QTY4NCc6J1xcdUE2ODUnLCdcXHVBNjg2JzonXFx1QTY4NycsJ1xcdUE2ODgnOidcXHVBNjg5JywnXFx1QTY4QSc6J1xcdUE2OEInLCdcXHVBNjhDJzonXFx1QTY4RCcsJ1xcdUE2OEUnOidcXHVBNjhGJywnXFx1QTY5MCc6J1xcdUE2OTEnLCdcXHVBNjkyJzonXFx1QTY5MycsJ1xcdUE2OTQnOidcXHVBNjk1JywnXFx1QTY5Nic6J1xcdUE2OTcnLCdcXHVBNjk4JzonXFx1QTY5OScsJ1xcdUE2OUEnOidcXHVBNjlCJywnXFx1QTcyMic6J1xcdUE3MjMnLCdcXHVBNzI0JzonXFx1QTcyNScsJ1xcdUE3MjYnOidcXHVBNzI3JywnXFx1QTcyOCc6J1xcdUE3MjknLCdcXHVBNzJBJzonXFx1QTcyQicsJ1xcdUE3MkMnOidcXHVBNzJEJywnXFx1QTcyRSc6J1xcdUE3MkYnLCdcXHVBNzMyJzonXFx1QTczMycsJ1xcdUE3MzQnOidcXHVBNzM1JywnXFx1QTczNic6J1xcdUE3MzcnLCdcXHVBNzM4JzonXFx1QTczOScsJ1xcdUE3M0EnOidcXHVBNzNCJywnXFx1QTczQyc6J1xcdUE3M0QnLCdcXHVBNzNFJzonXFx1QTczRicsJ1xcdUE3NDAnOidcXHVBNzQxJywnXFx1QTc0Mic6J1xcdUE3NDMnLCdcXHVBNzQ0JzonXFx1QTc0NScsJ1xcdUE3NDYnOidcXHVBNzQ3JywnXFx1QTc0OCc6J1xcdUE3NDknLCdcXHVBNzRBJzonXFx1QTc0QicsJ1xcdUE3NEMnOidcXHVBNzREJywnXFx1QTc0RSc6J1xcdUE3NEYnLCdcXHVBNzUwJzonXFx1QTc1MScsJ1xcdUE3NTInOidcXHVBNzUzJywnXFx1QTc1NCc6J1xcdUE3NTUnLCdcXHVBNzU2JzonXFx1QTc1NycsJ1xcdUE3NTgnOidcXHVBNzU5JywnXFx1QTc1QSc6J1xcdUE3NUInLCdcXHVBNzVDJzonXFx1QTc1RCcsJ1xcdUE3NUUnOidcXHVBNzVGJywnXFx1QTc2MCc6J1xcdUE3NjEnLCdcXHVBNzYyJzonXFx1QTc2MycsJ1xcdUE3NjQnOidcXHVBNzY1JywnXFx1QTc2Nic6J1xcdUE3NjcnLCdcXHVBNzY4JzonXFx1QTc2OScsJ1xcdUE3NkEnOidcXHVBNzZCJywnXFx1QTc2Qyc6J1xcdUE3NkQnLCdcXHVBNzZFJzonXFx1QTc2RicsJ1xcdUE3NzknOidcXHVBNzdBJywnXFx1QTc3Qic6J1xcdUE3N0MnLCdcXHVBNzdEJzonXFx1MUQ3OScsJ1xcdUE3N0UnOidcXHVBNzdGJywnXFx1QTc4MCc6J1xcdUE3ODEnLCdcXHVBNzgyJzonXFx1QTc4MycsJ1xcdUE3ODQnOidcXHVBNzg1JywnXFx1QTc4Nic6J1xcdUE3ODcnLCdcXHVBNzhCJzonXFx1QTc4QycsJ1xcdUE3OEQnOidcXHUwMjY1JywnXFx1QTc5MCc6J1xcdUE3OTEnLCdcXHVBNzkyJzonXFx1QTc5MycsJ1xcdUE3OTYnOidcXHVBNzk3JywnXFx1QTc5OCc6J1xcdUE3OTknLCdcXHVBNzlBJzonXFx1QTc5QicsJ1xcdUE3OUMnOidcXHVBNzlEJywnXFx1QTc5RSc6J1xcdUE3OUYnLCdcXHVBN0EwJzonXFx1QTdBMScsJ1xcdUE3QTInOidcXHVBN0EzJywnXFx1QTdBNCc6J1xcdUE3QTUnLCdcXHVBN0E2JzonXFx1QTdBNycsJ1xcdUE3QTgnOidcXHVBN0E5JywnXFx1QTdBQSc6J1xcdTAyNjYnLCdcXHVBN0FCJzonXFx1MDI1QycsJ1xcdUE3QUMnOidcXHUwMjYxJywnXFx1QTdBRCc6J1xcdTAyNkMnLCdcXHVBN0IwJzonXFx1MDI5RScsJ1xcdUE3QjEnOidcXHUwMjg3JywnXFx1RkYyMSc6J1xcdUZGNDEnLCdcXHVGRjIyJzonXFx1RkY0MicsJ1xcdUZGMjMnOidcXHVGRjQzJywnXFx1RkYyNCc6J1xcdUZGNDQnLCdcXHVGRjI1JzonXFx1RkY0NScsJ1xcdUZGMjYnOidcXHVGRjQ2JywnXFx1RkYyNyc6J1xcdUZGNDcnLCdcXHVGRjI4JzonXFx1RkY0OCcsJ1xcdUZGMjknOidcXHVGRjQ5JywnXFx1RkYyQSc6J1xcdUZGNEEnLCdcXHVGRjJCJzonXFx1RkY0QicsJ1xcdUZGMkMnOidcXHVGRjRDJywnXFx1RkYyRCc6J1xcdUZGNEQnLCdcXHVGRjJFJzonXFx1RkY0RScsJ1xcdUZGMkYnOidcXHVGRjRGJywnXFx1RkYzMCc6J1xcdUZGNTAnLCdcXHVGRjMxJzonXFx1RkY1MScsJ1xcdUZGMzInOidcXHVGRjUyJywnXFx1RkYzMyc6J1xcdUZGNTMnLCdcXHVGRjM0JzonXFx1RkY1NCcsJ1xcdUZGMzUnOidcXHVGRjU1JywnXFx1RkYzNic6J1xcdUZGNTYnLCdcXHVGRjM3JzonXFx1RkY1NycsJ1xcdUZGMzgnOidcXHVGRjU4JywnXFx1RkYzOSc6J1xcdUZGNTknLCdcXHVGRjNBJzonXFx1RkY1QScsJ1xcdUQ4MDFcXHVEQzAwJzonXFx1RDgwMVxcdURDMjgnLCdcXHVEODAxXFx1REMwMSc6J1xcdUQ4MDFcXHVEQzI5JywnXFx1RDgwMVxcdURDMDInOidcXHVEODAxXFx1REMyQScsJ1xcdUQ4MDFcXHVEQzAzJzonXFx1RDgwMVxcdURDMkInLCdcXHVEODAxXFx1REMwNCc6J1xcdUQ4MDFcXHVEQzJDJywnXFx1RDgwMVxcdURDMDUnOidcXHVEODAxXFx1REMyRCcsJ1xcdUQ4MDFcXHVEQzA2JzonXFx1RDgwMVxcdURDMkUnLCdcXHVEODAxXFx1REMwNyc6J1xcdUQ4MDFcXHVEQzJGJywnXFx1RDgwMVxcdURDMDgnOidcXHVEODAxXFx1REMzMCcsJ1xcdUQ4MDFcXHVEQzA5JzonXFx1RDgwMVxcdURDMzEnLCdcXHVEODAxXFx1REMwQSc6J1xcdUQ4MDFcXHVEQzMyJywnXFx1RDgwMVxcdURDMEInOidcXHVEODAxXFx1REMzMycsJ1xcdUQ4MDFcXHVEQzBDJzonXFx1RDgwMVxcdURDMzQnLCdcXHVEODAxXFx1REMwRCc6J1xcdUQ4MDFcXHVEQzM1JywnXFx1RDgwMVxcdURDMEUnOidcXHVEODAxXFx1REMzNicsJ1xcdUQ4MDFcXHVEQzBGJzonXFx1RDgwMVxcdURDMzcnLCdcXHVEODAxXFx1REMxMCc6J1xcdUQ4MDFcXHVEQzM4JywnXFx1RDgwMVxcdURDMTEnOidcXHVEODAxXFx1REMzOScsJ1xcdUQ4MDFcXHVEQzEyJzonXFx1RDgwMVxcdURDM0EnLCdcXHVEODAxXFx1REMxMyc6J1xcdUQ4MDFcXHVEQzNCJywnXFx1RDgwMVxcdURDMTQnOidcXHVEODAxXFx1REMzQycsJ1xcdUQ4MDFcXHVEQzE1JzonXFx1RDgwMVxcdURDM0QnLCdcXHVEODAxXFx1REMxNic6J1xcdUQ4MDFcXHVEQzNFJywnXFx1RDgwMVxcdURDMTcnOidcXHVEODAxXFx1REMzRicsJ1xcdUQ4MDFcXHVEQzE4JzonXFx1RDgwMVxcdURDNDAnLCdcXHVEODAxXFx1REMxOSc6J1xcdUQ4MDFcXHVEQzQxJywnXFx1RDgwMVxcdURDMUEnOidcXHVEODAxXFx1REM0MicsJ1xcdUQ4MDFcXHVEQzFCJzonXFx1RDgwMVxcdURDNDMnLCdcXHVEODAxXFx1REMxQyc6J1xcdUQ4MDFcXHVEQzQ0JywnXFx1RDgwMVxcdURDMUQnOidcXHVEODAxXFx1REM0NScsJ1xcdUQ4MDFcXHVEQzFFJzonXFx1RDgwMVxcdURDNDYnLCdcXHVEODAxXFx1REMxRic6J1xcdUQ4MDFcXHVEQzQ3JywnXFx1RDgwMVxcdURDMjAnOidcXHVEODAxXFx1REM0OCcsJ1xcdUQ4MDFcXHVEQzIxJzonXFx1RDgwMVxcdURDNDknLCdcXHVEODAxXFx1REMyMic6J1xcdUQ4MDFcXHVEQzRBJywnXFx1RDgwMVxcdURDMjMnOidcXHVEODAxXFx1REM0QicsJ1xcdUQ4MDFcXHVEQzI0JzonXFx1RDgwMVxcdURDNEMnLCdcXHVEODAxXFx1REMyNSc6J1xcdUQ4MDFcXHVEQzREJywnXFx1RDgwMVxcdURDMjYnOidcXHVEODAxXFx1REM0RScsJ1xcdUQ4MDFcXHVEQzI3JzonXFx1RDgwMVxcdURDNEYnLCdcXHVEODA2XFx1RENBMCc6J1xcdUQ4MDZcXHVEQ0MwJywnXFx1RDgwNlxcdURDQTEnOidcXHVEODA2XFx1RENDMScsJ1xcdUQ4MDZcXHVEQ0EyJzonXFx1RDgwNlxcdURDQzInLCdcXHVEODA2XFx1RENBMyc6J1xcdUQ4MDZcXHVEQ0MzJywnXFx1RDgwNlxcdURDQTQnOidcXHVEODA2XFx1RENDNCcsJ1xcdUQ4MDZcXHVEQ0E1JzonXFx1RDgwNlxcdURDQzUnLCdcXHVEODA2XFx1RENBNic6J1xcdUQ4MDZcXHVEQ0M2JywnXFx1RDgwNlxcdURDQTcnOidcXHVEODA2XFx1RENDNycsJ1xcdUQ4MDZcXHVEQ0E4JzonXFx1RDgwNlxcdURDQzgnLCdcXHVEODA2XFx1RENBOSc6J1xcdUQ4MDZcXHVEQ0M5JywnXFx1RDgwNlxcdURDQUEnOidcXHVEODA2XFx1RENDQScsJ1xcdUQ4MDZcXHVEQ0FCJzonXFx1RDgwNlxcdURDQ0InLCdcXHVEODA2XFx1RENBQyc6J1xcdUQ4MDZcXHVEQ0NDJywnXFx1RDgwNlxcdURDQUQnOidcXHVEODA2XFx1RENDRCcsJ1xcdUQ4MDZcXHVEQ0FFJzonXFx1RDgwNlxcdURDQ0UnLCdcXHVEODA2XFx1RENBRic6J1xcdUQ4MDZcXHVEQ0NGJywnXFx1RDgwNlxcdURDQjAnOidcXHVEODA2XFx1RENEMCcsJ1xcdUQ4MDZcXHVEQ0IxJzonXFx1RDgwNlxcdURDRDEnLCdcXHVEODA2XFx1RENCMic6J1xcdUQ4MDZcXHVEQ0QyJywnXFx1RDgwNlxcdURDQjMnOidcXHVEODA2XFx1RENEMycsJ1xcdUQ4MDZcXHVEQ0I0JzonXFx1RDgwNlxcdURDRDQnLCdcXHVEODA2XFx1RENCNSc6J1xcdUQ4MDZcXHVEQ0Q1JywnXFx1RDgwNlxcdURDQjYnOidcXHVEODA2XFx1RENENicsJ1xcdUQ4MDZcXHVEQ0I3JzonXFx1RDgwNlxcdURDRDcnLCdcXHVEODA2XFx1RENCOCc6J1xcdUQ4MDZcXHVEQ0Q4JywnXFx1RDgwNlxcdURDQjknOidcXHVEODA2XFx1RENEOScsJ1xcdUQ4MDZcXHVEQ0JBJzonXFx1RDgwNlxcdURDREEnLCdcXHVEODA2XFx1RENCQic6J1xcdUQ4MDZcXHVEQ0RCJywnXFx1RDgwNlxcdURDQkMnOidcXHVEODA2XFx1RENEQycsJ1xcdUQ4MDZcXHVEQ0JEJzonXFx1RDgwNlxcdURDREQnLCdcXHVEODA2XFx1RENCRSc6J1xcdUQ4MDZcXHVEQ0RFJywnXFx1RDgwNlxcdURDQkYnOidcXHVEODA2XFx1RENERicsJ1xceERGJzonc3MnLCdcXHUwMTMwJzonaVxcdTAzMDcnLCdcXHUwMTQ5JzonXFx1MDJCQ24nLCdcXHUwMUYwJzonalxcdTAzMEMnLCdcXHUwMzkwJzonXFx1MDNCOVxcdTAzMDhcXHUwMzAxJywnXFx1MDNCMCc6J1xcdTAzQzVcXHUwMzA4XFx1MDMwMScsJ1xcdTA1ODcnOidcXHUwNTY1XFx1MDU4MicsJ1xcdTFFOTYnOidoXFx1MDMzMScsJ1xcdTFFOTcnOid0XFx1MDMwOCcsJ1xcdTFFOTgnOid3XFx1MDMwQScsJ1xcdTFFOTknOid5XFx1MDMwQScsJ1xcdTFFOUEnOidhXFx1MDJCRScsJ1xcdTFFOUUnOidzcycsJ1xcdTFGNTAnOidcXHUwM0M1XFx1MDMxMycsJ1xcdTFGNTInOidcXHUwM0M1XFx1MDMxM1xcdTAzMDAnLCdcXHUxRjU0JzonXFx1MDNDNVxcdTAzMTNcXHUwMzAxJywnXFx1MUY1Nic6J1xcdTAzQzVcXHUwMzEzXFx1MDM0MicsJ1xcdTFGODAnOidcXHUxRjAwXFx1MDNCOScsJ1xcdTFGODEnOidcXHUxRjAxXFx1MDNCOScsJ1xcdTFGODInOidcXHUxRjAyXFx1MDNCOScsJ1xcdTFGODMnOidcXHUxRjAzXFx1MDNCOScsJ1xcdTFGODQnOidcXHUxRjA0XFx1MDNCOScsJ1xcdTFGODUnOidcXHUxRjA1XFx1MDNCOScsJ1xcdTFGODYnOidcXHUxRjA2XFx1MDNCOScsJ1xcdTFGODcnOidcXHUxRjA3XFx1MDNCOScsJ1xcdTFGODgnOidcXHUxRjAwXFx1MDNCOScsJ1xcdTFGODknOidcXHUxRjAxXFx1MDNCOScsJ1xcdTFGOEEnOidcXHUxRjAyXFx1MDNCOScsJ1xcdTFGOEInOidcXHUxRjAzXFx1MDNCOScsJ1xcdTFGOEMnOidcXHUxRjA0XFx1MDNCOScsJ1xcdTFGOEQnOidcXHUxRjA1XFx1MDNCOScsJ1xcdTFGOEUnOidcXHUxRjA2XFx1MDNCOScsJ1xcdTFGOEYnOidcXHUxRjA3XFx1MDNCOScsJ1xcdTFGOTAnOidcXHUxRjIwXFx1MDNCOScsJ1xcdTFGOTEnOidcXHUxRjIxXFx1MDNCOScsJ1xcdTFGOTInOidcXHUxRjIyXFx1MDNCOScsJ1xcdTFGOTMnOidcXHUxRjIzXFx1MDNCOScsJ1xcdTFGOTQnOidcXHUxRjI0XFx1MDNCOScsJ1xcdTFGOTUnOidcXHUxRjI1XFx1MDNCOScsJ1xcdTFGOTYnOidcXHUxRjI2XFx1MDNCOScsJ1xcdTFGOTcnOidcXHUxRjI3XFx1MDNCOScsJ1xcdTFGOTgnOidcXHUxRjIwXFx1MDNCOScsJ1xcdTFGOTknOidcXHUxRjIxXFx1MDNCOScsJ1xcdTFGOUEnOidcXHUxRjIyXFx1MDNCOScsJ1xcdTFGOUInOidcXHUxRjIzXFx1MDNCOScsJ1xcdTFGOUMnOidcXHUxRjI0XFx1MDNCOScsJ1xcdTFGOUQnOidcXHUxRjI1XFx1MDNCOScsJ1xcdTFGOUUnOidcXHUxRjI2XFx1MDNCOScsJ1xcdTFGOUYnOidcXHUxRjI3XFx1MDNCOScsJ1xcdTFGQTAnOidcXHUxRjYwXFx1MDNCOScsJ1xcdTFGQTEnOidcXHUxRjYxXFx1MDNCOScsJ1xcdTFGQTInOidcXHUxRjYyXFx1MDNCOScsJ1xcdTFGQTMnOidcXHUxRjYzXFx1MDNCOScsJ1xcdTFGQTQnOidcXHUxRjY0XFx1MDNCOScsJ1xcdTFGQTUnOidcXHUxRjY1XFx1MDNCOScsJ1xcdTFGQTYnOidcXHUxRjY2XFx1MDNCOScsJ1xcdTFGQTcnOidcXHUxRjY3XFx1MDNCOScsJ1xcdTFGQTgnOidcXHUxRjYwXFx1MDNCOScsJ1xcdTFGQTknOidcXHUxRjYxXFx1MDNCOScsJ1xcdTFGQUEnOidcXHUxRjYyXFx1MDNCOScsJ1xcdTFGQUInOidcXHUxRjYzXFx1MDNCOScsJ1xcdTFGQUMnOidcXHUxRjY0XFx1MDNCOScsJ1xcdTFGQUQnOidcXHUxRjY1XFx1MDNCOScsJ1xcdTFGQUUnOidcXHUxRjY2XFx1MDNCOScsJ1xcdTFGQUYnOidcXHUxRjY3XFx1MDNCOScsJ1xcdTFGQjInOidcXHUxRjcwXFx1MDNCOScsJ1xcdTFGQjMnOidcXHUwM0IxXFx1MDNCOScsJ1xcdTFGQjQnOidcXHUwM0FDXFx1MDNCOScsJ1xcdTFGQjYnOidcXHUwM0IxXFx1MDM0MicsJ1xcdTFGQjcnOidcXHUwM0IxXFx1MDM0MlxcdTAzQjknLCdcXHUxRkJDJzonXFx1MDNCMVxcdTAzQjknLCdcXHUxRkMyJzonXFx1MUY3NFxcdTAzQjknLCdcXHUxRkMzJzonXFx1MDNCN1xcdTAzQjknLCdcXHUxRkM0JzonXFx1MDNBRVxcdTAzQjknLCdcXHUxRkM2JzonXFx1MDNCN1xcdTAzNDInLCdcXHUxRkM3JzonXFx1MDNCN1xcdTAzNDJcXHUwM0I5JywnXFx1MUZDQyc6J1xcdTAzQjdcXHUwM0I5JywnXFx1MUZEMic6J1xcdTAzQjlcXHUwMzA4XFx1MDMwMCcsJ1xcdTFGRDMnOidcXHUwM0I5XFx1MDMwOFxcdTAzMDEnLCdcXHUxRkQ2JzonXFx1MDNCOVxcdTAzNDInLCdcXHUxRkQ3JzonXFx1MDNCOVxcdTAzMDhcXHUwMzQyJywnXFx1MUZFMic6J1xcdTAzQzVcXHUwMzA4XFx1MDMwMCcsJ1xcdTFGRTMnOidcXHUwM0M1XFx1MDMwOFxcdTAzMDEnLCdcXHUxRkU0JzonXFx1MDNDMVxcdTAzMTMnLCdcXHUxRkU2JzonXFx1MDNDNVxcdTAzNDInLCdcXHUxRkU3JzonXFx1MDNDNVxcdTAzMDhcXHUwMzQyJywnXFx1MUZGMic6J1xcdTFGN0NcXHUwM0I5JywnXFx1MUZGMyc6J1xcdTAzQzlcXHUwM0I5JywnXFx1MUZGNCc6J1xcdTAzQ0VcXHUwM0I5JywnXFx1MUZGNic6J1xcdTAzQzlcXHUwMzQyJywnXFx1MUZGNyc6J1xcdTAzQzlcXHUwMzQyXFx1MDNCOScsJ1xcdTFGRkMnOidcXHUwM0M5XFx1MDNCOScsJ1xcdUZCMDAnOidmZicsJ1xcdUZCMDEnOidmaScsJ1xcdUZCMDInOidmbCcsJ1xcdUZCMDMnOidmZmknLCdcXHVGQjA0JzonZmZsJywnXFx1RkIwNSc6J3N0JywnXFx1RkIwNic6J3N0JywnXFx1RkIxMyc6J1xcdTA1NzRcXHUwNTc2JywnXFx1RkIxNCc6J1xcdTA1NzRcXHUwNTY1JywnXFx1RkIxNSc6J1xcdTA1NzRcXHUwNTZCJywnXFx1RkIxNic6J1xcdTA1N0VcXHUwNTc2JywnXFx1RkIxNyc6J1xcdTA1NzRcXHUwNTZEJ307XG5cbi8vIE5vcm1hbGl6ZSByZWZlcmVuY2UgbGFiZWw6IGNvbGxhcHNlIGludGVybmFsIHdoaXRlc3BhY2Vcbi8vIHRvIHNpbmdsZSBzcGFjZSwgcmVtb3ZlIGxlYWRpbmcvdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FzZSBmb2xkLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDEsIHN0cmluZy5sZW5ndGggLSAxKS50cmltKCkucmVwbGFjZShyZWdleCwgZnVuY3Rpb24oJDApIHtcbiAgICAgICAgLy8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzT3duUHJvcGVydHkoJDApYCBoZXJlLlxuICAgICAgICAvLyBJZiBjaGFyYWN0ZXIgbm90IGZvdW5kIGluIGxvb2t1cCB0YWJsZSwgaXQgbXVzdCBiZSB3aGl0ZXNwYWNlLlxuICAgICAgICByZXR1cm4gbWFwWyQwXSB8fCAnICc7XG4gICAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29tbW9ubWFyay9saWIvbm9ybWFsaXplLXJlZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGRlcml2ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcuZnJvbUNvZGVQb2ludFxuLyohIGh0dHA6Ly9tdGhzLmJlL2Zyb21jb2RlcG9pbnQgdjAuMi4xIGJ5IEBtYXRoaWFzICovXG5pZiAoU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcblxufSBlbHNlIHtcblxuICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMDtcbiAgICAgIHZhciBjb2RlVW5pdHMgPSBbXTtcbiAgICAgIHZhciBoaWdoU3Vycm9nYXRlO1xuICAgICAgdmFyIGxvd1N1cnJvZ2F0ZTtcbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA8IDAgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPiAweDEwRkZGRiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgIGZsb29yKGNvZGVQb2ludCkgIT09IGNvZGVQb2ludCAvLyBub3QgYW4gaW50ZWdlclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4RkZGRikgeyAvLyBCTVAgY29kZSBwb2ludFxuICAgICAgICAgICAgICBjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIEFzdHJhbCBjb2RlIHBvaW50OyBzcGxpdCBpbiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgICAgICAgIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDA7XG4gICAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweERDMDA7XG4gICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRleCArIDEgPT09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlVW5pdHMpO1xuICAgICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtb2R1bGUuZXhwb3J0cyA9IGZyb21Db2RlUG9pbnQ7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb21tb25tYXJrL2xpYi9mcm9tLWNvZGUtcG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qISBodHRwOi8vbXRocy5iZS9yZXBlYXQgdjAuMi4wIGJ5IEBtYXRoaWFzICovXG5pZiAoIVN0cmluZy5wcm90b3R5cGUucmVwZWF0KSB7XG5cdChmdW5jdGlvbigpIHtcblx0XHQndXNlIHN0cmljdCc7IC8vIG5lZWRlZCB0byBzdXBwb3J0IGBhcHBseWAvYGNhbGxgIHdpdGggYHVuZGVmaW5lZGAvYG51bGxgXG5cdFx0dmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gSUUgOCBvbmx5IHN1cHBvcnRzIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG9uIERPTSBlbGVtZW50c1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0XHR2YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gJGRlZmluZVByb3BlcnR5KG9iamVjdCwgb2JqZWN0LCBvYmplY3QpICYmICRkZWZpbmVQcm9wZXJ0eTtcblx0XHRcdH0gY2F0Y2goZXJyb3IpIHt9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0oKSk7XG5cdFx0dmFyIHJlcGVhdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG5cdFx0XHRpZiAodGhpcyA9PSBudWxsKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcigpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcblx0XHRcdC8vIGBUb0ludGVnZXJgXG5cdFx0XHR2YXIgbiA9IGNvdW50ID8gTnVtYmVyKGNvdW50KSA6IDA7XG5cdFx0XHRpZiAobiAhPSBuKSB7IC8vIGJldHRlciBgaXNOYU5gXG5cdFx0XHRcdG4gPSAwO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWNjb3VudCBmb3Igb3V0LW9mLWJvdW5kcyBpbmRpY2VzXG5cdFx0XHRpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkge1xuXHRcdFx0XHR0aHJvdyBSYW5nZUVycm9yKCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0XHR3aGlsZSAobikge1xuXHRcdFx0XHRpZiAobiAlIDIgPT0gMSkge1xuXHRcdFx0XHRcdHJlc3VsdCArPSBzdHJpbmc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG4gPiAxKSB7XG5cdFx0XHRcdFx0c3RyaW5nICs9IHN0cmluZztcblx0XHRcdFx0fVxuXHRcdFx0XHRuID4+PSAxO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdGlmIChkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgJ3JlcGVhdCcsIHtcblx0XHRcdFx0J3ZhbHVlJzogcmVwZWF0LFxuXHRcdFx0XHQnY29uZmlndXJhYmxlJzogdHJ1ZSxcblx0XHRcdFx0J3dyaXRhYmxlJzogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFN0cmluZy5wcm90b3R5cGUucmVwZWF0ID0gcmVwZWF0O1xuXHRcdH1cblx0fSgpKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0cmluZy5wcm90b3R5cGUucmVwZWF0L3JlcGVhdC5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXInKTtcblxudmFyIHJlVW5zYWZlUHJvdG9jb2wgPSAvXmphdmFzY3JpcHQ6fHZic2NyaXB0OnxmaWxlOnxkYXRhOi9pO1xudmFyIHJlU2FmZURhdGFQcm90b2NvbCA9IC9eZGF0YTppbWFnZVxcLyg/OnBuZ3xnaWZ8anBlZ3x3ZWJwKS9pO1xuXG52YXIgcG90ZW50aWFsbHlVbnNhZmUgPSBmdW5jdGlvbih1cmwpIHtcbiAgcmV0dXJuIHJlVW5zYWZlUHJvdG9jb2wudGVzdCh1cmwpICYmXG4gICAgICAhcmVTYWZlRGF0YVByb3RvY29sLnRlc3QodXJsKTtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwcm9kdWNlIGFuIEhUTUwgdGFnLlxuZnVuY3Rpb24gdGFnKG5hbWUsIGF0dHJzLCBzZWxmY2xvc2luZykge1xuICBpZiAodGhpcy5kaXNhYmxlVGFncyA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5idWZmZXIgKz0gKCc8JyArIG5hbWUpO1xuICBpZiAoYXR0cnMgJiYgYXR0cnMubGVuZ3RoID4gMCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYXR0cmliO1xuICAgIHdoaWxlICgoYXR0cmliID0gYXR0cnNbaV0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYnVmZmVyICs9ICgnICcgKyBhdHRyaWJbMF0gKyAnPVwiJyArIGF0dHJpYlsxXSArICdcIicpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuICBpZiAoc2VsZmNsb3NpbmcpIHtcbiAgICB0aGlzLmJ1ZmZlciArPSAnIC8nO1xuICB9XG4gIHRoaXMuYnVmZmVyICs9ICc+JztcbiAgdGhpcy5sYXN0T3V0ID0gJz4nO1xufVxuXG5mdW5jdGlvbiBIdG1sUmVuZGVyZXIob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgLy8gYnkgZGVmYXVsdCwgc29mdCBicmVha3MgYXJlIHJlbmRlcmVkIGFzIG5ld2xpbmVzIGluIEhUTUxcbiAgb3B0aW9ucy5zb2Z0YnJlYWsgPSBvcHRpb25zLnNvZnRicmVhayB8fCAnXFxuJztcbiAgLy8gc2V0IHRvIFwiPGJyIC8+XCIgdG8gbWFrZSB0aGVtIGhhcmQgYnJlYWtzXG4gIC8vIHNldCB0byBcIiBcIiBpZiB5b3Ugd2FudCB0byBpZ25vcmUgbGluZSB3cmFwcGluZyBpbiBzb3VyY2VcblxuICB0aGlzLmRpc2FibGVUYWdzID0gMDtcbiAgdGhpcy5sYXN0T3V0ID0gXCJcXG5cIjtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbn1cblxuLyogTm9kZSBtZXRob2RzICovXG5cbmZ1bmN0aW9uIHRleHQobm9kZSkge1xuICB0aGlzLm91dChub2RlLmxpdGVyYWwpO1xufVxuXG5mdW5jdGlvbiBzb2Z0YnJlYWsoKSB7XG4gIHRoaXMubGl0KHRoaXMub3B0aW9ucy5zb2Z0YnJlYWspO1xufVxuXG5mdW5jdGlvbiBsaW5lYnJlYWsoKSB7XG4gIHRoaXMudGFnKCdicicsIFtdLCB0cnVlKTtcbiAgdGhpcy5jcigpO1xufVxuXG5mdW5jdGlvbiBsaW5rKG5vZGUsIGVudGVyaW5nKSB7XG4gIHZhciBhdHRycyA9IHRoaXMuYXR0cnMobm9kZSk7XG4gIGlmIChlbnRlcmluZykge1xuICAgIGlmICghKHRoaXMub3B0aW9ucy5zYWZlICYmIHBvdGVudGlhbGx5VW5zYWZlKG5vZGUuZGVzdGluYXRpb24pKSkge1xuICAgICAgYXR0cnMucHVzaChbJ2hyZWYnLCB0aGlzLmVzYyhub2RlLmRlc3RpbmF0aW9uLCB0cnVlKV0pO1xuICAgIH1cbiAgICBpZiAobm9kZS50aXRsZSkge1xuICAgICAgYXR0cnMucHVzaChbJ3RpdGxlJywgdGhpcy5lc2Mobm9kZS50aXRsZSwgdHJ1ZSldKTtcbiAgICB9XG4gICAgdGhpcy50YWcoJ2EnLCBhdHRycyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWcoJy9hJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW1hZ2Uobm9kZSwgZW50ZXJpbmcpIHtcbiAgaWYgKGVudGVyaW5nKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZVRhZ3MgPT09IDApIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2FmZSAmJiBwb3RlbnRpYWxseVVuc2FmZShub2RlLmRlc3RpbmF0aW9uKSkge1xuICAgICAgICB0aGlzLmxpdCgnPGltZyBzcmM9XCJcIiBhbHQ9XCInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGl0KCc8aW1nIHNyYz1cIicgKyB0aGlzLmVzYyhub2RlLmRlc3RpbmF0aW9uLCB0cnVlKSArXG4gICAgICAgICAgICAnXCIgYWx0PVwiJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVRhZ3MgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRpc2FibGVUYWdzIC09IDE7XG4gICAgaWYgKHRoaXMuZGlzYWJsZVRhZ3MgPT09IDApIHtcbiAgICAgIGlmIChub2RlLnRpdGxlKSB7XG4gICAgICAgIHRoaXMubGl0KCdcIiB0aXRsZT1cIicgKyB0aGlzLmVzYyhub2RlLnRpdGxlLCB0cnVlKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxpdCgnXCIgLz4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1waChub2RlLCBlbnRlcmluZykge1xuICB0aGlzLnRhZyhlbnRlcmluZyA/ICdlbScgOiAnL2VtJyk7XG59XG5cbmZ1bmN0aW9uIHN0cm9uZyhub2RlLCBlbnRlcmluZykge1xuICB0aGlzLnRhZyhlbnRlcmluZyA/ICdzdHJvbmcnIDogJy9zdHJvbmcnKTtcbn1cblxuZnVuY3Rpb24gcGFyYWdyYXBoKG5vZGUsIGVudGVyaW5nKSB7XG4gIHZhciBncmFuZHBhcmVudCA9IG5vZGUucGFyZW50LnBhcmVudFxuICAgICwgYXR0cnMgPSB0aGlzLmF0dHJzKG5vZGUpO1xuICBpZiAoZ3JhbmRwYXJlbnQgIT09IG51bGwgJiZcbiAgICBncmFuZHBhcmVudC50eXBlID09PSAnbGlzdCcpIHtcbiAgICBpZiAoZ3JhbmRwYXJlbnQubGlzdFRpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChlbnRlcmluZykge1xuICAgIHRoaXMuY3IoKTtcbiAgICB0aGlzLnRhZygncCcsIGF0dHJzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhZygnL3AnKTtcbiAgICB0aGlzLmNyKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGVhZGluZyhub2RlLCBlbnRlcmluZykge1xuICB2YXIgdGFnbmFtZSA9ICdoJyArIG5vZGUubGV2ZWxcbiAgICAsIGF0dHJzID0gdGhpcy5hdHRycyhub2RlKTtcbiAgaWYgKGVudGVyaW5nKSB7XG4gICAgdGhpcy5jcigpO1xuICAgIHRoaXMudGFnKHRhZ25hbWUsIGF0dHJzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhZygnLycgKyB0YWduYW1lKTtcbiAgICB0aGlzLmNyKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29kZShub2RlKSB7XG4gIHRoaXMudGFnKCdjb2RlJyk7XG4gIHRoaXMub3V0KG5vZGUubGl0ZXJhbCk7XG4gIHRoaXMudGFnKCcvY29kZScpO1xufVxuXG5mdW5jdGlvbiBjb2RlX2Jsb2NrKG5vZGUpIHtcbiAgdmFyIGluZm9fd29yZHMgPSBub2RlLmluZm8gPyBub2RlLmluZm8uc3BsaXQoL1xccysvKSA6IFtdXG4gICAgLCBhdHRycyA9IHRoaXMuYXR0cnMobm9kZSk7XG4gIGlmIChpbmZvX3dvcmRzLmxlbmd0aCA+IDAgJiYgaW5mb193b3Jkc1swXS5sZW5ndGggPiAwKSB7XG4gICAgYXR0cnMucHVzaChbJ2NsYXNzJywgJ2xhbmd1YWdlLScgKyB0aGlzLmVzYyhpbmZvX3dvcmRzWzBdLCB0cnVlKV0pO1xuICB9XG4gIHRoaXMuY3IoKTtcbiAgdGhpcy50YWcoJ3ByZScpO1xuICB0aGlzLnRhZygnY29kZScsIGF0dHJzKTtcbiAgdGhpcy5vdXQobm9kZS5saXRlcmFsKTtcbiAgdGhpcy50YWcoJy9jb2RlJyk7XG4gIHRoaXMudGFnKCcvcHJlJyk7XG4gIHRoaXMuY3IoKTtcbn1cblxuZnVuY3Rpb24gdGhlbWF0aWNfYnJlYWsobm9kZSkge1xuICB2YXIgYXR0cnMgPSB0aGlzLmF0dHJzKG5vZGUpO1xuICB0aGlzLmNyKCk7XG4gIHRoaXMudGFnKCdocicsIGF0dHJzLCB0cnVlKTtcbiAgdGhpcy5jcigpO1xufVxuXG5mdW5jdGlvbiBibG9ja19xdW90ZShub2RlLCBlbnRlcmluZykge1xuICB2YXIgYXR0cnMgPSB0aGlzLmF0dHJzKG5vZGUpO1xuICBpZiAoZW50ZXJpbmcpIHtcbiAgICB0aGlzLmNyKCk7XG4gICAgdGhpcy50YWcoJ2Jsb2NrcXVvdGUnLCBhdHRycyk7XG4gICAgdGhpcy5jcigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY3IoKTtcbiAgICB0aGlzLnRhZygnL2Jsb2NrcXVvdGUnKTtcbiAgICB0aGlzLmNyKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGlzdChub2RlLCBlbnRlcmluZykge1xuICB2YXIgdGFnbmFtZSA9IG5vZGUubGlzdFR5cGUgPT09ICdidWxsZXQnID8gJ3VsJyA6ICdvbCdcbiAgICAsIGF0dHJzID0gdGhpcy5hdHRycyhub2RlKTtcblxuICBpZiAoZW50ZXJpbmcpIHtcbiAgICB2YXIgc3RhcnQgPSBub2RlLmxpc3RTdGFydDtcbiAgICBpZiAoc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IDEpIHtcbiAgICAgIGF0dHJzLnB1c2goWydzdGFydCcsIHN0YXJ0LnRvU3RyaW5nKCldKTtcbiAgICB9XG4gICAgdGhpcy5jcigpO1xuICAgIHRoaXMudGFnKHRhZ25hbWUsIGF0dHJzKTtcbiAgICB0aGlzLmNyKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jcigpO1xuICAgIHRoaXMudGFnKCcvJyArIHRhZ25hbWUpO1xuICAgIHRoaXMuY3IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpdGVtKG5vZGUsIGVudGVyaW5nKSB7XG4gIHZhciBhdHRycyA9IHRoaXMuYXR0cnMobm9kZSk7XG4gIGlmIChlbnRlcmluZykge1xuICAgIHRoaXMudGFnKCdsaScsIGF0dHJzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhZygnL2xpJyk7XG4gICAgdGhpcy5jcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGh0bWxfaW5saW5lKG5vZGUpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5zYWZlKSB7XG4gICAgdGhpcy5saXQoJzwhLS0gcmF3IEhUTUwgb21pdHRlZCAtLT4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxpdChub2RlLmxpdGVyYWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGh0bWxfYmxvY2sobm9kZSkge1xuICB0aGlzLmNyKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuc2FmZSkge1xuICAgIHRoaXMubGl0KCc8IS0tIHJhdyBIVE1MIG9taXR0ZWQgLS0+Jyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5saXQobm9kZS5saXRlcmFsKTtcbiAgfVxuICB0aGlzLmNyKCk7XG59XG5cbmZ1bmN0aW9uIGN1c3RvbV9pbmxpbmUobm9kZSwgZW50ZXJpbmcpIHtcbiAgaWYgKGVudGVyaW5nICYmIG5vZGUub25FbnRlcikge1xuICAgIHRoaXMubGl0KG5vZGUub25FbnRlcik7XG4gIH0gZWxzZSBpZiAoIWVudGVyaW5nICYmIG5vZGUub25FeGl0KSB7XG4gICAgdGhpcy5saXQobm9kZS5vbkV4aXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGN1c3RvbV9ibG9jayhub2RlLCBlbnRlcmluZykge1xuICB0aGlzLmNyKCk7XG4gIGlmIChlbnRlcmluZyAmJiBub2RlLm9uRW50ZXIpIHtcbiAgICB0aGlzLmxpdChub2RlLm9uRW50ZXIpO1xuICB9IGVsc2UgaWYgKCFlbnRlcmluZyAmJiBub2RlLm9uRXhpdCkge1xuICAgIHRoaXMubGl0KG5vZGUub25FeGl0KTtcbiAgfVxuICB0aGlzLmNyKCk7XG59XG5cbi8qIEhlbHBlciBtZXRob2RzICovXG5cbmZ1bmN0aW9uIG91dChzKSB7XG4gIHRoaXMubGl0KHRoaXMuZXNjKHMsIGZhbHNlKSk7XG59XG5cbmZ1bmN0aW9uIGF0dHJzIChub2RlKSB7XG4gIHZhciBhdHQgPSBbXTtcbiAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2Vwb3MpIHtcbiAgICB2YXIgcG9zID0gbm9kZS5zb3VyY2Vwb3M7XG4gICAgaWYgKHBvcykge1xuICAgICAgYXR0LnB1c2goWydkYXRhLXNvdXJjZXBvcycsIFN0cmluZyhwb3NbMF1bMF0pICsgJzonICtcbiAgICAgICAgU3RyaW5nKHBvc1swXVsxXSkgKyAnLScgKyBTdHJpbmcocG9zWzFdWzBdKSArICc6JyArXG4gICAgICAgIFN0cmluZyhwb3NbMV1bMV0pXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhdHQ7XG59XG5cbi8vIHF1aWNrIGJyb3dzZXItY29tcGF0aWJsZSBpbmhlcml0YW5jZVxuSHRtbFJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVuZGVyZXIucHJvdG90eXBlKTtcblxuSHRtbFJlbmRlcmVyLnByb3RvdHlwZS50ZXh0ID0gdGV4dDtcbkh0bWxSZW5kZXJlci5wcm90b3R5cGUuaHRtbF9pbmxpbmUgPSBodG1sX2lubGluZTtcbkh0bWxSZW5kZXJlci5wcm90b3R5cGUuaHRtbF9ibG9jayA9IGh0bWxfYmxvY2s7XG5IdG1sUmVuZGVyZXIucHJvdG90eXBlLnNvZnRicmVhayA9IHNvZnRicmVhaztcbkh0bWxSZW5kZXJlci5wcm90b3R5cGUubGluZWJyZWFrID0gbGluZWJyZWFrO1xuSHRtbFJlbmRlcmVyLnByb3RvdHlwZS5saW5rID0gbGluaztcbkh0bWxSZW5kZXJlci5wcm90b3R5cGUuaW1hZ2UgPSBpbWFnZTtcbkh0bWxSZW5kZXJlci5wcm90b3R5cGUuZW1waCA9IGVtcGg7XG5IdG1sUmVuZGVyZXIucHJvdG90eXBlLnN0cm9uZyA9IHN0cm9uZztcbkh0bWxSZW5kZXJlci5wcm90b3R5cGUucGFyYWdyYXBoID0gcGFyYWdyYXBoO1xuSHRtbFJlbmRlcmVyLnByb3RvdHlwZS5oZWFkaW5nID0gaGVhZGluZztcbkh0bWxSZW5kZXJlci5wcm90b3R5cGUuY29kZSA9IGNvZGU7XG5IdG1sUmVuZGVyZXIucHJvdG90eXBlLmNvZGVfYmxvY2sgPSBjb2RlX2Jsb2NrO1xuSHRtbFJlbmRlcmVyLnByb3RvdHlwZS50aGVtYXRpY19icmVhayA9IHRoZW1hdGljX2JyZWFrO1xuSHRtbFJlbmRlcmVyLnByb3RvdHlwZS5ibG9ja19xdW90ZSA9IGJsb2NrX3F1b3RlO1xuSHRtbFJlbmRlcmVyLnByb3RvdHlwZS5saXN0ID0gbGlzdDtcbkh0bWxSZW5kZXJlci5wcm90b3R5cGUuaXRlbSA9IGl0ZW07XG5IdG1sUmVuZGVyZXIucHJvdG90eXBlLmN1c3RvbV9pbmxpbmUgPSBjdXN0b21faW5saW5lO1xuSHRtbFJlbmRlcmVyLnByb3RvdHlwZS5jdXN0b21fYmxvY2sgPSBjdXN0b21fYmxvY2s7XG5cbkh0bWxSZW5kZXJlci5wcm90b3R5cGUuZXNjID0gcmVxdWlyZSgnLi4vY29tbW9uJykuZXNjYXBlWG1sO1xuXG5IdG1sUmVuZGVyZXIucHJvdG90eXBlLm91dCA9IG91dDtcbkh0bWxSZW5kZXJlci5wcm90b3R5cGUudGFnID0gdGFnO1xuSHRtbFJlbmRlcmVyLnByb3RvdHlwZS5hdHRycyA9IGF0dHJzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxSZW5kZXJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvbW1vbm1hcmsvbGliL3JlbmRlci9odG1sLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xuXG52YXIgcmVYTUxUYWcgPSAvXFw8W14+XSpcXD4vO1xuXG5mdW5jdGlvbiB0b1RhZ05hbWUocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxXyQyXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIFhtbFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5kaXNhYmxlVGFncyA9IDA7XG4gIHRoaXMubGFzdE91dCA9IFwiXFxuXCI7XG5cbiAgdGhpcy5pbmRlbnRMZXZlbCA9IDA7XG4gIHRoaXMuaW5kZW50ID0gJyAgJztcblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiByZW5kZXIoYXN0KSB7XG5cbiAgdGhpcy5idWZmZXIgPSAnJztcblxuICB2YXIgYXR0cnM7XG4gIHZhciB0YWduYW1lO1xuICB2YXIgd2Fsa2VyID0gYXN0LndhbGtlcigpO1xuICB2YXIgZXZlbnQsIG5vZGUsIGVudGVyaW5nO1xuICB2YXIgY29udGFpbmVyO1xuICB2YXIgc2VsZkNsb3Npbmc7XG4gIHZhciBub2RldHlwZTtcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0aW9ucy50aW1lKSB7IGNvbnNvbGUudGltZShcInJlbmRlcmluZ1wiKTsgfVxuXG4gIHRoaXMuYnVmZmVyICs9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz5cXG4nO1xuICB0aGlzLmJ1ZmZlciArPSAnPCFET0NUWVBFIGRvY3VtZW50IFNZU1RFTSBcIkNvbW1vbk1hcmsuZHRkXCI+XFxuJztcblxuICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nO1xuICAgIG5vZGUgPSBldmVudC5ub2RlO1xuICAgIG5vZGV0eXBlID0gbm9kZS50eXBlO1xuXG4gICAgY29udGFpbmVyID0gbm9kZS5pc0NvbnRhaW5lcjtcblxuICAgIHNlbGZDbG9zaW5nID0gbm9kZXR5cGUgPT09ICd0aGVtYXRpY19icmVhaydcbiAgICAgIHx8IG5vZGV0eXBlID09PSAnbGluZWJyZWFrJ1xuICAgICAgfHwgbm9kZXR5cGUgPT09ICdzb2Z0YnJlYWsnO1xuXG4gICAgdGFnbmFtZSA9IHRvVGFnTmFtZShub2RldHlwZSk7XG5cbiAgICBpZiAoZW50ZXJpbmcpIHtcblxuICAgICAgICBhdHRycyA9IFtdO1xuXG4gICAgICAgIHN3aXRjaCAobm9kZXR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICBhdHRycy5wdXNoKFsneG1sbnMnLCAnaHR0cDovL2NvbW1vbm1hcmsub3JnL3htbC8xLjAnXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgICAgIGlmIChub2RlLmxpc3RUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGF0dHJzLnB1c2goWyd0eXBlJywgbm9kZS5saXN0VHlwZS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5saXN0U3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYXR0cnMucHVzaChbJ3N0YXJ0JywgU3RyaW5nKG5vZGUubGlzdFN0YXJ0KV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUubGlzdFRpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGF0dHJzLnB1c2goWyd0aWdodCcsIChub2RlLmxpc3RUaWdodCA/ICd0cnVlJyA6ICdmYWxzZScpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVsaW0gPSBub2RlLmxpc3REZWxpbWl0ZXI7XG4gICAgICAgICAgICBpZiAoZGVsaW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGRlbGltd29yZCA9ICcnO1xuICAgICAgICAgICAgICBpZiAoZGVsaW0gPT09ICcuJykge1xuICAgICAgICAgICAgICAgIGRlbGltd29yZCA9ICdwZXJpb2QnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGltd29yZCA9ICdwYXJlbic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXR0cnMucHVzaChbJ2RlbGltaXRlcicsIGRlbGltd29yZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY29kZV9ibG9jayc6XG4gICAgICAgICAgICBpZiAobm9kZS5pbmZvKSB7XG4gICAgICAgICAgICAgIGF0dHJzLnB1c2goWydpbmZvJywgbm9kZS5pbmZvXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIGF0dHJzLnB1c2goWydsZXZlbCcsIFN0cmluZyhub2RlLmxldmVsKV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgYXR0cnMucHVzaChbJ2Rlc3RpbmF0aW9uJywgbm9kZS5kZXN0aW5hdGlvbl0pO1xuICAgICAgICAgICAgYXR0cnMucHVzaChbJ3RpdGxlJywgbm9kZS50aXRsZV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY3VzdG9tX2lubGluZSc6XG4gICAgICAgICAgY2FzZSAnY3VzdG9tX2Jsb2NrJzpcbiAgICAgICAgICAgIGF0dHJzLnB1c2goWydvbl9lbnRlcicsIG5vZGUub25FbnRlcl0pO1xuICAgICAgICAgICAgYXR0cnMucHVzaChbJ29uX2V4aXQnLCBub2RlLm9uRXhpdF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZXBvcykge1xuICAgICAgICAgIHZhciBwb3MgPSBub2RlLnNvdXJjZXBvcztcbiAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICBhdHRycy5wdXNoKFsnc291cmNlcG9zJywgU3RyaW5nKHBvc1swXVswXSkgKyAnOicgK1xuICAgICAgICAgICAgICBTdHJpbmcocG9zWzBdWzFdKSArICctJyArIFN0cmluZyhwb3NbMV1bMF0pICsgJzonICtcbiAgICAgICAgICAgICAgU3RyaW5nKHBvc1sxXVsxXSldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNyKCk7XG4gICAgICAgIHRoaXMub3V0KHRoaXMudGFnKHRhZ25hbWUsIGF0dHJzLCBzZWxmQ2xvc2luZykpO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgdGhpcy5pbmRlbnRMZXZlbCArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKCFjb250YWluZXIgJiYgIXNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgdmFyIGxpdCA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgICBpZiAobGl0KSB7XG4gICAgICAgICAgICB0aGlzLm91dCh0aGlzLmVzYyhsaXQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vdXQodGhpcy50YWcoJy8nICsgdGFnbmFtZSkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5kZW50TGV2ZWwgLT0gMTtcbiAgICAgIHRoaXMuY3IoKTtcbiAgICAgIHRoaXMub3V0KHRoaXMudGFnKCcvJyArIHRhZ25hbWUpKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMudGltZSkgeyBjb25zb2xlLnRpbWVFbmQoXCJyZW5kZXJpbmdcIik7IH1cbiAgdGhpcy5idWZmZXIgKz0gJ1xcbic7XG4gIHJldHVybiB0aGlzLmJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gb3V0KHMpIHtcbiAgaWYodGhpcy5kaXNhYmxlVGFncyA+IDApIHtcbiAgICB0aGlzLmJ1ZmZlciArPSBzLnJlcGxhY2UocmVYTUxUYWcsICcnKTtcbiAgfWVsc2V7XG4gICAgdGhpcy5idWZmZXIgKz0gcztcbiAgfVxuICB0aGlzLmxhc3RPdXQgPSBzO1xufVxuXG5mdW5jdGlvbiBjcigpIHtcbiAgaWYodGhpcy5sYXN0T3V0ICE9PSAnXFxuJykge1xuICAgIHRoaXMuYnVmZmVyICs9ICdcXG4nO1xuICAgIHRoaXMubGFzdE91dCA9ICdcXG4nO1xuICAgIGZvcih2YXIgaSA9IHRoaXMuaW5kZW50TGV2ZWw7IGkgPiAwOyBpLS0pIHtcbiAgICAgIHRoaXMuYnVmZmVyICs9IHRoaXMuaW5kZW50O1xuICAgIH1cbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gcHJvZHVjZSBhbiBYTUwgdGFnLlxuZnVuY3Rpb24gdGFnKG5hbWUsIGF0dHJzLCBzZWxmY2xvc2luZykge1xuICB2YXIgcmVzdWx0ID0gJzwnICsgbmFtZTtcbiAgaWYoYXR0cnMgJiYgYXR0cnMubGVuZ3RoID4gMCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYXR0cmliO1xuICAgIHdoaWxlICgoYXR0cmliID0gYXR0cnNbaV0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdCArPSAnICcgKyBhdHRyaWJbMF0gKyAnPVwiJyArIHRoaXMuZXNjKGF0dHJpYlsxXSkgKyAnXCInO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuICBpZihzZWxmY2xvc2luZykge1xuICAgIHJlc3VsdCArPSAnIC8nO1xuICB9XG4gIHJlc3VsdCArPSAnPic7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHF1aWNrIGJyb3dzZXItY29tcGF0aWJsZSBpbmhlcml0YW5jZVxuWG1sUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZW5kZXJlci5wcm90b3R5cGUpO1xuXG5YbWxSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gcmVuZGVyO1xuWG1sUmVuZGVyZXIucHJvdG90eXBlLm91dCA9IG91dDtcblhtbFJlbmRlcmVyLnByb3RvdHlwZS5jciA9IGNyO1xuWG1sUmVuZGVyZXIucHJvdG90eXBlLnRhZyA9IHRhZztcblhtbFJlbmRlcmVyLnByb3RvdHlwZS5lc2MgPSByZXF1aXJlKCcuLi9jb21tb24nKS5lc2NhcGVYbWw7XG5cbm1vZHVsZS5leHBvcnRzID0gWG1sUmVuZGVyZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb21tb25tYXJrL2xpYi9yZW5kZXIveG1sLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCBtZXRhVGFnR2VuZXJhdG9yID0gZnVuY3Rpb24oKXtcbiAgICAvLyBleHBlY3RzIGF0IGxlYXN0IG9uZSBzdHJpbmcgb2YgdHlwZSBgYXR0cmlidXRlPVwidmFsdWVcImBcbiAgICBjb25zdCBhcmdBcnIgPSBbLi4uYXJndW1lbnRzXTtcbiAgICBjb25zdCBjaGVja0ZvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkIFsnICsgYXJnQXJyLmpvaW4oJ11bJykgKyAnXScpO1xuICAgIGlmICghY2hlY2tGb3JFbGVtZW50KXtcbiAgICAgICAgY29uc3QgbWV0YUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtZXRhJyk7XG4gICAgICAgIGZvciAobGV0IGFyZ3VtZW50IG9mIGFyZ0Fycil7XG4gICAgICAgICAgICBjb25zdCBzcGxpdCA9IGFyZ3VtZW50LnNwbGl0KCc9XCInKTtcbiAgICAgICAgICAgIG1ldGFFbGVtZW50LnNldEF0dHJpYnV0ZShzcGxpdFswXSwgc3BsaXRbMV0uc3Vic3RyaW5nKDAsIHNwbGl0WzFdLmxlbmd0aC0xKSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChtZXRhRWxlbWVudCk7XG4gICAgICAgIHJldHVybiBtZXRhRWxlbWVudDtcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gY2hlY2tGb3JFbGVtZW50O1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb2N1bWVudCkge1xuICAgIC8vIHNvbWUgZ29vZCBwcmFjdGljZXMgKGVzcGVjaWFsbHkgZm9yIGZyYWdtZW50cylcbiAgICAvLyBhZGQgPG1ldGEgY2hhcnNldD1cIlVURi04XCI+XG4gICAgbWV0YVRhZ0dlbmVyYXRvcignY2hhcnNldD1cIlVURi04XCInKTtcbiAgICAvLyA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMFwiPlxuICAgIG1ldGFUYWdHZW5lcmF0b3IoJ25hbWU9XCJ2aWV3cG9ydFwiJywgJ2NvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wXCInKVxuICAgIC8vIDxtZXRhIGh0dHAtZXF1aXY9XCJYLVVBLUNvbXBhdGlibGVcIiBjb250ZW50PVwiaWU9ZWRnZVwiPlxuICAgIG1ldGFUYWdHZW5lcmF0b3IoJ2h0dHAtZXF1aXY9XCJYLVVBLUNvbXBhdGlibGVcIicsICdjb250ZW50PVwiaWU9ZWRnZVwiJyk7XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9odG1sLWhlYWQuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9jdW1lbnQpIHtcbiAgY29uc3QgVEFHTkFNRVMgPSBbXG4gICAgJ2JvZHknLFxuICAgICdjaGFwdGVyJyxcbiAgICAnc2VjdGlvbicsXG4gICAgJ3RoZW9yZW0nLFxuICAgICdsZW1tYScsXG4gICAgJ3Byb3Bvc2l0aW9uJyxcbiAgICAnY29yb2xsYXJ5JyxcbiAgICAncHJvb2YnLFxuICAgICdhYnN0cmFjdCcsXG4gICAgJ2ZpZ3VyZSdcbiAgXTtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoVEFHTkFNRVMuam9pbignLCcpKTtcbiAgZm9yIChsZXQgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAvLyBmb3IgKGxldCBjaGlsZCBvZiBjYW5kaWRhdGUuY2hpbGROb2Rlcykge1xuICAgIC8vICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAzICYmIGNoaWxkLm5vZGVWYWx1ZS50cmltKCkgIT09ICcnKSB7XG4gICAgLy8gICAgIGNoaWxkLm5vZGVWYWx1ZSA9ICdcXG4nICsgY2hpbGQubm9kZVZhbHVlLnJlcGxhY2UoL1xcbi9nLCAnXFxuXFxuJykgKyAnXFxuJztcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXG5cXG4nKTtcbiAgICBjYW5kaWRhdGUuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgY2FuZGlkYXRlLmluc2VydEJlZm9yZSh0ZXh0LmNsb25lTm9kZSh0cnVlKSwgY2FuZGlkYXRlLmZpcnN0Q2hpbGQpO1xuICB9XG59O1xuXG4vLyB3cmFwIHBocmFzaW5nIGNvbnRlbnQgaW4gcFxuXG4vLyBjb25zdCBQSFJBU0lOR19UQUdOQU1FUyA9IFsnYWJicicsICdhdWRpbycsICdiJywgJ2JkbycsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NpdGUnLCAnY29kZScsICdjb21tYW5kJywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGZuJywgJ2VtJywgJ2VtYmVkJywgJ2knLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdrYmQnLCAna2V5Z2VuJywgJ2xhYmVsJywgJ21hcmsnLCAnbWF0aCcsICdtZXRlcicsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb3V0cHV0JywgJ3Byb2dyZXNzJywgJ3EnLCAncnVieScsICdzYW1wJywgJ3NjcmlwdCcsICdzZWxlY3QnLCAnc21hbGwnLCAnc3BhbicsICdzdHJvbmcnLCAnc3ViJywgJ3N1cCcsICdzdmcnLCAndGV4dGFyZWEnLCAndGltZScsICd2YXInLCAndmlkZW8nLCAnd2JyJywgJ2EnLCAnZGVsJywgJ2lucyddXG4vLyBjb25zdCBjYW5kaWRhdGVzID0gW10vL2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2JvZHksIHNlY3Rpb24sIGZpZ3VyZScpO1xuLy8gZm9yIChsZXQgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpe1xuLy8gICAvLyBjb25zb2xlLmxvZyhjYW5kaWRhdGUpXG4vLyAgIGNvbnN0IGNoaWxkTm9kZXMgPSBjYW5kaWRhdGUuY2hpbGROb2Rlcztcbi8vICAgY29uc3QgYXJyYXlvZmFycmF5cyA9IFtbXV07XG4vLyAgIGZvciAobGV0IGNoaWxkTm9kZSBvZiBjaGlsZE5vZGVzKXtcbi8vICAgICBjb25zdCBjdXJyZW50QmF0Y2ggPSBhcnJheW9mYXJyYXlzW2FycmF5b2ZhcnJheXMubGVuZ3RoIC0xXTtcbi8vICAgICAvLyBjb25zb2xlLmxvZyhjaGlsZE5vZGUpXG4vLyAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMyl7XG4vLyAgICAgICBjb25zdCBsaW5lcyA9IGNoaWxkTm9kZS5kYXRhLnNwbGl0KCdcXG4nKTtcbi8vICAgICAgIGxldCB0ZW1wID0gY2hpbGROb2RlO1xuLy8gICAgICAgZm9yIChsZXQgW2luZGV4LCBsaW5lXSBvZiBsaW5lcy5lbnRyaWVzKCkpe1xuLy8gICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbi8vICAgICAgICAgICBjaGlsZE5vZGUuZGF0YSA9IGxpbmU7XG4vLyAgICAgICAgICAgY3VycmVudEJhdGNoLnB1c2goY2hpbGROb2RlKTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICBjb25zdCBsaW5lRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpO1xuLy8gICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdCZWZvcmUnLCBjaGlsZE5vZGUubmV4dFNpYmxpbmcpXG4vLyAgICAgICAgICAgY2hpbGROb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGxpbmVFbGVtZW50LCB0ZW1wLm5leHRTaWJsaW5nKTtcbi8vICAgICAgICAgICB0ZW1wID0gbGluZUVsZW1lbnQ7XG4vLyAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0FmdGVyJywgY2hpbGROb2RlLm5leHRTaWJsaW5nKVxuLy8gICAgICAgICAgIGFycmF5b2ZhcnJheXMucHVzaChbbGluZUVsZW1lbnRdKTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgICBlbHNlIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggfHwgUEhSQVNJTkdfVEFHTkFNRVMuaW5kZXhPZihjaGlsZE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSA+IC0xKSB7XG4vLyAgICAgICBjdXJyZW50QmF0Y2gucHVzaChjaGlsZE5vZGUpO1xuLy8gICAgIH1cbi8vICAgICBlbHNlIGlmKGN1cnJlbnRCYXRjaC5sZW5ndGggPiAwKSAgYXJyYXlvZmFycmF5cy5wdXNoKFtdKTtcbi8vICAgfVxuLy8gICBjb25zb2xlLmxvZyhhcnJheW9mYXJyYXlzKVxuLy8gICBmb3IgKGxldCBhcnJheSBvZiBhcnJheW9mYXJyYXlzKXtcbi8vICAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSBjb250aW51ZVxuLy8gICAgIGNvbnN0IHBhcmEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4vLyAgICAgY29uc3QgZmlyc3QgPSBhcnJheVswXTtcbi8vICAgICAvLyBjb25zb2xlLmxvZyhmaXJzdCk7XG4vLyAgICAgZmlyc3QucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQocGFyYSwgZmlyc3QpO1xuLy8gICAgIGZvciAobm9kZSBvZiBhcnJheSkgcGFyYS5hcHBlbmRDaGlsZChub2RlKTtcbi8vICAgfVxuLy8gfVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGFyYWdhcGhzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9